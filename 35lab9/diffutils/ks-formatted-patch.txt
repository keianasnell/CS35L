From 29f2e261a159a2bbdd07efd3cf6fb0bdf86824d8 Mon Sep 17 00:00:00 2001
From: Keiana Rei Snell <classksn@lnxsrv02.seas.ucla.edu>
Date: Thu, 7 Jun 2018 18:30:15 -0700
Subject: [PATCH] 2018-06-07  Keiana Rei Snell 
 <classksn@lnxsrv02.seas.ucla.edu>

	* src/cmp.c:    Changed quotes from backtick mark to single apostrophe.
	* src/diff.c:   Changed quotes from backtick mark to single apostrophe.
	* src/diff3.c:  Changed quotes from backtick mark to single apostrophe.
	* src/dir.c:    Changed quotes from backtick mark to single apostrophe.
	* src/sdiff.c:  Changed quotes from backtick mark to single apostrophe.
	* src/util.c:   Changed quotes from backtick mark to single apostrophe.
---
 diffutils-3.0-orig                  |    1 +
 diffutils-3.0-patch/src/Makefile.am |   55 +
 diffutils-3.0-patch/src/analyze.c   |  723 +++++
 diffutils-3.0-patch/src/cmp         |  Bin 0 -> 172097 bytes
 diffutils-3.0-patch/src/cmp.c       |  685 +++++
 diffutils-3.0-patch/src/context.c   |  493 ++++
 diffutils-3.0-patch/src/diff        |  Bin 0 -> 774876 bytes
 diffutils-3.0-patch/src/diff.c      | 1330 +++++++++
 diffutils-3.0-patch/src/diff.h      |  373 +++
 diffutils-3.0-patch/src/diff3       |  Bin 0 -> 238733 bytes
 diffutils-3.0-patch/src/diff3.c     | 1747 ++++++++++++
 diffutils-3.0-patch/src/dir.c       |  283 ++
 diffutils-3.0-patch/src/ed.c        |  175 ++
 diffutils-3.0-patch/src/ifdef.c     |  430 +++
 diffutils-3.0-patch/src/io.c        |  845 ++++++
 diffutils-3.0-patch/src/normal.c    |   69 +
 diffutils-3.0-patch/src/paths.h     |    2 +
 diffutils-3.0-patch/src/sdiff       |  Bin 0 -> 182588 bytes
 diffutils-3.0-patch/src/sdiff.c     | 1236 +++++++++
 diffutils-3.0-patch/src/side.c      |  320 +++
 diffutils-3.0-patch/src/system.h    |  228 ++
 diffutils-3.0-patch/src/util.c      |  788 ++++++
 diffutils-3.0/quote-3.0-test.txt    |    0
 diffutils-3.0/src/Makefile.am       |   80 +
 diffutils-3.0/src/analyze.c         |  716 +++++
 diffutils-3.0/src/cmp.c             |  693 +++++
 diffutils-3.0/src/context.c         |  537 ++++
 diffutils-3.0/src/die.h             |   31 +
 diffutils-3.0/src/diff.c            | 1473 ++++++++++
 diffutils-3.0/src/diff.h            |  423 +++
 diffutils-3.0/src/diff3.c           | 1790 ++++++++++++
 diffutils-3.0/src/dir.c             |  385 +++
 diffutils-3.0/src/ed.c              |  177 ++
 diffutils-3.0/src/ifdef.c           |  431 +++
 diffutils-3.0/src/io.c              |  830 ++++++
 diffutils-3.0/src/normal.c          |   91 +
 diffutils-3.0/src/sdiff.c           | 1173 ++++++++
 diffutils-3.0/src/side.c            |  335 +++
 diffutils-3.0/src/system.h          |  240 ++
 diffutils-3.0/src/util.c            | 1576 +++++++++++
 patch.txt                           |  321 +++
 quote-3.0-patch.txt                 |  321 +++
 quote-3.0-test.txt                  | 5080 +++++++++++++++++++++++++++++++++++
 src/cmp.c.orig                      |  685 +++++
 src/diff.c                          |    6 +-
 src/diff.c.orig                     | 1330 +++++++++
 src/diff3.c.orig                    | 1747 ++++++++++++
 src/dir.c.orig                      |  283 ++
 src/sdiff.c                         |    2 +-
 src/sdiff.c.orig                    | 1236 +++++++++
 src/util.c.orig                     |  788 ++++++
 51 files changed, 32559 insertions(+), 4 deletions(-)
 create mode 160000 diffutils-3.0-orig
 create mode 100644 diffutils-3.0-patch/src/Makefile.am
 create mode 100644 diffutils-3.0-patch/src/analyze.c
 create mode 100755 diffutils-3.0-patch/src/cmp
 create mode 100644 diffutils-3.0-patch/src/cmp.c
 create mode 100644 diffutils-3.0-patch/src/context.c
 create mode 100755 diffutils-3.0-patch/src/diff
 create mode 100644 diffutils-3.0-patch/src/diff.c
 create mode 100644 diffutils-3.0-patch/src/diff.h
 create mode 100755 diffutils-3.0-patch/src/diff3
 create mode 100644 diffutils-3.0-patch/src/diff3.c
 create mode 100644 diffutils-3.0-patch/src/dir.c
 create mode 100644 diffutils-3.0-patch/src/ed.c
 create mode 100644 diffutils-3.0-patch/src/ifdef.c
 create mode 100644 diffutils-3.0-patch/src/io.c
 create mode 100644 diffutils-3.0-patch/src/normal.c
 create mode 100644 diffutils-3.0-patch/src/paths.h
 create mode 100755 diffutils-3.0-patch/src/sdiff
 create mode 100644 diffutils-3.0-patch/src/sdiff.c
 create mode 100644 diffutils-3.0-patch/src/side.c
 create mode 100644 diffutils-3.0-patch/src/system.h
 create mode 100644 diffutils-3.0-patch/src/util.c
 create mode 100644 diffutils-3.0/quote-3.0-test.txt
 create mode 100644 diffutils-3.0/src/Makefile.am
 create mode 100644 diffutils-3.0/src/analyze.c
 create mode 100644 diffutils-3.0/src/cmp.c
 create mode 100644 diffutils-3.0/src/context.c
 create mode 100644 diffutils-3.0/src/die.h
 create mode 100644 diffutils-3.0/src/diff.c
 create mode 100644 diffutils-3.0/src/diff.h
 create mode 100644 diffutils-3.0/src/diff3.c
 create mode 100644 diffutils-3.0/src/dir.c
 create mode 100644 diffutils-3.0/src/ed.c
 create mode 100644 diffutils-3.0/src/ifdef.c
 create mode 100644 diffutils-3.0/src/io.c
 create mode 100644 diffutils-3.0/src/normal.c
 create mode 100644 diffutils-3.0/src/sdiff.c
 create mode 100644 diffutils-3.0/src/side.c
 create mode 100644 diffutils-3.0/src/system.h
 create mode 100644 diffutils-3.0/src/util.c
 create mode 100644 patch.txt
 create mode 100644 quote-3.0-patch.txt
 create mode 100644 quote-3.0-test.txt
 create mode 100644 src/cmp.c.orig
 create mode 100644 src/diff.c.orig
 create mode 100644 src/diff3.c.orig
 create mode 100644 src/dir.c.orig
 create mode 100644 src/sdiff.c.orig
 create mode 100644 src/util.c.orig

diff --git a/diffutils-3.0-orig b/diffutils-3.0-orig
new file mode 160000
index 0000000..576645c
--- /dev/null
+++ b/diffutils-3.0-orig
@@ -0,0 +1 @@
+Subproject commit 576645cdf71342ba8eb60930998655a99b7a8da1
diff --git a/diffutils-3.0-patch/src/Makefile.am b/diffutils-3.0-patch/src/Makefile.am
new file mode 100644
index 0000000..48fbf7d
--- /dev/null
+++ b/diffutils-3.0-patch/src/Makefile.am
@@ -0,0 +1,55 @@
+# Automakefile for GNU diffutils programs.
+
+# Copyright (C) 2001-2002, 2006, 2009-2010 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+bin_PROGRAMS = cmp diff diff3 sdiff
+
+noinst_HEADERS = system.h
+
+localedir = $(datadir)/locale
+
+AM_CPPFLAGS = -I../lib -I$(top_srcdir)/lib
+AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS)
+
+LDADD = \
+  ../lib/libdiffutils.a \
+  $(LIBCSTACK) \
+  $(LIBINTL) \
+  $(LIBICONV) \
+  $(LIBSIGSEGV) \
+  $(LIB_CLOCK_GETTIME)
+
+diff_LDADD = $(LDADD)
+cmp_LDADD = $(LDADD)
+sdiff_LDADD = $(LDADD)
+diff3_LDADD = $(LDADD)
+
+cmp_SOURCES = cmp.c
+diff3_SOURCES = diff3.c
+sdiff_SOURCES = sdiff.c
+diff_SOURCES = \
+  analyze.c context.c diff.c diff.h dir.c ed.c ifdef.c io.c \
+  normal.c side.c util.c
+
+MOSTLYCLEANFILES = paths.h paths.ht
+
+cmp.$(OBJEXT) diff3.$(OBJEXT) diff.$(OBJEXT) sdiff.$(OBJEXT): paths.h
+
+gdiff = `echo diff|sed '$(transform)'`
+BUILT_SOURCES = paths.h
+paths.h: Makefile.am
+	$(AM_V_GEN)(echo '#define DEFAULT_DIFF_PROGRAM "'$(gdiff)'"' && \
+	  echo '#define LOCALEDIR "$(localedir)"') >$@t && mv $@t $@
diff --git a/diffutils-3.0-patch/src/analyze.c b/diffutils-3.0-patch/src/analyze.c
new file mode 100644
index 0000000..e797248
--- /dev/null
+++ b/diffutils-3.0-patch/src/analyze.c
@@ -0,0 +1,723 @@
+/* Analyze file differences for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <error.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* The core of the Diff algorithm.  */
+#define ELEMENT lin
+#define EQUAL(x,y) ((x) == (y))
+#define OFFSET lin
+#define EXTRA_CONTEXT_FIELDS /* none */
+#define NOTE_DELETE(c, xoff) (files[0].changed[files[0].realindexes[xoff]] = 1)
+#define NOTE_INSERT(c, yoff) (files[1].changed[files[1].realindexes[yoff]] = 1)
+#define USE_HEURISTIC 1
+#include <diffseq.h>
+
+/* Discard lines from one file that have no matches in the other file.
+
+   A line which is discarded will not be considered by the actual
+   comparison algorithm; it will be as if that line were not in the file.
+   The file's `realindexes' table maps virtual line numbers
+   (which don't count the discarded lines) into real line numbers;
+   this is how the actual comparison algorithm produces results
+   that are comprehensible when the discarded lines are counted.
+
+   When we discard a line, we also mark it as a deletion or insertion
+   so that it will be printed in the output.  */
+
+static void
+discard_confusing_lines (struct file_data filevec[])
+{
+  int f;
+  lin i;
+  char *discarded[2];
+  lin *equiv_count[2];
+  lin *p;
+
+  /* Allocate our results.  */
+  p = xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
+	       * (2 * sizeof *p));
+  for (f = 0; f < 2; f++)
+    {
+      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
+      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
+    }
+
+  /* Set up equiv_count[F][I] as the number of lines in file F
+     that fall in equivalence class I.  */
+
+  p = zalloc (filevec[0].equiv_max * (2 * sizeof *p));
+  equiv_count[0] = p;
+  equiv_count[1] = p + filevec[0].equiv_max;
+
+  for (i = 0; i < filevec[0].buffered_lines; ++i)
+    ++equiv_count[0][filevec[0].equivs[i]];
+  for (i = 0; i < filevec[1].buffered_lines; ++i)
+    ++equiv_count[1][filevec[1].equivs[i]];
+
+  /* Set up tables of which lines are going to be discarded.  */
+
+  discarded[0] = zalloc (filevec[0].buffered_lines
+			 + filevec[1].buffered_lines);
+  discarded[1] = discarded[0] + filevec[0].buffered_lines;
+
+  /* Mark to be discarded each line that matches no line of the other file.
+     If a line matches many lines, mark it as provisionally discardable.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      size_t end = filevec[f].buffered_lines;
+      char *discards = discarded[f];
+      lin *counts = equiv_count[1 - f];
+      lin *equivs = filevec[f].equivs;
+      size_t many = 5;
+      size_t tem = end / 64;
+
+      /* Multiply MANY by approximate square root of number of lines.
+	 That is the threshold for provisionally discardable lines.  */
+      while ((tem = tem >> 2) > 0)
+	many *= 2;
+
+      for (i = 0; i < end; i++)
+	{
+	  lin nmatch;
+	  if (equivs[i] == 0)
+	    continue;
+	  nmatch = counts[equivs[i]];
+	  if (nmatch == 0)
+	    discards[i] = 1;
+	  else if (nmatch > many)
+	    discards[i] = 2;
+	}
+    }
+
+  /* Don't really discard the provisional lines except when they occur
+     in a run of discardables, with nonprovisionals at the beginning
+     and end.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      lin end = filevec[f].buffered_lines;
+      register char *discards = discarded[f];
+
+      for (i = 0; i < end; i++)
+	{
+	  /* Cancel provisional discards not in middle of run of discards.  */
+	  if (discards[i] == 2)
+	    discards[i] = 0;
+	  else if (discards[i] != 0)
+	    {
+	      /* We have found a nonprovisional discard.  */
+	      register lin j;
+	      lin length;
+	      lin provisional = 0;
+
+	      /* Find end of this run of discardable lines.
+		 Count how many are provisionally discardable.  */
+	      for (j = i; j < end; j++)
+		{
+		  if (discards[j] == 0)
+		    break;
+		  if (discards[j] == 2)
+		    ++provisional;
+		}
+
+	      /* Cancel provisional discards at end, and shrink the run.  */
+	      while (j > i && discards[j - 1] == 2)
+		discards[--j] = 0, --provisional;
+
+	      /* Now we have the length of a run of discardable lines
+		 whose first and last are not provisional.  */
+	      length = j - i;
+
+	      /* If 1/4 of the lines in the run are provisional,
+		 cancel discarding of all provisional lines in the run.  */
+	      if (provisional * 4 > length)
+		{
+		  while (j > i)
+		    if (discards[--j] == 2)
+		      discards[j] = 0;
+		}
+	      else
+		{
+		  register lin consec;
+		  lin minimum = 1;
+		  lin tem = length >> 2;
+
+		  /* MINIMUM is approximate square root of LENGTH/4.
+		     A subrun of two or more provisionals can stand
+		     when LENGTH is at least 16.
+		     A subrun of 4 or more can stand when LENGTH >= 64.  */
+		  while (0 < (tem >>= 2))
+		    minimum <<= 1;
+		  minimum++;
+
+		  /* Cancel any subrun of MINIMUM or more provisionals
+		     within the larger run.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    if (discards[i + j] != 2)
+		      consec = 0;
+		    else if (minimum == ++consec)
+		      /* Back up to start of subrun, to cancel it all.  */
+		      j -= consec;
+		    else if (minimum < consec)
+		      discards[i + j] = 0;
+
+		  /* Scan from beginning of run
+		     until we find 3 or more nonprovisionals in a row
+		     or until the first nonprovisional at least 8 lines in.
+		     Until that point, cancel any provisionals.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i + j] == 1)
+			break;
+		      if (discards[i + j] == 2)
+			consec = 0, discards[i + j] = 0;
+		      else if (discards[i + j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+
+		  /* I advances to the last line of the run.  */
+		  i += length - 1;
+
+		  /* Same thing, from end.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i - j] == 1)
+			break;
+		      if (discards[i - j] == 2)
+			consec = 0, discards[i - j] = 0;
+		      else if (discards[i - j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+		}
+	    }
+	}
+    }
+
+  /* Actually discard the lines. */
+  for (f = 0; f < 2; f++)
+    {
+      char *discards = discarded[f];
+      lin end = filevec[f].buffered_lines;
+      lin j = 0;
+      for (i = 0; i < end; ++i)
+	if (minimal || discards[i] == 0)
+	  {
+	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
+	    filevec[f].realindexes[j++] = i;
+	  }
+	else
+	  filevec[f].changed[i] = 1;
+      filevec[f].nondiscarded_lines = j;
+    }
+
+  free (discarded[0]);
+  free (equiv_count[0]);
+}
+
+/* Adjust inserts/deletes of identical lines to join changes
+   as much as possible.
+
+   We do something when a run of changed lines include a
+   line at one end and have an excluded, identical line at the other.
+   We are free to choose which identical line is included.
+   `compareseq' usually chooses the one at the beginning,
+   but usually it is cleaner to consider the following identical line
+   to be the "change".  */
+
+static void
+shift_boundaries (struct file_data filevec[])
+{
+  int f;
+
+  for (f = 0; f < 2; f++)
+    {
+      char *changed = filevec[f].changed;
+      char *other_changed = filevec[1 - f].changed;
+      lin const *equivs = filevec[f].equivs;
+      lin i = 0;
+      lin j = 0;
+      lin i_end = filevec[f].buffered_lines;
+
+      while (1)
+	{
+	  lin runlength, start, corresponding;
+
+	  /* Scan forwards to find beginning of another run of changes.
+	     Also keep track of the corresponding point in the other file.  */
+
+	  while (i < i_end && !changed[i])
+	    {
+	      while (other_changed[j++])
+		continue;
+	      i++;
+	    }
+
+	  if (i == i_end)
+	    break;
+
+	  start = i;
+
+	  /* Find the end of this run of changes.  */
+
+	  while (changed[++i])
+	    continue;
+	  while (other_changed[j])
+	    j++;
+
+	  do
+	    {
+	      /* Record the length of this run of changes, so that
+		 we can later determine whether the run has grown.  */
+	      runlength = i - start;
+
+	      /* Move the changed region back, so long as the
+		 previous unchanged line matches the last changed one.
+		 This merges with previous changed regions.  */
+
+	      while (start && equivs[start - 1] == equivs[i - 1])
+		{
+		  changed[--start] = 1;
+		  changed[--i] = 0;
+		  while (changed[start - 1])
+		    start--;
+		  while (other_changed[--j])
+		    continue;
+		}
+
+	      /* Set CORRESPONDING to the end of the changed run, at the last
+		 point where it corresponds to a changed run in the other file.
+		 CORRESPONDING == I_END means no such point has been found.  */
+	      corresponding = other_changed[j - 1] ? i : i_end;
+
+	      /* Move the changed region forward, so long as the
+		 first changed line matches the following unchanged one.
+		 This merges with following changed regions.
+		 Do this second, so that if there are no merges,
+		 the changed region is moved forward as far as possible.  */
+
+	      while (i != i_end && equivs[start] == equivs[i])
+		{
+		  changed[start++] = 0;
+		  changed[i++] = 1;
+		  while (changed[i])
+		    i++;
+		  while (other_changed[++j])
+		    corresponding = i;
+		}
+	    }
+	  while (runlength != i - start);
+
+	  /* If possible, move the fully-merged run of changes
+	     back to a corresponding run in the other file.  */
+
+	  while (corresponding < i)
+	    {
+	      changed[--start] = 1;
+	      changed[--i] = 0;
+	      while (other_changed[--j])
+		continue;
+	    }
+	}
+    }
+}
+
+/* Cons an additional entry onto the front of an edit script OLD.
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+static struct change *
+add_change (lin line0, lin line1, lin deleted, lin inserted,
+	    struct change *old)
+{
+  struct change *new = xmalloc (sizeof *new);
+
+  new->line0 = line0;
+  new->line1 = line1;
+  new->inserted = inserted;
+  new->deleted = deleted;
+  new->link = old;
+  return new;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in reverse order.  */
+
+static struct change *
+build_reverse_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin len0 = filevec[0].buffered_lines;
+  lin len1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[lenN] does exist, and is 0.  */
+
+  lin i0 = 0, i1 = 0;
+
+  while (i0 < len0 || i1 < len1)
+    {
+      if (changed0[i0] | changed1[i1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0]) ++i0;
+	  while (changed1[i1]) ++i1;
+
+	  /* Record this change.  */
+	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0++, i1++;
+    }
+
+  return script;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in forward order.  */
+
+static struct change *
+build_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[-1] does exist, and is 0.  */
+
+  while (i0 >= 0 || i1 >= 0)
+    {
+      if (changed0[i0 - 1] | changed1[i1 - 1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0 - 1]) --i0;
+	  while (changed1[i1 - 1]) --i1;
+
+	  /* Record this change.  */
+	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0--, i1--;
+    }
+
+  return script;
+}
+
+/* If CHANGES, briefly report that two files differed.
+   Return 2 if trouble, CHANGES otherwise.  */
+static int
+briefly_report (int changes, struct file_data const filevec[])
+{
+  if (changes)
+    {
+      char const *label0 = file_label[0] ? file_label[0] : filevec[0].name;
+      char const *label1 = file_label[1] ? file_label[1] : filevec[1].name;
+
+      if (brief)
+	message ("Files %s and %s differ\n", label0, label1);
+      else
+	{
+	  message ("Binary files %s and %s differ\n", label0, label1);
+	  changes = 2;
+	}
+    }
+
+  return changes;
+}
+
+/* Report the differences of two files.  */
+int
+diff_2_files (struct comparison *cmp)
+{
+  int f;
+  struct change *e, *p;
+  struct change *script;
+  int changes;
+
+
+  /* If we have detected that either file is binary,
+     compare the two files as binary.  This can happen
+     only when the first chunk is read.
+     Also, --brief without any --ignore-* options means
+     we can speed things up by treating the files as binary.  */
+
+  if (read_files (cmp->file, files_can_be_treated_as_binary))
+    {
+      /* Files with different lengths must be different.  */
+      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
+	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+	changes = 1;
+
+      /* Standard input equals itself.  */
+      else if (cmp->file[0].desc == cmp->file[1].desc)
+	changes = 0;
+
+      else
+	/* Scan both files, a buffer at a time, looking for a difference.  */
+	{
+	  /* Allocate same-sized buffers for both files.  */
+	  size_t lcm_max = PTRDIFF_MAX - 1;
+	  size_t buffer_size =
+	    buffer_lcm (sizeof (word),
+			buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
+				    STAT_BLOCKSIZE (cmp->file[1].stat),
+				    lcm_max),
+			lcm_max);
+	  for (f = 0; f < 2; f++)
+	    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
+
+	  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
+	    {
+	      /* Read a buffer's worth from both files.  */
+	      for (f = 0; f < 2; f++)
+		if (0 <= cmp->file[f].desc)
+		  file_block_read (&cmp->file[f],
+				   buffer_size - cmp->file[f].buffered);
+
+	      /* If the buffers differ, the files differ.  */
+	      if (cmp->file[0].buffered != cmp->file[1].buffered
+		  || memcmp (cmp->file[0].buffer,
+			     cmp->file[1].buffer,
+			     cmp->file[0].buffered))
+		{
+		  changes = 1;
+		  break;
+		}
+
+	      /* If we reach end of file, the files are the same.  */
+	      if (cmp->file[0].buffered != buffer_size)
+		{
+		  changes = 0;
+		  break;
+		}
+	    }
+	}
+
+      changes = briefly_report (changes, cmp->file);
+    }
+  else
+    {
+      struct context ctxt;
+      lin diags;
+      lin too_expensive;
+
+      /* Allocate vectors for the results of comparison:
+	 a flag for each line of each file, saying whether that line
+	 is an insertion or deletion.
+	 Allocate an extra element, always 0, at each end of each vector.  */
+
+      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;
+      char *flag_space = zalloc (s);
+      cmp->file[0].changed = flag_space + 1;
+      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;
+
+      /* Some lines are obviously insertions or deletions
+	 because they don't match anything.  Detect them now, and
+	 avoid even thinking about them in the main comparison algorithm.  */
+
+      discard_confusing_lines (cmp->file);
+
+      /* Now do the main comparison algorithm, considering just the
+	 undiscarded lines.  */
+
+      ctxt.xvec = cmp->file[0].undiscarded;
+      ctxt.yvec = cmp->file[1].undiscarded;
+      diags = (cmp->file[0].nondiscarded_lines
+	       + cmp->file[1].nondiscarded_lines + 3);
+      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));
+      ctxt.bdiag = ctxt.fdiag + diags;
+      ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;
+      ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1;
+
+      ctxt.heuristic = speed_large_files;
+
+      /* Set TOO_EXPENSIVE to be approximate square root of input size,
+	 bounded below by 256.  */
+      too_expensive = 1;
+      for (;  diags != 0;  diags >>= 2)
+	too_expensive <<= 1;
+      ctxt.too_expensive = MAX (256, too_expensive);
+
+      files[0] = cmp->file[0];
+      files[1] = cmp->file[1];
+
+      compareseq (0, cmp->file[0].nondiscarded_lines,
+		  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
+
+      free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));
+
+      /* Modify the results slightly to make them prettier
+	 in cases where that can validly be done.  */
+
+      shift_boundaries (cmp->file);
+
+      /* Get the results of comparison in the form of a chain
+	 of `struct change's -- an edit script.  */
+
+      if (output_style == OUTPUT_ED)
+	script = build_reverse_script (cmp->file);
+      else
+	script = build_script (cmp->file);
+
+      /* Set CHANGES if we had any diffs.
+	 If some changes are ignored, we must scan the script to decide.  */
+      if (ignore_blank_lines || ignore_regexp.fastmap)
+	{
+	  struct change *next = script;
+	  changes = 0;
+
+	  while (next && changes == 0)
+	    {
+	      struct change *this, *end;
+	      lin first0, last0, first1, last1;
+
+	      /* Find a set of changes that belong together.  */
+	      this = next;
+	      end = find_change (next);
+
+	      /* Disconnect them from the rest of the changes, making them
+		 a hunk, and remember the rest for next iteration.  */
+	      next = end->link;
+	      end->link = 0;
+
+	      /* Determine whether this hunk is really a difference.  */
+	      if (analyze_hunk (this, &first0, &last0, &first1, &last1))
+		changes = 1;
+
+	      /* Reconnect the script so it will all be freed properly.  */
+	      end->link = next;
+	    }
+	}
+      else
+	changes = (script != 0);
+
+      if (brief)
+	changes = briefly_report (changes, cmp->file);
+      else
+	{
+	  if (changes || !no_diff_means_no_output)
+	    {
+	      /* Record info for starting up output,
+		 to be used if and when we have some output to print.  */
+	      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
+			    file_label[1] ? file_label[1] : cmp->file[1].name,
+			    cmp->parent != 0);
+
+	      switch (output_style)
+		{
+		case OUTPUT_CONTEXT:
+		  print_context_script (script, false);
+		  break;
+
+		case OUTPUT_UNIFIED:
+		  print_context_script (script, true);
+		  break;
+
+		case OUTPUT_ED:
+		  print_ed_script (script);
+		  break;
+
+		case OUTPUT_FORWARD_ED:
+		  pr_forward_ed_script (script);
+		  break;
+
+		case OUTPUT_RCS:
+		  print_rcs_script (script);
+		  break;
+
+		case OUTPUT_NORMAL:
+		  print_normal_script (script);
+		  break;
+
+		case OUTPUT_IFDEF:
+		  print_ifdef_script (script);
+		  break;
+
+		case OUTPUT_SDIFF:
+		  print_sdiff_script (script);
+		  break;
+
+		default:
+		  abort ();
+		}
+
+	      finish_output ();
+	    }
+	}
+
+      free (cmp->file[0].undiscarded);
+
+      free (flag_space);
+
+      for (f = 0; f < 2; f++)
+	{
+	  free (cmp->file[f].equivs);
+	  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
+	}
+
+      for (e = script; e; e = p)
+	{
+	  p = e->link;
+	  free (e);
+	}
+
+      if (! ROBUST_OUTPUT_STYLE (output_style))
+	for (f = 0; f < 2; ++f)
+	  if (cmp->file[f].missing_newline)
+	    {
+	      error (0, 0, "%s: %s\n",
+		     file_label[f] ? file_label[f] : cmp->file[f].name,
+		     _("No newline at end of file"));
+	      changes = 2;
+	    }
+    }
+
+  if (cmp->file[0].buffer != cmp->file[1].buffer)
+    free (cmp->file[0].buffer);
+  free (cmp->file[1].buffer);
+
+  return changes;
+}
diff --git a/diffutils-3.0-patch/src/cmp b/diffutils-3.0-patch/src/cmp
new file mode 100755
index 0000000000000000000000000000000000000000..1609b069706671b2f8a235aa81d028e2fd953cb3
GIT binary patch
literal 172097
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%0DNg<67m$s~t;VwyVkzG<xqf;aSPu8!hYiP9S
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
K4o_Im*Z&`8{D=Dh

literal 0
HcmV?d00001

diff --git a/diffutils-3.0-patch/src/cmp.c b/diffutils-3.0-patch/src/cmp.c
new file mode 100644
index 0000000..e19f013
--- /dev/null
+++ b/diffutils-3.0-patch/src/cmp.c
@@ -0,0 +1,685 @@
+/* cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *);
+static size_t block_compare_and_count (word const *, word const *, off_t *);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value '%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b  --print-bytes  Print differing bytes."),
+  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
+  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
+  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
+  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
+  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
+  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare two files byte by byte."));
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n%s\n\n%s\n%s\n",
+	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after '%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand '%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    xfreopen (NULL, "rb", stdin);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      error (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
+   using `buffer[0]' and `buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of `read0' and `read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      /* Insert sentinels for the block compare.  */
+
+      buf0[read0] = ~buf1[read0];
+      buf1[read1] = ~buf0[read1];
+
+      /* If the line number should be written for differing files,
+	 compare the blocks and count the number of newlines
+	 simultaneously.  */
+      first_diff = (comparison_type == type_first_diff
+		    ? block_compare_and_count (buffer0, buffer1, &line_number)
+		    : block_compare (buffer0, buffer1));
+
+      byte_number += first_diff;
+      smaller = MIN (read0, read1);
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX 1003.1-2001 for this format.  This
+		       message is used only in the POSIX locale, so it
+		       need not be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		}
+	      }
+	      /* Fall through.  */
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX 1003.1-2001 for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ,
+   and count the number of '\n' occurrences in the common
+   part of P0 and P1.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.
+   Increment *COUNT by the count of '\n' occurrences.  */
+
+static size_t
+block_compare_and_count (word const *p0, word const *p1, off_t *count)
+{
+  word l;		/* One word from first buffer. */
+  word const *l0, *l1;	/* Pointers into each buffer. */
+  char const *c0, *c1;	/* Pointers for finding exact address. */
+  size_t cnt = 0;	/* Number of '\n' occurrences. */
+  word nnnn;		/* Newline, sizeof (word) times.  */
+  int i;
+
+  nnnn = 0;
+  for (i = 0; i < sizeof nnnn; i++)
+    nnnn = (nnnn << CHAR_BIT) | '\n';
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
+    {
+      l ^= nnnn;
+      for (i = 0; i < sizeof l; i++)
+	{
+	  unsigned char uc = l;
+	  cnt += ! uc;
+	  l >>= CHAR_BIT;
+	}
+    }
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    cnt += *c0 == '\n';
+
+  *count += cnt;
+  return c0 - (char const *) p0;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/diffutils-3.0-patch/src/context.c b/diffutils-3.0-patch/src/context.c
new file mode 100644
index 0000000..0be8cc5
--- /dev/null
+++ b/diffutils-3.0-patch/src/context.c
@@ -0,0 +1,493 @@
+/* Context-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include "c-ctype.h"
+#include <inttostr.h>
+#include <stat-time.h>
+#include <strftime.h>
+
+static char const *find_function (char const * const *, lin);
+static struct change *find_hunk (struct change *);
+static void mark_ignorable (struct change *);
+static void pr_context_hunk (struct change *);
+static void pr_unidiff_hunk (struct change *);
+
+/* Last place find_function started searching from.  */
+static lin find_function_last_search;
+
+/* The value find_function returned when it started searching there.  */
+static lin find_function_last_match;
+
+/* Print a label for a context diff, with a file name and date or a label.  */
+
+static void
+print_context_label (char const *mark,
+		     struct file_data *inf,
+		     char const *label)
+{
+  if (label)
+    fprintf (outfile, "%s %s\n", mark, label);
+  else
+    {
+      char buf[MAX (INT_STRLEN_BOUND (int) + 32,
+		    INT_STRLEN_BOUND (time_t) + 11)];
+      struct tm const *tm = localtime (&inf->stat.st_mtime);
+      int nsec = get_stat_mtime_ns (&inf->stat);
+      if (! (tm && nstrftime (buf, sizeof buf, time_format, tm, 0, nsec)))
+	{
+	  verify (TYPE_IS_INTEGER (time_t));
+	  if (LONG_MIN <= TYPE_MINIMUM (time_t)
+	      && TYPE_MAXIMUM (time_t) <= LONG_MAX)
+	    {
+	      long int sec = inf->stat.st_mtime;
+	      sprintf (buf, "%ld.%.9d", sec, nsec);
+	    }
+	  else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
+	    {
+	      intmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
+	    }
+	  else
+	    {
+	      uintmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+	    }
+	}
+      fprintf (outfile, "%s %s\t%s\n", mark, inf->name, buf);
+    }
+}
+
+/* Print a header for a context diff, with the file names and dates.  */
+
+void
+print_context_header (struct file_data inf[], bool unidiff)
+{
+  if (unidiff)
+    {
+      print_context_label ("---", &inf[0], file_label[0]);
+      print_context_label ("+++", &inf[1], file_label[1]);
+    }
+  else
+    {
+      print_context_label ("***", &inf[0], file_label[0]);
+      print_context_label ("---", &inf[1], file_label[1]);
+    }
+}
+
+/* Print an edit script in context format.  */
+
+void
+print_context_script (struct change *script, bool unidiff)
+{
+  if (ignore_blank_lines || ignore_regexp.fastmap)
+    mark_ignorable (script);
+  else
+    {
+      struct change *e;
+      for (e = script; e; e = e->link)
+	e->ignore = false;
+    }
+
+  find_function_last_search = - files[0].prefix_lines;
+  find_function_last_match = LIN_MAX;
+
+  if (unidiff)
+    print_script (script, find_hunk, pr_unidiff_hunk);
+  else
+    print_script (script, find_hunk, pr_context_hunk);
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is not greater, use the first in place of it.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_context_number_range (struct file_data const *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B <= A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.
+
+     POSIX 1003.1-2001 requires two line numbers separated by a comma
+     even if the line numbers are the same.  However, this does not
+     match existing practice and is surely an error in the
+     specification.  */
+
+  if (trans_b <= trans_a)
+    fprintf (outfile, "%ld", trans_b);
+  else
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b);
+}
+
+/* Print FUNCTION in a context header.  */
+static void
+print_context_function (FILE *out, char const *function)
+{
+  int i, j;
+  putc (' ', out);
+  for (i = 0; c_isspace ((unsigned char) function[i]) && function[i] != '\n'; i++)
+    continue;
+  for (j = i; j < i + 40 && function[j] != '\n'; j++)
+    continue;
+  while (i < j && c_isspace ((unsigned char) function[j - 1]))
+    j--;
+  fwrite (function + i, sizeof (char), j - i, out);
+}
+
+/* Print a portion of an edit script in context format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a `link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_context_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1, i;
+  char const *prefix;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (! changes)
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("***************", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  fputs ("\n*** ", out);
+  print_context_number_range (&files[0], first0, last0);
+  fputs (" ****\n", out);
+
+  if (changes & OLD)
+    {
+      struct change *next = hunk;
+
+      for (i = first0; i <= last0; i++)
+	{
+	  /* Skip past changes that apply (in file 0)
+	     only to lines before line I.  */
+
+	  while (next && next->line0 + next->deleted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line0 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were inserted here in file 1, this is "changed".
+	       Otherwise it is "deleted".  */
+	    prefix = (next->inserted > 0 ? "!" : "-");
+
+	  print_1_line (prefix, &files[0].linbuf[i]);
+	}
+    }
+
+  fputs ("--- ", out);
+  print_context_number_range (&files[1], first1, last1);
+  fputs (" ----\n", out);
+
+  if (changes & NEW)
+    {
+      struct change *next = hunk;
+
+      for (i = first1; i <= last1; i++)
+	{
+	  /* Skip past changes that apply (in file 1)
+	     only to lines before line I.  */
+
+	  while (next && next->line1 + next->inserted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line1 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were deleted here in file 0, this is "changed".
+	       Otherwise it is "inserted".  */
+	    prefix = (next->deleted > 0 ? "!" : "+");
+
+	  print_1_line (prefix, &files[1].linbuf[i]);
+	}
+    }
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is smaller, use the first in place of it.
+   If the numbers are equal, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B < A in the case of a range of no lines.
+     In this case, we print the line number before the range,
+     which is B.  It would be more logical to print A, but
+     'patch' expects B in order to detect diffs against empty files.  */
+  if (trans_b <= trans_a)
+    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
+  else
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
+}
+
+/* Print a portion of an edit script in unidiff format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a `link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_unidiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  lin i, j, k;
+  struct change *next;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  if (! analyze_hunk (hunk, &first0, &last0, &first1, &last1))
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("@@ -", out);
+  print_unidiff_number_range (&files[0], first0, last0);
+  fputs (" +", out);
+  print_unidiff_number_range (&files[1], first1, last1);
+  fputs (" @@", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  putc ('\n', out);
+
+  next = hunk;
+  i = first0;
+  j = first1;
+
+  while (i <= last0 || j <= last1)
+    {
+
+      /* If the line isn't a difference, output the context from file 0. */
+
+      if (!next || i < next->line0)
+	{
+	  char const *const *line = &files[0].linbuf[i++];
+	  if (! (suppress_blank_empty && **line == '\n'))
+	    putc (initial_tab ? '\t' : ' ', out);
+	  print_1_line (NULL, line);
+	  j++;
+	}
+      else
+	{
+	  /* For each difference, first output the deleted part. */
+
+	  k = next->deleted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[0].linbuf[i++];
+	      putc ('-', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* Then output the inserted part. */
+
+	  k = next->inserted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[1].linbuf[j++];
+	      putc ('+', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* We're done with this hunk, so on to the next! */
+
+	  next = next->link;
+	}
+    }
+}
+
+/* Scan a (forward-ordered) edit script for the first place that more than
+   2*CONTEXT unchanged lines appear, and return a pointer
+   to the `struct change' for the last change before those lines.  */
+
+static struct change *
+find_hunk (struct change *start)
+{
+  struct change *prev;
+  lin top0, top1;
+  lin thresh;
+
+  /* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable
+     changes, but only CONTEXT if one is ignorable.  Watch out for
+     integer overflow, though.  */
+  lin non_ignorable_threshold =
+    (LIN_MAX - 1) / 2 < context ? LIN_MAX : 2 * context + 1;
+  lin ignorable_threshold = context;
+
+  do
+    {
+      /* Compute number of first line in each file beyond this changed.  */
+      top0 = start->line0 + start->deleted;
+      top1 = start->line1 + start->inserted;
+      prev = start;
+      start = start->link;
+      thresh = (prev->ignore || (start && start->ignore)
+		? ignorable_threshold
+		: non_ignorable_threshold);
+      /* It is not supposed to matter which file we check in the end-test.
+	 If it would matter, crash.  */
+      if (start && start->line0 - top0 != start->line1 - top1)
+	abort ();
+    } while (start
+	     /* Keep going if less than THRESH lines
+		elapse before the affected line.  */
+	     && start->line0 - top0 < thresh);
+
+  return prev;
+}
+
+/* Set the `ignore' flag properly in each change in SCRIPT.
+   It should be 1 if all the lines inserted or deleted in that change
+   are ignorable lines.  */
+
+static void
+mark_ignorable (struct change *script)
+{
+  while (script)
+    {
+      struct change *next = script->link;
+      lin first0, last0, first1, last1;
+
+      /* Turn this change into a hunk: detach it from the others.  */
+      script->link = NULL;
+
+      /* Determine whether this change is ignorable.  */
+      script->ignore = ! analyze_hunk (script,
+				       &first0, &last0, &first1, &last1);
+
+      /* Reconnect the chain as before.  */
+      script->link = next;
+
+      /* Advance to the following change.  */
+      script = next;
+    }
+}
+
+/* Find the last function-header line in LINBUF prior to line number LINENUM.
+   This is a line containing a match for the regexp in `function_regexp'.
+   Return the address of the text, or NULL if no function-header is found.  */
+
+static char const *
+find_function (char const * const *linbuf, lin linenum)
+{
+  lin i = linenum;
+  lin last = find_function_last_search;
+  find_function_last_search = i;
+
+  while (last <= --i)
+    {
+      /* See if this line is what we want.  */
+      char const *line = linbuf[i];
+      size_t linelen = linbuf[i + 1] - line - 1;
+
+      /* FIXME: re_search's size args should be size_t, not int.  */
+      int len = MIN (linelen, INT_MAX);
+
+      if (0 <= re_search (&function_regexp, line, len, 0, len, NULL))
+	{
+	  find_function_last_match = i;
+	  return line;
+	}
+    }
+  /* If we search back to where we started searching the previous time,
+     find the line we found last time.  */
+  if (find_function_last_match != LIN_MAX)
+    return linbuf[find_function_last_match];
+
+  return NULL;
+}
diff --git a/diffutils-3.0-patch/src/diff b/diffutils-3.0-patch/src/diff
new file mode 100755
index 0000000000000000000000000000000000000000..0c4945a9b58729111bf5cd4488755348fc04597b
GIT binary patch
literal 774876
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
U@gde2HY{VTYEIGk@2$-L0t6K=K>z>%

literal 0
HcmV?d00001

diff --git a/diffutils-3.0-patch/src/diff.c b/diffutils-3.0-patch/src/diff.c
new file mode 100644
index 0000000..365bea0
--- /dev/null
+++ b/diffutils-3.0-patch/src/diff.c
@@ -0,0 +1,1330 @@
+/* diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in 'regexps' */
+  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* When comparing directories, if a file appears only in one
+   directory, treat it as present but empty in the other (-N).
+   Then `patch' would create the file with appropriate contents.  */
+static bool new_file;
+
+/* When comparing directories, if a file appears only in the second
+   directory of the two, treat it as present but empty in the other
+   (--unidirectional-new-file).
+   Then `patch' would create the file with appropriate contents.  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (! ISDIGIT (prev))
+	    ocontext = c - '0';
+	  else if (LIN_MAX / 10 < ocontext
+		   || ((ocontext = 10 * ocontext + c - '0') < 0))
+	    ocontext = LIN_MAX;
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (LIN_MAX < numval)
+		  numval = LIN_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
+	    ignore_white_space = IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    xfreopen (NULL, "wb", stdout);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    intmax_t t = expand_tabs ? 1 : tabsize;
+    intmax_t w = width;
+    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
+    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (0, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("Compare files line by line."),
+  "",
+  N_("-i  --ignore-case  Ignore case differences in file contents."),
+  N_("--ignore-file-name-case  Ignore case when comparing file names."),
+  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-w  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+#if O_BINARY
+  N_("--binary  Read and write data in binary mode."),
+#endif
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
+-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
+  --label LABEL  Use LABEL instead of file name.\n\
+  -p  --show-c-function  Show which C function each change is in.\n\
+  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
+  N_("-q  --brief  Output only whether files differ."),
+  N_("-e  --ed  Output an ed script."),
+  N_("--normal  Output a normal diff."),
+  N_("-n  --rcs  Output an RCS format diff."),
+  N_("-y  --side-by-side  Output in two columns.\n\
+  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+  --left-column  Output only the left column of common lines.\n\
+  --suppress-common-lines  Do not output common lines."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
+  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+  N_("  GFMT may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1"),
+  N_("  LFMT may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Either GFMT or LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO"),
+  "",
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+  "",
+  N_("-r  --recursive  Recursively compare any subdirectories found."),
+  N_("-N  --new-file  Treat absent files as empty."),
+  N_("--unidirectional-new-file  Treat absent first files as empty."),
+  N_("-s  --report-identical-files  Report when two files are the same."),
+  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
+  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
+  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
+  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
+  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+  "",
+  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("--speed-large-files  Assume large files and many scattered small changes."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+  N_("If a FILE is '-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && strcmp (*var, value) != 0)
+    {
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= dir_file_pathname (parent->file[0].name, name0);
+      cmp.file[1].name = free1
+	= dir_file_pathname (parent->file[1].name, name1);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
+		xfreopen (NULL, "rb", stdin);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+	       && ! parent
+	       && cmp.file[1 - f].desc == UNOPENED)))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare '-' to a directory");
+
+      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && (! S_ISREG (cmp.file[0].stat.st_mode)
+		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/diffutils-3.0-patch/src/diff.h b/diffutils-3.0-patch/src/diff.h
new file mode 100644
index 0000000..71b33f4
--- /dev/null
+++ b/diffutils-3.0-patch/src/diff.h
@@ -0,0 +1,373 @@
+/* Shared definitions for GNU DIFF
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include <regex.h>
+#include <stdio.h>
+#include <unlocked-io.h>
+
+/* What kind of changes a hunk contains.  */
+enum changes
+{
+  /* No changes: lines common to both files.  */
+  UNCHANGED,
+
+  /* Deletes only: lines taken from just the first file.  */
+  OLD,
+
+  /* Inserts only: lines taken from just the second file.  */
+  NEW,
+
+  /* Both deletes and inserts: a hunk containing both old and new lines.  */
+  CHANGED
+};
+
+/* Variables for command line options */
+
+#ifndef GDIFF_MAIN
+# define XTERN extern
+#else
+# define XTERN
+#endif
+
+enum output_style
+{
+  /* No output style specified.  */
+  OUTPUT_UNSPECIFIED,
+
+  /* Default output style.  */
+  OUTPUT_NORMAL,
+
+  /* Output the differences with lines of context before and after (-c).  */
+  OUTPUT_CONTEXT,
+
+  /* Output the differences in a unified context diff format (-u).  */
+  OUTPUT_UNIFIED,
+
+  /* Output the differences as commands suitable for `ed' (-e).  */
+  OUTPUT_ED,
+
+  /* Output the diff as a forward ed script (-f).  */
+  OUTPUT_FORWARD_ED,
+
+  /* Like -f, but output a count of changed lines in each "command" (-n).  */
+  OUTPUT_RCS,
+
+  /* Output merged #ifdef'd file (-D).  */
+  OUTPUT_IFDEF,
+
+  /* Output sdiff style (-y).  */
+  OUTPUT_SDIFF
+};
+
+/* True for output styles that are robust,
+   i.e. can handle a file that ends in a non-newline.  */
+#define ROBUST_OUTPUT_STYLE(S) ((S) != OUTPUT_ED && (S) != OUTPUT_FORWARD_ED)
+
+XTERN enum output_style output_style;
+
+/* Nonzero if output cannot be generated for identical files.  */
+XTERN bool no_diff_means_no_output;
+
+/* Number of lines of context to show in each set of diffs.
+   This is zero when context is not to be shown.  */
+XTERN lin context;
+
+/* Consider all files as text files (-a).
+   Don't interpret codes over 0177 as implying a "binary file".  */
+XTERN bool text;
+
+/* Number of lines to keep in identical prefix and suffix.  */
+XTERN lin horizon_lines;
+
+/* The significance of white space during comparisons.  */
+XTERN enum
+{
+  /* All white space is significant (the default).  */
+  IGNORE_NO_WHITE_SPACE,
+
+  /* Ignore changes due to tab expansion (-E).  */
+  IGNORE_TAB_EXPANSION,
+
+  /* Ignore changes in horizontal white space (-b).  */
+  IGNORE_SPACE_CHANGE,
+
+  /* Ignore all horizontal white space (-w).  */
+  IGNORE_ALL_SPACE
+} ignore_white_space;
+
+/* Ignore changes that affect only blank lines (-B).  */
+XTERN bool ignore_blank_lines;
+
+/* Files can be compared byte-by-byte, as if they were binary.
+   This depends on various options.  */
+XTERN bool files_can_be_treated_as_binary;
+
+/* Ignore differences in case of letters (-i).  */
+XTERN bool ignore_case;
+
+/* Ignore differences in case of letters in file names.  */
+XTERN bool ignore_file_name_case;
+
+/* File labels for `-c' output headers (--label).  */
+XTERN char *file_label[2];
+
+/* Regexp to identify function-header lines (-F).  */
+XTERN struct re_pattern_buffer function_regexp;
+
+/* Ignore changes that affect only lines matching this regexp (-I).  */
+XTERN struct re_pattern_buffer ignore_regexp;
+
+/* Say only whether files differ, not how (-q).  */
+XTERN bool brief;
+
+/* Expand tabs in the output so the text lines up properly
+   despite the characters added to the front of each line (-t).  */
+XTERN bool expand_tabs;
+
+/* Number of columns between tab stops.  */
+XTERN size_t tabsize;
+
+/* Use a tab in the output, rather than a space, before the text of an
+   input line, so as to keep the proper alignment in the input line
+   without changing the characters in it (-T).  */
+XTERN bool initial_tab;
+
+/* Do not output an initial space or tab before the text of an empty line.  */
+XTERN bool suppress_blank_empty;
+
+/* Remove trailing carriage returns from input.  */
+XTERN bool strip_trailing_cr;
+
+/* In directory comparison, specify file to start with (-S).
+   This is used for resuming an aborted comparison.
+   All file names less than this name are ignored.  */
+XTERN char const *starting_file;
+
+/* Pipe each file's output through pr (-l).  */
+XTERN bool paginate;
+
+/* Line group formats for unchanged, old, new, and changed groups.  */
+XTERN char const *group_format[CHANGED + 1];
+
+/* Line formats for unchanged, old, and new lines.  */
+XTERN char const *line_format[NEW + 1];
+
+/* If using OUTPUT_SDIFF print extra information to help the sdiff filter.  */
+XTERN bool sdiff_merge_assist;
+
+/* Tell OUTPUT_SDIFF to show only the left version of common lines.  */
+XTERN bool left_column;
+
+/* Tell OUTPUT_SDIFF to not show common lines.  */
+XTERN bool suppress_common_lines;
+
+/* The half line width and column 2 offset for OUTPUT_SDIFF.  */
+XTERN size_t sdiff_half_width;
+XTERN size_t sdiff_column2_offset;
+
+/* String containing all the command options diff received,
+   with spaces between and at the beginning but none at the end.
+   If there were no options given, this string is empty.  */
+XTERN char *switch_string;
+
+/* Use heuristics for better speed with large files with a small
+   density of changes.  */
+XTERN bool speed_large_files;
+
+/* Patterns that match file names to be excluded.  */
+XTERN struct exclude *excluded;
+
+/* Don't discard lines.  This makes things slower (sometimes much
+   slower) but will find a guaranteed minimal set of changes.  */
+XTERN bool minimal;
+
+/* The strftime format to use for time strings.  */
+XTERN char const *time_format;
+
+/* The result of comparison is an "edit script": a chain of `struct change'.
+   Each `struct change' represents one place where some lines are deleted
+   and some are inserted.
+
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+struct change
+{
+  struct change *link;		/* Previous or next edit command  */
+  lin inserted;			/* # lines of file 1 changed here.  */
+  lin deleted;			/* # lines of file 0 changed here.  */
+  lin line0;			/* Line number of 1st deleted line.  */
+  lin line1;			/* Line number of 1st inserted line.  */
+  bool ignore;			/* Flag used in context.c.  */
+};
+
+/* Structures that describe the input files.  */
+
+/* Data on one input file being compared.  */
+
+struct file_data {
+    int             desc;	/* File descriptor  */
+    char const      *name;	/* File name  */
+    struct stat     stat;	/* File status */
+
+    /* Buffer in which text of file is read.  */
+    word *buffer;
+
+    /* Allocated size of buffer, in bytes.  Always a multiple of
+       sizeof *buffer.  */
+    size_t bufsize;
+
+    /* Number of valid bytes now in the buffer.  */
+    size_t buffered;
+
+    /* Array of pointers to lines in the file.  */
+    char const **linbuf;
+
+    /* linbuf_base <= buffered_lines <= valid_lines <= alloc_lines.
+       linebuf[linbuf_base ... buffered_lines - 1] are possibly differing.
+       linebuf[linbuf_base ... valid_lines - 1] contain valid data.
+       linebuf[linbuf_base ... alloc_lines - 1] are allocated.  */
+    lin linbuf_base, buffered_lines, valid_lines, alloc_lines;
+
+    /* Pointer to end of prefix of this file to ignore when hashing.  */
+    char const *prefix_end;
+
+    /* Count of lines in the prefix.
+       There are this many lines in the file before linbuf[0].  */
+    lin prefix_lines;
+
+    /* Pointer to start of suffix of this file to ignore when hashing.  */
+    char const *suffix_begin;
+
+    /* Vector, indexed by line number, containing an equivalence code for
+       each line.  It is this vector that is actually compared with that
+       of another file to generate differences.  */
+    lin *equivs;
+
+    /* Vector, like the previous one except that
+       the elements for discarded lines have been squeezed out.  */
+    lin *undiscarded;
+
+    /* Vector mapping virtual line numbers (not counting discarded lines)
+       to real ones (counting those lines).  Both are origin-0.  */
+    lin *realindexes;
+
+    /* Total number of nondiscarded lines.  */
+    lin nondiscarded_lines;
+
+    /* Vector, indexed by real origin-0 line number,
+       containing 1 for a line that is an insertion or a deletion.
+       The results of comparison are stored here.  */
+    char *changed;
+
+    /* 1 if file ends in a line with no final newline.  */
+    bool missing_newline;
+
+    /* 1 if at end of file.  */
+    bool eof;
+
+    /* 1 more than the maximum equivalence value used for this or its
+       sibling file.  */
+    lin equiv_max;
+};
+
+/* The file buffer, considered as an array of bytes rather than
+   as an array of words.  */
+#define FILE_BUFFER(f) ((char *) (f)->buffer)
+
+/* Data on two input files being compared.  */
+
+struct comparison
+  {
+    struct file_data file[2];
+    struct comparison const *parent;  /* parent, if a recursive comparison */
+  };
+
+/* Describe the two files currently being compared.  */
+
+XTERN struct file_data files[2];
+
+/* Stdio stream to output diffs to.  */
+
+XTERN FILE *outfile;
+
+/* Declare various functions.  */
+
+/* analyze.c */
+int diff_2_files (struct comparison *);
+
+/* context.c */
+void print_context_header (struct file_data[], bool);
+void print_context_script (struct change *, bool);
+
+/* dir.c */
+int diff_dirs (struct comparison const *, int (*) (struct comparison const *, char const *, char const *));
+
+/* ed.c */
+void print_ed_script (struct change *);
+void pr_forward_ed_script (struct change *);
+
+/* ifdef.c */
+void print_ifdef_script (struct change *);
+
+/* io.c */
+void file_block_read (struct file_data *, size_t);
+bool read_files (struct file_data[], bool);
+
+/* normal.c */
+void print_normal_script (struct change *);
+
+/* rcs.c */
+void print_rcs_script (struct change *);
+
+/* side.c */
+void print_sdiff_script (struct change *);
+
+/* util.c */
+extern char const change_letter[4];
+extern char const pr_program[];
+char *concat (char const *, char const *, char const *);
+char *dir_file_pathname (char const *, char const *);
+bool lines_differ (char const *, char const *);
+lin translate_line_number (struct file_data const *, lin);
+struct change *find_change (struct change *);
+struct change *find_reverse_change (struct change *);
+void *zalloc (size_t);
+enum changes analyze_hunk (struct change *, lin *, lin *, lin *, lin *);
+void begin_output (void);
+void debug_script (struct change *);
+void fatal (char const *) __attribute__((noreturn));
+void finish_output (void);
+void message (char const *, char const *, char const *);
+void message5 (char const *, char const *, char const *, char const *, char const *);
+void output_1_line (char const *, char const *, char const *, char const *);
+void perror_with_name (char const *);
+void pfatal_with_name (char const *) __attribute__((noreturn));
+void print_1_line (char const *, char const * const *);
+void print_message_queue (void);
+void print_number_range (char, struct file_data *, lin, lin);
+void print_script (struct change *, struct change * (*) (struct change *), void (*) (struct change *));
+void setup_output (char const *, char const *, bool);
+void translate_range (struct file_data const *, lin, lin, long int *, long int *);
diff --git a/diffutils-3.0-patch/src/diff3 b/diffutils-3.0-patch/src/diff3
new file mode 100755
index 0000000000000000000000000000000000000000..c893aa27ee91d1f13651187d5b7994755ee4c1a8
GIT binary patch
literal 238733
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

literal 0
HcmV?d00001

diff --git a/diffutils-3.0-patch/src/diff3.c b/diffutils-3.0-patch/src/diff3.c
new file mode 100644
index 0000000..885a194
--- /dev/null
+++ b/diffutils-3.0-patch/src/diff3.c
@@ -0,0 +1,1747 @@
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include `:wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  /* Fall through.  */
+	case 'E':
+	  flagging = true;
+	  /* Fall through.  */
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("'-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (strcmp (file[i], "-") != 0)
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+  diff3 = make_3way_diff (thread0, thread1);
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  check_stdout ();
+  exit (conflicts_found);
+  return conflicts_found;
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
+  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
+  N_("-A  --show-all  Output all changes, bracketing conflicts."),
+  N_("-x  --overlap-only  Output overlapping changes."),
+  N_("-X  Output overlapping changes, bracketing them."),
+  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+  "",
+  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+  N_("-i  Append 'w' and `q' commands to ed scripts."),
+  N_("-a  --text  Treat all files as text."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char *
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+
+  char const *argv[9];
+  char const **ap;
+  int fds[2];
+  pid_t pid;
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = vfork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  FILE *fpipe;
+  char const args[] = " --horizon-lines=100 -- ";
+  char *command = xmalloc (shell_quote_length (diff_program)
+			   + sizeof "-a"
+			   + sizeof "--strip-trailing-cr"
+			   + sizeof args - 1
+			   + shell_quote_length (filea) + 1
+			   + shell_quote_length (fileb) + 1);
+  char *p = command;
+  p = shell_quote_copy (p, diff_program);
+  if (text)
+    {
+      strcpy (p, " -a");
+      p += 3;
+    }
+  if (strip_trailing_cr)
+    {
+      strcpy (p, " --strip-trailing-cr");
+      p += 20;
+    }
+  strcpy (p, args);
+  p += sizeof args - 1;
+  p = shell_quote_copy (p, filea);
+  *p++ = ' ';
+  p = shell_quote_copy (p, fileb);
+  *p = 0;
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    error (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  long int llowt = lowt;
+	  long int lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%lda\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  (START is long int, not lin, for
+   convenience with printf %ld formats.)  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%lds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in `output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      long int low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%lda\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%ldd\n", low0);
+	  else
+	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%lda\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  error (EXIT_TROUBLE, errno, "%s", string);
+  abort ();
+}
diff --git a/diffutils-3.0-patch/src/dir.c b/diffutils-3.0-patch/src/dir.c
new file mode 100644
index 0000000..5e08318
--- /dev/null
+++ b/diffutils-3.0-patch/src/dir.c
@@ -0,0 +1,283 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+static int compare_names_for_qsort (void const *, void const *);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the `data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the `names' table from the `data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int r;
+      errno = 0;
+      if (ignore_file_name_case)
+	r = strcasecoll (name1, name2);
+      else
+	r = strcoll (name1, name2);
+      if (errno)
+	{
+	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+		 name1, name2);
+	  longjmp (failed_locale_specific_sorting, 1);
+	}
+      return r;
+    }
+
+  return (ignore_file_name_case
+	  ? strcasecmp (name1, name2)
+	  : file_name_cmp (name1, name2));
+}
+
+/* A wrapper for compare_names suitable as an argument for qsort.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  return compare_names (*f1, *f2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If `-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
diff --git a/diffutils-3.0-patch/src/ed.c b/diffutils-3.0-patch/src/ed.c
new file mode 100644
index 0000000..08acf50
--- /dev/null
+++ b/diffutils-3.0-patch/src/ed.c
@@ -0,0 +1,175 @@
+/* Output routines for ed-script format.
+
+   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_ed_hunk (struct change *);
+static void print_rcs_hunk (struct change *);
+static void pr_forward_ed_hunk (struct change *);
+
+/* Print our script as ed commands.  */
+
+void
+print_ed_script (struct change *script)
+{
+  print_script (script, find_reverse_change, print_ed_hunk);
+}
+
+/* Print a hunk of an ed diff */
+
+static void
+print_ed_hunk (struct change *hunk)
+{
+  lin f0, l0, f1, l1;
+  enum changes changes;
+
+#ifdef DEBUG
+  debug_script (hunk);
+#endif
+
+  /* Determine range of line numbers involved in each file.  */
+  changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], f0, l0);
+  fputc (change_letter[changes], outfile);
+  fputc ('\n', outfile);
+
+  /* Print new/changed lines from second file, if needed */
+  if (changes != OLD)
+    {
+      lin i;
+      bool insert_mode = true;
+
+      for (i = f1; i <= l1; i++)
+	{
+	  if (!insert_mode)
+	    {
+	      fputs ("a\n", outfile);
+	      insert_mode = true;
+	    }
+	  if (files[1].linbuf[i][0] == '.' && files[1].linbuf[i][1] == '\n')
+	    {
+	      /* The file's line is just a dot, and it would exit
+		 insert mode.  Precede the dot with another dot, exit
+		 insert mode and remove the extra dot.  */
+	      fputs ("..\n.\ns/.//\n", outfile);
+	      insert_mode = false;
+	    }
+	  else
+	    print_1_line ("", &files[1].linbuf[i]);
+	}
+
+      if (insert_mode)
+	fputs (".\n", outfile);
+    }
+}
+
+/* Print change script in the style of ed commands,
+   but print the changes in the order they appear in the input files,
+   which means that the commands are not truly useful with ed.
+   Because of the issue with lines containing just a dot, the output
+   is not even parseable.  */
+
+void
+pr_forward_ed_script (struct change *script)
+{
+  print_script (script, find_change, pr_forward_ed_hunk);
+}
+
+static void
+pr_forward_ed_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  fputc (change_letter[changes], outfile);
+  print_number_range (' ', files, f0, l0);
+  fputc ('\n', outfile);
+
+  /* If deletion only, print just the number range.  */
+
+  if (changes == OLD)
+    return;
+
+  /* For insertion (with or without deletion), print the number range
+     and the lines from file 2.  */
+
+  for (i = f1; i <= l1; i++)
+    print_1_line ("", &files[1].linbuf[i]);
+
+  fputs (".\n", outfile);
+}
+
+/* Print in a format somewhat like ed commands
+   except that each insert command states the number of lines it inserts.
+   This format is used for RCS.  */
+
+void
+print_rcs_script (struct change *script)
+{
+  print_script (script, find_change, print_rcs_hunk);
+}
+
+/* Print a hunk of an RCS diff */
+
+static void
+print_rcs_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+  long int tf0, tl0, tf1, tl1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  translate_range (&files[0], f0, l0, &tf0, &tl0);
+
+  if (changes & OLD)
+    {
+      /* For deletion, print just the starting line number from file 0
+	 and the number of lines deleted.  */
+      fprintf (outfile, "d%ld %ld\n", tf0, tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+    }
+
+  if (changes & NEW)
+    {
+      /* Take last-line-number from file 0 and # lines from file 1.  */
+      translate_range (&files[1], f1, l1, &tf1, &tl1);
+      fprintf (outfile, "a%ld %ld\n", tl0, tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+
+      /* Print the inserted lines.  */
+      for (i = f1; i <= l1; i++)
+	print_1_line ("", &files[1].linbuf[i]);
+    }
+}
diff --git a/diffutils-3.0-patch/src/ifdef.c b/diffutils-3.0-patch/src/ifdef.c
new file mode 100644
index 0000000..a48f830
--- /dev/null
+++ b/diffutils-3.0-patch/src/ifdef.c
@@ -0,0 +1,430 @@
+/* #ifdef-format output routines for GNU DIFF.
+
+   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <xalloc.h>
+
+struct group
+{
+  struct file_data const *file;
+  lin from, upto; /* start and limit lines for this group of lines */
+};
+
+static char const *format_group (FILE *, char const *, char,
+				 struct group const *);
+static char const *do_printf_spec (FILE *, char const *,
+				   struct file_data const *, lin,
+				   struct group const *);
+static char const *scan_char_literal (char const *, char *);
+static lin groups_letter_value (struct group const *, char);
+static void format_ifdef (char const *, lin, lin, lin, lin);
+static void print_ifdef_hunk (struct change *);
+static void print_ifdef_lines (FILE *, char const *, struct group const *);
+
+static lin next_line0;
+static lin next_line1;
+
+/* Print the edit-script SCRIPT as a merged #ifdef file.  */
+
+void
+print_ifdef_script (struct change *script)
+{
+  next_line0 = next_line1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_ifdef_hunk);
+  if (next_line0 < files[0].valid_lines
+      || next_line1 < files[1].valid_lines)
+    {
+      begin_output ();
+      format_ifdef (group_format[UNCHANGED],
+		    next_line0, files[0].valid_lines,
+		    next_line1, files[1].valid_lines);
+    }
+}
+
+/* Print a hunk of an ifdef diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_ifdef_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print lines up to this change.  */
+  if (next_line0 < first0 || next_line1 < first1)
+    format_ifdef (group_format[UNCHANGED],
+		  next_line0, first0,
+		  next_line1, first1);
+
+  /* Print this change.  */
+  next_line0 = last0 + 1;
+  next_line1 = last1 + 1;
+  format_ifdef (group_format[changes],
+		first0, next_line0,
+		first1, next_line1);
+}
+
+/* Print a set of lines according to FORMAT.
+   Lines BEG0 up to END0 are from the first file;
+   lines BEG1 up to END1 are from the second file.  */
+
+static void
+format_ifdef (char const *format, lin beg0, lin end0, lin beg1, lin end1)
+{
+  struct group groups[2];
+
+  groups[0].file = &files[0];
+  groups[0].from = beg0;
+  groups[0].upto = end0;
+  groups[1].file = &files[1];
+  groups[1].from = beg1;
+  groups[1].upto = end1;
+  format_group (outfile, format, 0, groups);
+}
+
+/* Print to file OUT a set of lines according to FORMAT.
+   The format ends at the first free instance of ENDCHAR.
+   Yield the address of the terminating character.
+   GROUPS specifies which lines to print.
+   If OUT is zero, do not actually print anything; just scan the format.  */
+
+static char const *
+format_group (register FILE *out, char const *format, char endchar,
+	      struct group const *groups)
+{
+  register char c;
+  register char const *f = format;
+
+  while ((c = *f) != endchar && c != 0)
+    {
+      char const *f1 = ++f;
+      if (c == '%')
+	switch ((c = *f++))
+	  {
+	  case '%':
+	    break;
+
+	  case '(':
+	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
+	    {
+	      int i;
+	      uintmax_t value[2];
+	      FILE *thenout, *elseout;
+
+	      for (i = 0; i < 2; i++)
+		{
+		  if (ISDIGIT (*f))
+		    {
+		      char *fend;
+		      errno = 0;
+		      value[i] = strtoumax (f, &fend, 10);
+		      if (errno)
+			goto bad_format;
+		      f = fend;
+		    }
+		  else
+		    {
+		      value[i] = groups_letter_value (groups, *f);
+		      if (value[i] == -1)
+			goto bad_format;
+		      f++;
+		    }
+		  if (*f++ != "=?"[i])
+		    goto bad_format;
+		}
+	      if (value[0] == value[1])
+		thenout = out, elseout = 0;
+	      else
+		thenout = 0, elseout = out;
+	      f = format_group (thenout, f, ':', groups);
+	      if (*f)
+		{
+		  f = format_group (elseout, f + 1, ')', groups);
+		  if (*f)
+		    f++;
+		}
+	    }
+	    continue;
+
+	  case '<':
+	    /* Print lines deleted from first file.  */
+	    print_ifdef_lines (out, line_format[OLD], &groups[0]);
+	    continue;
+
+	  case '=':
+	    /* Print common lines.  */
+	    print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
+	    continue;
+
+	  case '>':
+	    /* Print lines inserted from second file.  */
+	    print_ifdef_lines (out, line_format[NEW], &groups[1]);
+	    continue;
+
+	  default:
+	    f = do_printf_spec (out, f - 2, 0, 0, groups);
+	    if (f)
+	      continue;
+	    /* Fall through. */
+	  bad_format:
+	    c = '%';
+	    f = f1;
+	    break;
+	  }
+
+      if (out)
+	putc (c, out);
+    }
+
+  return f;
+}
+
+/* For the line group pair G, return the number corresponding to LETTER.
+   Return -1 if LETTER is not a group format letter.  */
+static lin
+groups_letter_value (struct group const *g, char letter)
+{
+  switch (letter)
+    {
+    case 'E': letter = 'e'; g++; break;
+    case 'F': letter = 'f'; g++; break;
+    case 'L': letter = 'l'; g++; break;
+    case 'M': letter = 'm'; g++; break;
+    case 'N': letter = 'n'; g++; break;
+    }
+
+  switch (letter)
+    {
+      case 'e': return translate_line_number (g->file, g->from) - 1;
+      case 'f': return translate_line_number (g->file, g->from);
+      case 'l': return translate_line_number (g->file, g->upto) - 1;
+      case 'm': return translate_line_number (g->file, g->upto);
+      case 'n': return g->upto - g->from;
+      default: return -1;
+    }
+}
+
+/* Print to file OUT, using FORMAT to print the line group GROUP.
+   But do nothing if OUT is zero.  */
+static void
+print_ifdef_lines (register FILE *out, char const *format,
+		   struct group const *group)
+{
+  struct file_data const *file = group->file;
+  char const * const *linbuf = file->linbuf;
+  lin from = group->from, upto = group->upto;
+
+  if (!out)
+    return;
+
+  /* If possible, use a single fwrite; it's faster.  */
+  if (!expand_tabs && format[0] == '%')
+    {
+      if (format[1] == 'l' && format[2] == '\n' && !format[3] && from < upto)
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
+		  out);
+	  return;
+	}
+      if (format[1] == 'L' && !format[2])
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] -  linbuf[from], out);
+	  return;
+	}
+    }
+
+  for (;  from < upto;  from++)
+    {
+      register char c;
+      register char const *f = format;
+
+      while ((c = *f++) != 0)
+	{
+	  char const *f1 = f;
+	  if (c == '%')
+	    switch ((c = *f++))
+	      {
+	      case '%':
+		break;
+
+	      case 'l':
+		output_1_line (linbuf[from],
+			       (linbuf[from + 1]
+				- (linbuf[from + 1][-1] == '\n')),
+			       0, 0);
+		continue;
+
+	      case 'L':
+		output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
+		continue;
+
+	      default:
+		f = do_printf_spec (out, f - 2, file, from, 0);
+		if (f)
+		  continue;
+		c = '%';
+		f = f1;
+		break;
+	      }
+
+	  putc (c, out);
+	}
+    }
+}
+
+static char const *
+do_printf_spec (FILE *out, char const *spec,
+		struct file_data const *file, lin n,
+		struct group const *groups)
+{
+  char const *f = spec;
+  char c;
+  char c1;
+
+  /* Scan printf-style SPEC of the form %[-'0]*[0-9]*(.[0-9]*)?[cdoxX].  */
+  /* assert (*f == '%'); */
+  f++;
+  while ((c = *f++) == '-' || c == '\'' || c == '0')
+    continue;
+  while (ISDIGIT (c))
+    c = *f++;
+  if (c == '.')
+    while (ISDIGIT (c = *f++))
+      continue;
+  c1 = *f++;
+
+  switch (c)
+    {
+    case 'c':
+      if (c1 != '\'')
+	return 0;
+      else
+	{
+	  char value IF_LINT (= 0);
+	  f = scan_char_literal (f, &value);
+	  if (!f)
+	    return 0;
+	  if (out)
+	    putc (value, out);
+	}
+      break;
+
+    case 'd': case 'o': case 'x': case 'X':
+      {
+	lin value;
+
+	if (file)
+	  {
+	    if (c1 != 'n')
+	      return 0;
+	    value = translate_line_number (file, n);
+	  }
+	else
+	  {
+	    value = groups_letter_value (groups, c1);
+	    if (value < 0)
+	      return 0;
+	  }
+
+	if (out)
+	  {
+	    /* For example, if the spec is "%3xn", use the printf
+	       format spec "%3lx".  Here the spec prefix is "%3".  */
+	    long int long_value = value;
+	    size_t spec_prefix_len = f - spec - 2;
+#if HAVE_C_VARARRAYS
+	    char format[spec_prefix_len + 3];
+#else
+	    char *format = xmalloc (spec_prefix_len + 3);
+#endif
+	    char *p = format + spec_prefix_len;
+	    memcpy (format, spec, spec_prefix_len);
+	    *p++ = 'l';
+	    *p++ = c;
+	    *p = '\0';
+	    fprintf (out, format, long_value);
+#if ! HAVE_C_VARARRAYS
+	    free (format);
+#endif
+	  }
+      }
+      break;
+
+    default:
+      return 0;
+    }
+
+  return f;
+}
+
+/* Scan the character literal represented in the string LIT; LIT points just
+   after the initial apostrophe.  Put the literal's value into *VALPTR.
+   Yield the address of the first character after the closing apostrophe,
+   or a null pointer if the literal is ill-formed.  */
+static char const *
+scan_char_literal (char const *lit, char *valptr)
+{
+  register char const *p = lit;
+  char value;
+  ptrdiff_t digits;
+  char c = *p++;
+
+  switch (c)
+    {
+      case 0:
+      case '\'':
+	return NULL;
+
+      case '\\':
+	value = 0;
+	while ((c = *p++) != '\'')
+	  {
+	    unsigned int digit = c - '0';
+	    if (8 <= digit)
+	      return NULL;
+	    value = 8 * value + digit;
+	  }
+	digits = p - lit - 2;
+	if (! (1 <= digits && digits <= 3))
+	  return NULL;
+	break;
+
+      default:
+	value = c;
+	if (*p++ != '\'')
+	  return NULL;
+	break;
+    }
+
+  *valptr = value;
+  return p;
+}
diff --git a/diffutils-3.0-patch/src/io.c b/diffutils-3.0-patch/src/io.c
new file mode 100644
index 0000000..031be3d
--- /dev/null
+++ b/diffutils-3.0-patch/src/io.c
@@ -0,0 +1,845 @@
+/* File I/O for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* Rotate an unsigned value to the left.  */
+#define ROL(v, n) ((v) << (n) | (v) >> (sizeof (v) * CHAR_BIT - (n)))
+
+/* Given a hash value and a new character, return a new hash value.  */
+#define HASH(h, c) ((c) + ROL (h, 7))
+
+/* The type of a hash value.  */
+typedef size_t hash_value;
+verify (! TYPE_SIGNED (hash_value));
+
+/* Lines are put into equivalence classes of lines that match in lines_differ.
+   Each equivalence class is represented by one of these structures,
+   but only while the classes are being computed.
+   Afterward, each class is represented by a number.  */
+struct equivclass
+{
+  lin next;		/* Next item in this bucket.  */
+  hash_value hash;	/* Hash of lines in this class.  */
+  char const *line;	/* A line that fits this class.  */
+  size_t length;	/* That line's length, not counting its newline.  */
+};
+
+/* Hash-table: array of buckets, each being a chain of equivalence classes.
+   buckets[-1] is reserved for incomplete lines.  */
+static lin *buckets;
+
+/* Number of buckets in the hash table array, not counting buckets[-1].  */
+static size_t nbuckets;
+
+/* Array in which the equivalence classes are allocated.
+   The bucket-chains go through the elements in this array.
+   The number of an equivalence class is its index in this array.  */
+static struct equivclass *equivs;
+
+/* Index of first free element in the array `equivs'.  */
+static lin equivs_index;
+
+/* Number of elements allocated in the array `equivs'.  */
+static lin equivs_alloc;
+
+/* Read a block of data into a file buffer, checking for EOF and error.  */
+
+void
+file_block_read (struct file_data *current, size_t size)
+{
+  if (size && ! current->eof)
+    {
+      size_t s = block_read (current->desc,
+			     FILE_BUFFER (current) + current->buffered, size);
+      if (s == SIZE_MAX)
+	pfatal_with_name (current->name);
+      current->buffered += s;
+      current->eof = s < size;
+    }
+}
+
+/* Check for binary files and compare them for exact identity.  */
+
+/* Return 1 if BUF contains a non text character.
+   SIZE is the number of characters in BUF.  */
+
+#define binary_file_p(buf, size) (memchr (buf, 0, size) != 0)
+
+/* Get ready to read the current file.
+   Return nonzero if SKIP_TEST is zero,
+   and if it appears to be a binary file.  */
+
+static bool
+sip (struct file_data *current, bool skip_test)
+{
+  /* If we have a nonexistent file at this stage, treat it as empty.  */
+  if (current->desc < 0)
+    {
+      /* Leave room for a sentinel.  */
+      current->bufsize = sizeof (word);
+      current->buffer = xmalloc (current->bufsize);
+    }
+  else
+    {
+      current->bufsize = buffer_lcm (sizeof (word),
+				     STAT_BLOCKSIZE (current->stat),
+				     PTRDIFF_MAX - 2 * sizeof (word));
+      current->buffer = xmalloc (current->bufsize);
+
+      if (! skip_test)
+	{
+	  /* Check first part of file to see if it's a binary file.  */
+
+	  /* FIXME: if O_BINARY, this should revert to text mode
+	     if the file is not binary.  */
+
+	  file_block_read (current, current->bufsize);
+	  return binary_file_p (current->buffer, current->buffered);
+	}
+    }
+
+  current->buffered = 0;
+  current->eof = false;
+  return false;
+}
+
+/* Slurp the rest of the current file completely into memory.  */
+
+static void
+slurp (struct file_data *current)
+{
+  size_t cc;
+
+  if (current->desc < 0)
+    {
+      /* The file is nonexistent.  */
+      return;
+    }
+
+  if (S_ISREG (current->stat.st_mode))
+    {
+      /* It's a regular file; slurp in the rest all at once.  */
+
+      /* Get the size out of the stat block.
+	 Allocate just enough room for appended newline plus word sentinel,
+	 plus word-alignment since we want the buffer word-aligned.  */
+      size_t file_size = current->stat.st_size;
+      cc = file_size + 2 * sizeof (word) - file_size % sizeof (word);
+      if (file_size != current->stat.st_size || cc < file_size
+	  || PTRDIFF_MAX <= cc)
+	xalloc_die ();
+
+      if (current->bufsize < cc)
+	{
+	  current->bufsize = cc;
+	  current->buffer = xrealloc (current->buffer, cc);
+	}
+
+      /* Try to read at least 1 more byte than the size indicates, to
+	 detect whether the file is growing.  This is a nicety for
+	 users who run 'diff' on files while they are changing.  */
+
+      if (current->buffered <= file_size)
+	{
+	  file_block_read (current, file_size + 1 - current->buffered);
+	  if (current->buffered <= file_size)
+	    return;
+	}
+    }
+
+  /* It's not a regular file, or it's a growing regular file; read it,
+     growing the buffer as needed.  */
+
+  file_block_read (current, current->bufsize - current->buffered);
+
+  if (current->buffered)
+    {
+      while (current->buffered == current->bufsize)
+	{
+	  if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
+	    xalloc_die ();
+	  current->bufsize *= 2;
+	  current->buffer = xrealloc (current->buffer, current->bufsize);
+	  file_block_read (current, current->bufsize - current->buffered);
+	}
+
+      /* Allocate just enough room for appended newline plus word
+	 sentinel, plus word-alignment.  */
+      cc = current->buffered + 2 * sizeof (word);
+      current->bufsize = cc - cc % sizeof (word);
+      current->buffer = xrealloc (current->buffer, current->bufsize);
+    }
+}
+
+/* Split the file into lines, simultaneously computing the equivalence
+   class for each line.  */
+
+static void
+find_and_hash_each_line (struct file_data *current)
+{
+  hash_value h;
+  char const *p = current->prefix_end;
+  unsigned char c;
+  lin i, *bucket;
+  size_t length;
+
+  /* Cache often-used quantities in local variables to help the compiler.  */
+  char const **linbuf = current->linbuf;
+  lin alloc_lines = current->alloc_lines;
+  lin line = 0;
+  lin linbuf_base = current->linbuf_base;
+  lin *cureqs = xmalloc (alloc_lines * sizeof *cureqs);
+  struct equivclass *eqs = equivs;
+  lin eqs_index = equivs_index;
+  lin eqs_alloc = equivs_alloc;
+  char const *suffix_begin = current->suffix_begin;
+  char const *bufend = FILE_BUFFER (current) + current->buffered;
+  bool diff_length_compare_anyway =
+    ignore_white_space != IGNORE_NO_WHITE_SPACE;
+  bool same_length_diff_contents_compare_anyway =
+    diff_length_compare_anyway | ignore_case;
+
+  while (p < suffix_begin)
+    {
+      char const *ip = p;
+
+      h = 0;
+
+      /* Hash this line until we find a newline.  */
+      if (ignore_case)
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, tolower (c));
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, tolower (c));
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      c = tolower (c);
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, tolower (c));
+	    break;
+	  }
+      else
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, c);
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, c);
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, c);
+	    break;
+	  }
+
+   hashing_done:;
+
+      bucket = &buckets[h % nbuckets];
+      length = p - ip - 1;
+
+      if (p == bufend
+	  && current->missing_newline
+	  && ROBUST_OUTPUT_STYLE (output_style))
+	{
+	  /* The last line is incomplete and we do not silently
+	     complete lines.  If the line cannot compare equal to any
+	     complete line, put it into buckets[-1] so that it can
+	     compare equal only to the other file's incomplete line
+	     (if one exists).  */
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    bucket = &buckets[-1];
+	}
+
+      for (i = *bucket;  ;  i = eqs[i].next)
+	if (!i)
+	  {
+	    /* Create a new equivalence class in this bucket.  */
+	    i = eqs_index++;
+	    if (i == eqs_alloc)
+	      {
+		if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
+		  xalloc_die ();
+		eqs_alloc *= 2;
+		eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
+	      }
+	    eqs[i].next = *bucket;
+	    eqs[i].hash = h;
+	    eqs[i].line = ip;
+	    eqs[i].length = length;
+	    *bucket = i;
+	    break;
+	  }
+	else if (eqs[i].hash == h)
+	  {
+	    char const *eqline = eqs[i].line;
+
+	    /* Reuse existing class if lines_differ reports the lines
+               equal.  */
+	    if (eqs[i].length == length)
+	      {
+		/* Reuse existing equivalence class if the lines are identical.
+		   This detects the common case of exact identity
+		   faster than lines_differ would.  */
+		if (memcmp (eqline, ip, length) == 0)
+		  break;
+		if (!same_length_diff_contents_compare_anyway)
+		  continue;
+	      }
+	    else if (!diff_length_compare_anyway)
+	      continue;
+
+	    if (! lines_differ (eqline, ip))
+	      break;
+	  }
+
+      /* Maybe increase the size of the line table.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = ip;
+      cureqs[line] = i;
+      ++line;
+    }
+
+  current->buffered_lines = line;
+
+  for (i = 0;  ;  i++)
+    {
+      /* Record the line start for lines in the suffix that we care about.
+	 Record one more line start than lines,
+	 so that we can compute the length of any buffered line.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = p;
+
+      if (p == bufend)
+	{
+	  /* If the last line is incomplete and we do not silently
+	     complete lines, don't count its appended newline.  */
+	  if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
+	    linbuf[line]--;
+	  break;
+	}
+
+      if (context <= i && no_diff_means_no_output)
+	break;
+
+      line++;
+
+      while (*p++ != '\n')
+	continue;
+    }
+
+  /* Done with cache in local variables.  */
+  current->linbuf = linbuf;
+  current->valid_lines = line;
+  current->alloc_lines = alloc_lines;
+  current->equivs = cureqs;
+  equivs = eqs;
+  equivs_alloc = eqs_alloc;
+  equivs_index = eqs_index;
+}
+
+/* Prepare the text.  Make sure the text end is initialized.
+   Make sure text ends in a newline,
+   but remember that we had to add one.
+   Strip trailing CRs, if that was requested.  */
+
+static void
+prepare_text (struct file_data *current)
+{
+  size_t buffered = current->buffered;
+  char *p = FILE_BUFFER (current);
+  char *dst;
+
+  if (buffered == 0 || p[buffered - 1] == '\n')
+    current->missing_newline = false;
+  else
+    {
+      p[buffered++] = '\n';
+      current->missing_newline = true;
+    }
+
+  if (!p)
+    return;
+
+  /* Don't use uninitialized storage when planting or using sentinels.  */
+  memset (p + buffered, 0, sizeof (word));
+
+  if (strip_trailing_cr && (dst = memchr (p, '\r', buffered)))
+    {
+      char const *src = dst;
+      char const *srclim = p + buffered;
+
+      do
+	dst += ! ((*dst = *src++) == '\r' && *src == '\n');
+      while (src < srclim);
+
+      buffered -= src - dst;
+    }
+
+  current->buffered = buffered;
+}
+
+/* We have found N lines in a buffer of size S; guess the
+   proportionate number of lines that will be found in a buffer of
+   size T.  However, do not guess a number of lines so large that the
+   resulting line table might cause overflow in size calculations.  */
+static lin
+guess_lines (lin n, size_t s, size_t t)
+{
+  size_t guessed_bytes_per_line = n < 10 ? 32 : s / (n - 1);
+  lin guessed_lines = MAX (1, t / guessed_bytes_per_line);
+  return MIN (guessed_lines, PTRDIFF_MAX / (2 * sizeof (char *) + 1) - 5) + 5;
+}
+
+/* Given a vector of two file_data objects, find the identical
+   prefixes and suffixes of each object.  */
+
+static void
+find_identical_ends (struct file_data filevec[])
+{
+  word *w0, *w1;
+  char *p0, *p1, *buffer0, *buffer1;
+  char const *end0, *beg0;
+  char const **linbuf0, **linbuf1;
+  lin i, lines;
+  size_t n0, n1;
+  lin alloc_lines0, alloc_lines1;
+  lin buffered_prefix, prefix_count, prefix_mask;
+  lin middle_guess, suffix_guess;
+
+  slurp (&filevec[0]);
+  prepare_text (&filevec[0]);
+  if (filevec[0].desc != filevec[1].desc)
+    {
+      slurp (&filevec[1]);
+      prepare_text (&filevec[1]);
+    }
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+      filevec[1].missing_newline = filevec[0].missing_newline;
+    }
+
+  /* Find identical prefix.  */
+
+  w0 = filevec[0].buffer;
+  w1 = filevec[1].buffer;
+  p0 = buffer0 = (char *) w0;
+  p1 = buffer1 = (char *) w1;
+  n0 = filevec[0].buffered;
+  n1 = filevec[1].buffered;
+
+  if (p0 == p1)
+    /* The buffers are the same; sentinels won't work.  */
+    p0 = p1 += n1;
+  else
+    {
+      /* Insert end sentinels, in this case characters that are guaranteed
+	 to make the equality test false, and thus terminate the loop.  */
+
+      if (n0 < n1)
+	p0[n0] = ~p1[n0];
+      else
+	p1[n1] = ~p0[n1];
+
+      /* Loop until first mismatch, or to the sentinel characters.  */
+
+      /* Compare a word at a time for speed.  */
+      while (*w0 == *w1)
+	w0++, w1++;
+
+      /* Do the last few bytes of comparison a byte at a time.  */
+      p0 = (char *) w0;
+      p1 = (char *) w1;
+      while (*p0 == *p1)
+	p0++, p1++;
+
+      /* Don't mistakenly count missing newline as part of prefix.  */
+      if (ROBUST_OUTPUT_STYLE (output_style)
+	  && ((buffer0 + n0 - filevec[0].missing_newline < p0)
+	      !=
+	      (buffer1 + n1 - filevec[1].missing_newline < p1)))
+	p0--, p1--;
+    }
+
+  /* Now P0 and P1 point at the first nonmatching characters.  */
+
+  /* Skip back to last line-beginning in the prefix,
+     and then discard up to HORIZON_LINES lines from the prefix.  */
+  i = horizon_lines;
+  while (p0 != buffer0 && (p0[-1] != '\n' || i--))
+    p0--, p1--;
+
+  /* Record the prefix.  */
+  filevec[0].prefix_end = p0;
+  filevec[1].prefix_end = p1;
+
+  /* Find identical suffix.  */
+
+  /* P0 and P1 point beyond the last chars not yet compared.  */
+  p0 = buffer0 + n0;
+  p1 = buffer1 + n1;
+
+  if (! ROBUST_OUTPUT_STYLE (output_style)
+      || filevec[0].missing_newline == filevec[1].missing_newline)
+    {
+      end0 = p0;	/* Addr of last char in file 0.  */
+
+      /* Get value of P0 at which we should stop scanning backward:
+	 this is when either P0 or P1 points just past the last char
+	 of the identical prefix.  */
+      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);
+
+      /* Scan back until chars don't match or we reach that point.  */
+      while (p0 != beg0)
+	if (*--p0 != *--p1)
+	  {
+	    /* Point at the first char of the matching suffix.  */
+	    ++p0, ++p1;
+	    beg0 = p0;
+	    break;
+	  }
+
+      /* Are we at a line-beginning in both files?  If not, add the rest of
+	 this line to the main body.  Discard up to HORIZON_LINES lines from
+	 the identical suffix.  Also, discard one extra line,
+	 because shift_boundaries may need it.  */
+      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n')
+			    &&
+			    (buffer1 == p1 || p1[-1] == '\n'));
+      while (i-- && p0 != end0)
+	while (*p0++ != '\n')
+	  continue;
+
+      p1 += p0 - beg0;
+    }
+
+  /* Record the suffix.  */
+  filevec[0].suffix_begin = p0;
+  filevec[1].suffix_begin = p1;
+
+  /* Calculate number of lines of prefix to save.
+
+     prefix_count == 0 means save the whole prefix;
+     we need this for options like -D that output the whole file,
+     or for enormous contexts (to avoid worrying about arithmetic overflow).
+     We also need it for options like -F that output some preceding line;
+     at least we will need to find the last few lines,
+     but since we don't know how many, it's easiest to find them all.
+
+     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
+     of the line buffer; they'll be moved to the proper location later.
+     Handle 1 more line than the context says (because we count 1 too many),
+     rounded up to the next power of 2 to speed index computation.  */
+
+  if (no_diff_means_no_output && ! function_regexp.fastmap
+      && context < LIN_MAX / 4 && context < n0)
+    {
+      middle_guess = guess_lines (0, 0, p0 - filevec[0].prefix_end);
+      suffix_guess = guess_lines (0, 0, buffer0 + n0 - p0);
+      for (prefix_count = 1;  prefix_count <= context;  prefix_count *= 2)
+	continue;
+      alloc_lines0 = (prefix_count + middle_guess
+		      + MIN (context, suffix_guess));
+    }
+  else
+    {
+      prefix_count = 0;
+      alloc_lines0 = guess_lines (0, 0, n0);
+    }
+
+  prefix_mask = prefix_count - 1;
+  lines = 0;
+  linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
+  p0 = buffer0;
+
+  /* If the prefix is needed, find the prefix lines.  */
+  if (! (no_diff_means_no_output
+	 && filevec[0].prefix_end == p0
+	 && filevec[1].prefix_end == p1))
+    {
+      end0 = filevec[0].prefix_end;
+      while (p0 != end0)
+	{
+	  lin l = lines++ & prefix_mask;
+	  if (l == alloc_lines0)
+	    {
+	      if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
+		xalloc_die ();
+	      alloc_lines0 *= 2;
+	      linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
+	    }
+	  linbuf0[l] = p0;
+	  while (*p0++ != '\n')
+	    continue;
+	}
+    }
+  buffered_prefix = prefix_count && context < lines ? context : lines;
+
+  /* Allocate line buffer 1.  */
+
+  middle_guess = guess_lines (lines, p0 - buffer0, p1 - filevec[1].prefix_end);
+  suffix_guess = guess_lines (lines, p0 - buffer0, buffer1 + n1 - p1);
+  alloc_lines1 = buffered_prefix + middle_guess + MIN (context, suffix_guess);
+  if (alloc_lines1 < buffered_prefix
+      || PTRDIFF_MAX / sizeof *linbuf1 <= alloc_lines1)
+    xalloc_die ();
+  linbuf1 = xmalloc (alloc_lines1 * sizeof *linbuf1);
+
+  if (buffered_prefix != lines)
+    {
+      /* Rotate prefix lines to proper location.  */
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf0[i] = linbuf1[i];
+    }
+
+  /* Initialize line buffer 1 from line buffer 0.  */
+  for (i = 0; i < buffered_prefix; i++)
+    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;
+
+  /* Record the line buffer, adjusted so that
+     linbuf[0] points at the first differing line.  */
+  filevec[0].linbuf = linbuf0 + buffered_prefix;
+  filevec[1].linbuf = linbuf1 + buffered_prefix;
+  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
+  filevec[0].alloc_lines = alloc_lines0 - buffered_prefix;
+  filevec[1].alloc_lines = alloc_lines1 - buffered_prefix;
+  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
+}
+
+/* If 1 < k, then (2**k - prime_offset[k]) is the largest prime less
+   than 2**k.  This table is derived from Chris K. Caldwell's list
+   <http://www.utm.edu/research/primes/lists/2small/>.  */
+
+static unsigned char const prime_offset[] =
+{
+  0, 0, 1, 1, 3, 1, 3, 1, 5, 3, 3, 9, 3, 1, 3, 19, 15, 1, 5, 1, 3, 9, 3,
+  15, 3, 39, 5, 39, 57, 3, 35, 1, 5, 9, 41, 31, 5, 25, 45, 7, 87, 21,
+  11, 57, 17, 55, 21, 115, 59, 81, 27, 129, 47, 111, 33, 55, 5, 13, 27,
+  55, 93, 1, 57, 25
+};
+
+/* Verify that this host's size_t is not too wide for the above table.  */
+
+verify (sizeof (size_t) * CHAR_BIT <= sizeof prime_offset);
+
+/* Given a vector of two file_data objects, read the file associated
+   with each one, and build the table of equivalence classes.
+   Return nonzero if either file appears to be a binary file.
+   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
+
+bool
+read_files (struct file_data filevec[], bool pretend_binary)
+{
+  int i;
+  bool skip_test = text | pretend_binary;
+  bool appears_binary = pretend_binary | sip (&filevec[0], skip_test);
+
+  if (filevec[0].desc != filevec[1].desc)
+    appears_binary |= sip (&filevec[1], skip_test | appears_binary);
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+    }
+  if (appears_binary)
+    {
+      /* FIXME: If O_BINARY, this should set both files to binary mode.  */
+      return true;
+    }
+
+  find_identical_ends (filevec);
+
+  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
+  if (PTRDIFF_MAX / sizeof *equivs <= equivs_alloc)
+    xalloc_die ();
+  equivs = xmalloc (equivs_alloc * sizeof *equivs);
+  /* Equivalence class 0 is permanently safe for lines that were not
+     hashed.  Real equivalence classes start at 1.  */
+  equivs_index = 1;
+
+  /* Allocate (one plus) a prime number of hash buckets.  Use a prime
+     number between 1/3 and 2/3 of the value of equiv_allocs,
+     approximately.  */
+  for (i = 9; (size_t) 1 << i < equivs_alloc / 3; i++)
+    continue;
+  nbuckets = ((size_t) 1 << i) - prime_offset[i];
+  if (PTRDIFF_MAX / sizeof *buckets <= nbuckets)
+    xalloc_die ();
+  buckets = zalloc ((nbuckets + 1) * sizeof *buckets);
+  buckets++;
+
+  for (i = 0; i < 2; i++)
+    find_and_hash_each_line (&filevec[i]);
+
+  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;
+
+  free (equivs);
+  free (buckets - 1);
+
+  return false;
+}
diff --git a/diffutils-3.0-patch/src/normal.c b/diffutils-3.0-patch/src/normal.c
new file mode 100644
index 0000000..154efaa
--- /dev/null
+++ b/diffutils-3.0-patch/src/normal.c
@@ -0,0 +1,69 @@
+/* Normal-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_normal_hunk (struct change *);
+
+/* Print the edit-script SCRIPT as a normal diff.
+   INF points to an array of descriptions of the two files.  */
+
+void
+print_normal_script (struct change *script)
+{
+  print_script (script, find_change, print_normal_hunk);
+}
+
+/* Print a hunk of a normal diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_normal_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], first0, last0);
+  fputc (change_letter[changes], outfile);
+  print_number_range (',', &files[1], first1, last1);
+  fputc ('\n', outfile);
+
+  /* Print the lines that the first file has.  */
+  if (changes & OLD)
+    for (i = first0; i <= last0; i++)
+      print_1_line ("<", &files[0].linbuf[i]);
+
+  if (changes == CHANGED)
+    fputs ("---\n", outfile);
+
+  /* Print the lines that the second file has.  */
+  if (changes & NEW)
+    for (i = first1; i <= last1; i++)
+      print_1_line (">", &files[1].linbuf[i]);
+}
diff --git a/diffutils-3.0-patch/src/paths.h b/diffutils-3.0-patch/src/paths.h
new file mode 100644
index 0000000..86dc41c
--- /dev/null
+++ b/diffutils-3.0-patch/src/paths.h
@@ -0,0 +1,2 @@
+#define DEFAULT_DIFF_PROGRAM "diff"
+#define LOCALEDIR "/usr/local/share/locale"
diff --git a/diffutils-3.0-patch/src/sdiff b/diffutils-3.0-patch/src/sdiff
new file mode 100755
index 0000000000000000000000000000000000000000..da1a649036d4c31ebc13b02b672550607e89f1cf
GIT binary patch
literal 182588
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

literal 0
HcmV?d00001

diff --git a/diffutils-3.0-patch/src/sdiff.c b/diffutils-3.0-patch/src/sdiff.c
new file mode 100644
index 0000000..6ea6f0a
--- /dev/null
+++ b/diffutils-3.0-patch/src/sdiff.c
@@ -0,0 +1,1236 @@
+/* sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+#endif
+       SIGINT
+#define handler_index_of_SIGINT (NUM_SIGS - 1)
+};
+
+#if HAVE_SIGACTION
+  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+#if ! HAVE_SIGPROCMASK
+# define sigset_t int
+# define sigemptyset(s) (*(s) = 0)
+# ifndef sigmask
+#  define sigmask(sig) (1 << ((sig) - 1))
+# endif
+# define sigaddset(s, sig) (*(s) |= sigmask (sig))
+# ifndef SIG_BLOCK
+#  define SIG_BLOCK 0
+# endif
+# ifndef SIG_SETMASK
+#  define SIG_SETMASK (! SIG_BLOCK)
+# endif
+# if ! HAVE_SIGBLOCK
+#  define sigblock(mask) (mask)
+#  define sigsetmask(mask) (mask)
+# endif
+# define sigprocmask(how, n, o) \
+    ((how) == SIG_BLOCK \
+     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
+     : sigsetmask (*(n)))
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+  "",
+  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-W  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
+  N_("-l  --left-column  Output only the left column of common lines."),
+  N_("-s  --suppress-common-lines  Do not output common lines."),
+  "",
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  "",
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      {
+	size_t cmdsize = 1;
+	char *p, *command;
+	int i;
+
+	for (i = 0;  diffargv[i];  i++)
+	  cmdsize += shell_quote_length (diffargv[i]) + 1;
+	command = p = xmalloc (cmdsize);
+	for (i = 0;  diffargv[i];  i++)
+	  {
+	    p = shell_quote_copy (p, diffargv[i]);
+	    *p++ = ' ';
+	  }
+	p[-1] = 0;
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+# if HAVE_WORKING_VFORK
+	sigset_t procmask;
+	sigset_t blocked;
+# endif
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+# if HAVE_WORKING_VFORK
+	/* Block SIGINT and SIGPIPE.  */
+	sigemptyset (&blocked);
+	sigaddset (&blocked, SIGINT);
+	sigaddset (&blocked, SIGPIPE);
+	sigprocmask (SIG_BLOCK, &blocked, &procmask);
+# endif
+	diffpid = vfork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+# if HAVE_WORKING_VFORK
+	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
+	    sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+# if HAVE_WORKING_VFORK
+	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
+	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	  signal_handler (SIGINT, catchsig);
+	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
+	  signal_handler (SIGPIPE, catchsig);
+	else
+	  signal_handler (SIGPIPE, SIG_IGN);
+
+	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
+	sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      kill (getpid (), s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	      flush_line ();
+	      /* Fall through.  */
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+		    else
+		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
+			       (long int) lline,
+			       (long int) (lline + llen - 1));
+		  }
+		/* Fall through.  */
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+		    else
+		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
+			       (long int) rline,
+			       (long int) (rline + rlen - 1));
+		  }
+		/* Fall through.  */
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      ignore_SIGINT = true;
+	      checksigs ();
+
+	      {
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+		char *command =
+		  xmalloc (shell_quote_length (editor_program)
+			   + 1 + strlen (tmpname) + 1);
+		sprintf (shell_quote_copy (command, editor_program),
+			 " %s", tmpname);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = vfork ();
+		if (pid == 0)
+		  {
+		    char const *argv[3];
+		    int i = 0;
+
+		    argv[i++] = editor_program;
+		    argv[i++] = tmpname;
+		    argv[i] = 0;
+
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  llen = val = strtoumax (diff_help + 1, &numend, 10);
+	  if (llen < 0 || llen != val || errno || *numend != ',')
+	    fatal (diff_help);
+	  rlen = val = strtoumax (numend + 1, &numend, 10);
+	  if (rlen < 0 || rlen != val || errno || *numend)
+	    fatal (diff_help);
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  int e;
+  sigset_t procmask;
+  sigset_t blocked;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  sigemptyset (&blocked);
+  sigaddset (&blocked, SIGINT);
+  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+  fd = mkstemp (buf);
+  e = errno;
+  if (0 <= fd)
+    tmpname = buf;
+  sigprocmask (SIG_SETMASK, &procmask, 0);
+  errno = e;
+  return fd;
+}
diff --git a/diffutils-3.0-patch/src/side.c b/diffutils-3.0-patch/src/side.c
new file mode 100644
index 0000000..6aa96a9
--- /dev/null
+++ b/diffutils-3.0-patch/src/side.c
@@ -0,0 +1,320 @@
+/* sdiff-format output routines for GNU DIFF.
+
+   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2010 Free Software
+   Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <wchar.h>
+
+static void print_sdiff_common_lines (lin, lin);
+static void print_sdiff_hunk (struct change *);
+
+/* Next line number to be printed in the two input files.  */
+static lin next0, next1;
+
+/* Print the edit-script SCRIPT as a sdiff style output.  */
+
+void
+print_sdiff_script (struct change *script)
+{
+  begin_output ();
+
+  next0 = next1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_sdiff_hunk);
+
+  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
+}
+
+/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */
+
+static size_t
+tab_from_to (size_t from, size_t to)
+{
+  FILE *out = outfile;
+  size_t tab;
+  size_t tab_size = tabsize;
+
+  if (!expand_tabs)
+    for (tab = from + tab_size - from % tab_size;  tab <= to;  tab += tab_size)
+      {
+	putc ('\t', out);
+	from = tab;
+      }
+  while (from++ < to)
+    putc (' ', out);
+  return to;
+}
+
+/* Print the text for half an sdiff line.  This means truncate to
+   width observing tabs, and trim a trailing newline.  Return the
+   last column written (not the number of chars).  */
+
+static size_t
+print_half_line (char const *const *line, size_t indent, size_t out_bound)
+{
+  FILE *out = outfile;
+  register size_t in_position = 0;
+  register size_t out_position = 0;
+  register char const *text_pointer = line[0];
+  register char const *text_limit = line[1];
+  mbstate_t mbstate = { 0 };
+
+  while (text_pointer < text_limit)
+    {
+      char const *tp0 = text_pointer;
+      register char c = *text_pointer++;
+
+      switch (c)
+	{
+	case '\t':
+	  {
+	    size_t spaces = tabsize - in_position % tabsize;
+	    if (in_position == out_position)
+	      {
+		size_t tabstop = out_position + spaces;
+		if (expand_tabs)
+		  {
+		    if (out_bound < tabstop)
+		      tabstop = out_bound;
+		    for (;  out_position < tabstop;  out_position++)
+		      putc (' ', out);
+		  }
+		else
+		  if (tabstop < out_bound)
+		    {
+		      out_position = tabstop;
+		      putc (c, out);
+		    }
+	      }
+	    in_position += spaces;
+	  }
+	  break;
+
+	case '\r':
+	  {
+	    putc (c, out);
+	    tab_from_to (0, indent);
+	    in_position = out_position = 0;
+	  }
+	  break;
+
+	case '\b':
+	  if (in_position != 0 && --in_position < out_bound)
+	    {
+	      if (out_position <= in_position)
+		/* Add spaces to make up for suppressed tab past out_bound.  */
+		for (;  out_position < in_position;  out_position++)
+		  putc (' ', out);
+	      else
+		{
+		  out_position = in_position;
+		  putc (c, out);
+		}
+	    }
+	  break;
+
+	default:
+	  {
+	    wchar_t wc;
+	    size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
+
+	    if (0 < bytes && bytes < (size_t) -2)
+	      {
+		int width = wcwidth (wc);
+		if (0 < width)
+		  in_position += width;
+		if (in_position <= out_bound)
+		  {
+		    out_position = in_position;
+		    fwrite (tp0, 1, bytes, stdout);
+		  }
+		text_pointer = tp0 + bytes;
+		break;
+	      }
+	  }
+	  /* Fall through.  */
+	case '\f':
+	case '\v':
+	  if (in_position < out_bound)
+	    putc (c, out);
+	  break;
+
+	case ' ': case '!': case '"': case '#': case '%':
+	case '&': case '\'': case '(': case ')': case '*':
+	case '+': case ',': case '-': case '.': case '/':
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+	case ':': case ';': case '<': case '=': case '>':
+	case '?':
+	case 'A': case 'B': case 'C': case 'D': case 'E':
+	case 'F': case 'G': case 'H': case 'I': case 'J':
+	case 'K': case 'L': case 'M': case 'N': case 'O':
+	case 'P': case 'Q': case 'R': case 'S': case 'T':
+	case 'U': case 'V': case 'W': case 'X': case 'Y':
+	case 'Z':
+	case '[': case '\\': case ']': case '^': case '_':
+	case 'a': case 'b': case 'c': case 'd': case 'e':
+	case 'f': case 'g': case 'h': case 'i': case 'j':
+	case 'k': case 'l': case 'm': case 'n': case 'o':
+	case 'p': case 'q': case 'r': case 's': case 't':
+	case 'u': case 'v': case 'w': case 'x': case 'y':
+	case 'z': case '{': case '|': case '}': case '~':
+	  /* These characters are printable ASCII characters.  */
+	  if (in_position++ < out_bound)
+	    {
+	      out_position = in_position;
+	      putc (c, out);
+	    }
+	  break;
+
+	case '\n':
+	  return out_position;
+	}
+    }
+
+  return out_position;
+}
+
+/* Print side by side lines with a separator in the middle.
+   0 parameters are taken to indicate white space text.
+   Blank lines that can easily be caught are reduced to a single newline.  */
+
+static void
+print_1sdiff_line (char const *const *left, char sep,
+		   char const *const *right)
+{
+  FILE *out = outfile;
+  size_t hw = sdiff_half_width;
+  size_t c2o = sdiff_column2_offset;
+  size_t col = 0;
+  bool put_newline = false;
+
+  if (left)
+    {
+      put_newline |= left[1][-1] == '\n';
+      col = print_half_line (left, 0, hw);
+    }
+
+  if (sep != ' ')
+    {
+      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
+      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
+	sep = put_newline ? '/' : '\\';
+      putc (sep, out);
+    }
+
+  if (right)
+    {
+      put_newline |= right[1][-1] == '\n';
+      if (**right != '\n')
+	{
+	  col = tab_from_to (col, c2o);
+	  print_half_line (right, col, hw);
+	}
+    }
+
+  if (put_newline)
+    putc ('\n', out);
+}
+
+/* Print lines common to both files in side-by-side format.  */
+static void
+print_sdiff_common_lines (lin limit0, lin limit1)
+{
+  lin i0 = next0, i1 = next1;
+
+  if (!suppress_common_lines && (i0 != limit0 || i1 != limit1))
+    {
+      if (sdiff_merge_assist)
+	{
+	  long int len0 = limit0 - i0;
+	  long int len1 = limit1 - i1;
+	  fprintf (outfile, "i%ld,%ld\n", len0, len1);
+	}
+
+      if (!left_column)
+	{
+	  while (i0 != limit0 && i1 != limit1)
+	    print_1sdiff_line (&files[0].linbuf[i0++], ' ',
+			       &files[1].linbuf[i1++]);
+	  while (i1 != limit1)
+	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
+	}
+      while (i0 != limit0)
+	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
+    }
+
+  next0 = limit0;
+  next1 = limit1;
+}
+
+/* Print a hunk of an sdiff diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_sdiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i, j;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes =
+    analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  /* Print out lines up to this change.  */
+  print_sdiff_common_lines (first0, first1);
+
+  if (sdiff_merge_assist)
+    {
+      long int len0 = last0 - first0 + 1;
+      long int len1 = last1 - first1 + 1;
+      fprintf (outfile, "c%ld,%ld\n", len0, len1);
+    }
+
+  /* Print ``xxx  |  xxx '' lines */
+  if (changes == CHANGED)
+    {
+      for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
+      changes = (i <= last0 ? OLD : 0) + (j <= last1 ? NEW : 0);
+      next0 = first0 = i;
+      next1 = first1 = j;
+    }
+
+  /* Print ``     >  xxx '' lines */
+  if (changes & NEW)
+    {
+      for (j = first1; j <= last1; ++j)
+	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
+      next1 = j;
+    }
+
+  /* Print ``xxx  <     '' lines */
+  if (changes & OLD)
+    {
+      for (i = first0; i <= last0; ++i)
+	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
+      next0 = i;
+    }
+}
diff --git a/diffutils-3.0-patch/src/system.h b/diffutils-3.0-patch/src/system.h
new file mode 100644
index 0000000..8942296
--- /dev/null
+++ b/diffutils-3.0-patch/src/system.h
@@ -0,0 +1,228 @@
+/* System dependent declarations.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Use this to suppress gcc's `...may be used before initialized' warnings. */
+#ifdef lint
+# define IF_LINT(Code) Code
+#else
+# define IF_LINT(Code) /* empty */
+#endif
+
+/* Define `__attribute__' and `volatile' first
+   so that they're used consistently in all system includes.  */
+#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6) || __STRICT_ANSI__
+# define __attribute__(x)
+#endif
+
+#include <verify.h>
+
+#include <sys/types.h>
+
+#include <sys/stat.h>
+#include "stat-macros.h"
+
+#ifndef STAT_BLOCKSIZE
+# if HAVE_STRUCT_STAT_ST_BLKSIZE
+#  define STAT_BLOCKSIZE(s) ((s).st_blksize)
+# else
+#  define STAT_BLOCKSIZE(s) (8 * 1024)
+# endif
+#endif
+
+#include <unistd.h>
+
+#include <fcntl.h>
+#include <time.h>
+
+#include <sys/wait.h>
+#ifndef WEXITSTATUS
+# define WEXITSTATUS(stat_val) ((unsigned int) (stat_val) >> 8)
+#endif
+#ifndef WIFEXITED
+# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
+#endif
+
+#include <dirent.h>
+#ifndef _D_EXACT_NAMLEN
+# define _D_EXACT_NAMLEN(dp) strlen ((dp)->d_name)
+#endif
+
+#include <stdlib.h>
+#define EXIT_TROUBLE 2
+
+#include <limits.h>
+#include <locale.h>
+#include <stddef.h>
+#include <inttypes.h>
+
+#include <string.h>
+#if ! HAVE_STRCASECOLL
+# if HAVE_STRICOLL || defined stricoll
+#  define strcasecoll(a, b) stricoll (a, b)
+# else
+#  define strcasecoll(a, b) strcasecmp (a, b) /* best we can do */
+# endif
+#endif
+#if ! (HAVE_STRCASECMP || defined strcasecmp)
+int strcasecmp (char const *, char const *);
+#endif
+
+#include <gettext.h>
+#if ! ENABLE_NLS
+# undef textdomain
+# define textdomain(Domainname) /* empty */
+# undef bindtextdomain
+# define bindtextdomain(Domainname, Dirname) /* empty */
+#endif
+
+#define _(msgid) gettext (msgid)
+#define N_(msgid) msgid
+
+#include <ctype.h>
+
+/* ISDIGIT differs from isdigit, as follows:
+   - Its arg may be any int or unsigned int; it need not be an unsigned char.
+   - It's guaranteed to evaluate its argument exactly once.
+   - It's typically faster.
+   POSIX 1003.1-2001 says that only '0' through '9' are digits.
+   Prefer ISDIGIT to isdigit unless it's important to use the locale's
+   definition of `digit' even when the host does not conform to POSIX.  */
+#define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)
+
+#include <errno.h>
+
+#include <signal.h>
+#ifndef SA_RESTART
+# ifdef SA_INTERRUPT /* e.g. SunOS 4.1.x */
+#  define SA_RESTART SA_INTERRUPT
+# else
+#  define SA_RESTART 0
+# endif
+#endif
+#if !defined SIGCHLD && defined SIGCLD
+# define SIGCHLD SIGCLD
+#endif
+
+#undef MIN
+#undef MAX
+#define MIN(a, b) ((a) <= (b) ? (a) : (b))
+#define MAX(a, b) ((a) >= (b) ? (a) : (b))
+
+#include <stdbool.h>
+
+#if HAVE_VFORK_H
+# include <vfork.h>
+#endif
+
+#if ! HAVE_WORKING_VFORK
+# define vfork fork
+#endif
+
+#include <intprops.h>
+#include "propername.h"
+
+/* Type used for fast comparison of several bytes at a time.  */
+
+#ifndef word
+# define word uintmax_t
+#endif
+
+/* The integer type of a line number.  Since files are read into main
+   memory, ptrdiff_t should be wide enough.  */
+
+typedef ptrdiff_t lin;
+#define LIN_MAX PTRDIFF_MAX
+verify (TYPE_SIGNED (lin));
+verify (sizeof (ptrdiff_t) <= sizeof (lin));
+verify (sizeof (lin) <= sizeof (long int));
+
+/* This section contains POSIX-compliant defaults for macros
+   that are meant to be overridden by hand in config.h as needed.  */
+
+#ifndef file_name_cmp
+# define file_name_cmp strcmp
+#endif
+
+#ifndef initialize_main
+# define initialize_main(argcp, argvp)
+#endif
+
+#ifndef NULL_DEVICE
+# define NULL_DEVICE "/dev/null"
+#endif
+
+/* Do struct stat *S, *T describe the same special file?  */
+#ifndef same_special_file
+# if HAVE_ST_RDEV && defined S_ISBLK && defined S_ISCHR
+#  define same_special_file(s, t) \
+     (((S_ISBLK ((s)->st_mode) && S_ISBLK ((t)->st_mode)) \
+       || (S_ISCHR ((s)->st_mode) && S_ISCHR ((t)->st_mode))) \
+      && (s)->st_rdev == (t)->st_rdev)
+# else
+#  define same_special_file(s, t) 0
+# endif
+#endif
+
+/* Do struct stat *S, *T describe the same file?  Answer -1 if unknown.  */
+#ifndef same_file
+# define same_file(s, t) \
+    ((((s)->st_ino == (t)->st_ino) && ((s)->st_dev == (t)->st_dev)) \
+     || same_special_file (s, t))
+#endif
+
+/* Do struct stat *S, *T have the same file attributes?
+
+   POSIX says that two files are identical if st_ino and st_dev are
+   the same, but many file systems incorrectly assign the same (device,
+   inode) pair to two distinct files, including:
+
+   - GNU/Linux NFS servers that export all local file systems as a
+     single NFS file system, if a local device number (st_dev) exceeds
+     255, or if a local inode number (st_ino) exceeds 16777215.
+
+   - Network Appliance NFS servers in snapshot directories; see
+     Network Appliance bug #195.
+
+   - ClearCase MVFS; see bug id ATRia04618.
+
+   Check whether two files that purport to be the same have the same
+   attributes, to work around instances of this common bug.  Do not
+   inspect all attributes, only attributes useful in checking for this
+   bug.
+
+   It's possible for two distinct files on a buggy file system to have
+   the same attributes, but it's not worth slowing down all
+   implementations (or complicating the configuration) to cater to
+   these rare cases in buggy implementations.  */
+
+#ifndef same_file_attributes
+# define same_file_attributes(s, t) \
+   ((s)->st_mode == (t)->st_mode \
+    && (s)->st_nlink == (t)->st_nlink \
+    && (s)->st_uid == (t)->st_uid \
+    && (s)->st_gid == (t)->st_gid \
+    && (s)->st_size == (t)->st_size \
+    && (s)->st_mtime == (t)->st_mtime \
+    && (s)->st_ctime == (t)->st_ctime)
+#endif
+
+#define STREQ(a, b) (strcmp (a, b) == 0)
diff --git a/diffutils-3.0-patch/src/util.c b/diffutils-3.0-patch/src/util.c
new file mode 100644
index 0000000..d18bf38
--- /dev/null
+++ b/diffutils-3.0-patch/src/util.c
@@ -0,0 +1,788 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <dirname.h>
+#include <error.h>
+#include <sh-quote.h>
+#include <xalloc.h>
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a `struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  error (EXIT_TROUBLE, e, "%s", name);
+  abort ();
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to `message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a `pr' and make OUTFILE a pipe to it.
+   `pr' then outputs to our stdout.  */
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t pr_pid;
+#endif
+
+void
+begin_output (void)
+{
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  /* Construct the header of this piece of diff.  */
+  name = xmalloc (strlen (current_name0) + strlen (current_name1)
+		  + strlen (switch_string) + 7);
+
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+
+  if (paginate)
+    {
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+      {
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = vfork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	  }
+#else
+	char *command = xmalloc (sizeof pr_program - 1 + 7
+				 + shell_quote_length (name) + 1);
+	char *p;
+	sprintf (command, "%s -f -h ", pr_program);
+	p = command + sizeof pr_program - 1 + 7;
+	p = shell_quote_copy (p, name);
+	*p = 0;
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to `stdout'.  */
+
+      outfile = stdout;
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, true);
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the `pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	error (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change *
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change *
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit, flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  if (!expand_tabs)
+    fwrite (base, sizeof (char), limit - base, outfile);
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+
+      while (t < limit)
+	switch ((c = *t++))
+	  {
+	  case '\t':
+	    {
+	      size_t spaces = tab_size - column % tab_size;
+	      column += spaces;
+	      do
+		putc (' ', out);
+	      while (--spaces);
+	    }
+	    break;
+
+	  case '\r':
+	    putc (c, out);
+	    if (flag_format && t < limit && *t != '\n')
+	      fprintf (out, flag_format, line_flag);
+	    column = 0;
+	    break;
+
+	  case '\b':
+	    if (column == 0)
+	      continue;
+	    column--;
+	    putc (c, out);
+	    break;
+
+	  default:
+	    column += isprint (c) != 0;
+	    putc (c, out);
+	    break;
+	  }
+    }
+}
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to long int rather than lin, so that the
+   caller can use printf with "%ld" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 long int *aptr, long int *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%ld", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of `struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+  bool skip_leading_white_space =
+    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *newline = linbuf0[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *newline = linbuf1[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+/* Yield the newly malloc'd pathname
+   of the file in DIR whose filename is FILE.  */
+
+char *
+dir_file_pathname (char const *dir, char const *file)
+{
+  char const *base = last_component (dir);
+  size_t baselen = base_len (base);
+  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
+  return concat (dir, "/" + omit_slash, file);
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      long int line0 = sp->line0;
+      long int line1 = sp->line1;
+      long int deleted = sp->deleted;
+      long int inserted = sp->inserted;
+      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
diff --git a/diffutils-3.0/quote-3.0-test.txt b/diffutils-3.0/quote-3.0-test.txt
new file mode 100644
index 0000000..e69de29
diff --git a/diffutils-3.0/src/Makefile.am b/diffutils-3.0/src/Makefile.am
new file mode 100644
index 0000000..35ddefe
--- /dev/null
+++ b/diffutils-3.0/src/Makefile.am
@@ -0,0 +1,80 @@
+# Automakefile for GNU diffutils programs.
+
+# Copyright (C) 2001-2002, 2006, 2009-2013, 2015-2018 Free Software Foundation,
+# Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+bin_PROGRAMS = cmp diff diff3 sdiff
+
+localedir = $(datadir)/locale
+
+AM_CPPFLAGS = -I../lib -I$(top_srcdir)/lib
+AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS)
+
+LDADD = \
+  libver.a \
+  ../lib/libdiffutils.a \
+  $(LIBCSTACK) \
+  $(LIBINTL) \
+  $(LIBICONV) \
+  $(LIBSIGSEGV) \
+  $(LIB_CLOCK_GETTIME)
+
+diff_LDADD = $(LDADD)
+cmp_LDADD = $(LDADD)
+sdiff_LDADD = $(LDADD)
+diff3_LDADD = $(LDADD)
+
+cmp_SOURCES = cmp.c
+diff3_SOURCES = diff3.c
+sdiff_SOURCES = sdiff.c
+diff_SOURCES = \
+  analyze.c context.c diff.c dir.c ed.c ifdef.c io.c \
+  normal.c side.c util.c
+noinst_HEADERS =	\
+  die.h			\
+  diff.h		\
+  system.h
+
+MOSTLYCLEANFILES = paths.h paths.ht
+
+cmp.$(OBJEXT) diff3.$(OBJEXT) diff.$(OBJEXT) sdiff.$(OBJEXT): paths.h
+
+gdiff = `echo diff|sed '$(transform)'`
+BUILT_SOURCES = paths.h
+paths.h: Makefile.am
+	$(AM_V_GEN)(echo '#define DEFAULT_DIFF_PROGRAM "'$(gdiff)'"' && \
+	  echo '#define LOCALEDIR "$(localedir)"') >$@t && mv $@t $@
+
+noinst_LIBRARIES = libver.a
+nodist_libver_a_SOURCES = version.c version.h
+
+BUILT_SOURCES += version.c
+version.c: Makefile
+	$(AM_V_GEN)rm -f $@
+	$(AM_V_at)printf '#include <config.h>\n' > $@t
+	$(AM_V_at)printf 'char const *Version = "$(PACKAGE_VERSION)";\n' >> $@t
+	$(AM_V_at)chmod a-w $@t
+	$(AM_V_at)mv $@t $@
+
+BUILT_SOURCES += version.h
+version.h: Makefile
+	$(AM_V_GEN)rm -f $@
+	$(AM_V_at)printf 'extern char const *Version;\n' > $@t
+	$(AM_V_at)chmod a-w $@t
+	$(AM_V_at)mv $@t $@
+
+DISTCLEANFILES = version.c version.h
+MAINTAINERCLEANFILES = $(BUILT_SOURCES)
diff --git a/diffutils-3.0/src/analyze.c b/diffutils-3.0/src/analyze.c
new file mode 100644
index 0000000..3c5b002
--- /dev/null
+++ b/diffutils-3.0/src/analyze.c
@@ -0,0 +1,716 @@
+/* Analyze file differences for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2013, 2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <error.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* The core of the Diff algorithm.  */
+#define ELEMENT lin
+#define EQUAL(x,y) ((x) == (y))
+#define OFFSET lin
+#define EXTRA_CONTEXT_FIELDS /* none */
+#define NOTE_DELETE(c, xoff) (files[0].changed[files[0].realindexes[xoff]] = 1)
+#define NOTE_INSERT(c, yoff) (files[1].changed[files[1].realindexes[yoff]] = 1)
+#define USE_HEURISTIC 1
+#include <diffseq.h>
+
+/* Discard lines from one file that have no matches in the other file.
+
+   A line which is discarded will not be considered by the actual
+   comparison algorithm; it will be as if that line were not in the file.
+   The file's 'realindexes' table maps virtual line numbers
+   (which don't count the discarded lines) into real line numbers;
+   this is how the actual comparison algorithm produces results
+   that are comprehensible when the discarded lines are counted.
+
+   When we discard a line, we also mark it as a deletion or insertion
+   so that it will be printed in the output.  */
+
+static void
+discard_confusing_lines (struct file_data filevec[])
+{
+  int f;
+  lin i;
+  char *discarded[2];
+  lin *equiv_count[2];
+  lin *p;
+
+  /* Allocate our results.  */
+  p = xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
+	       * (2 * sizeof *p));
+  for (f = 0; f < 2; f++)
+    {
+      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
+      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
+    }
+
+  /* Set up equiv_count[F][I] as the number of lines in file F
+     that fall in equivalence class I.  */
+
+  p = zalloc (filevec[0].equiv_max * (2 * sizeof *p));
+  equiv_count[0] = p;
+  equiv_count[1] = p + filevec[0].equiv_max;
+
+  for (i = 0; i < filevec[0].buffered_lines; ++i)
+    ++equiv_count[0][filevec[0].equivs[i]];
+  for (i = 0; i < filevec[1].buffered_lines; ++i)
+    ++equiv_count[1][filevec[1].equivs[i]];
+
+  /* Set up tables of which lines are going to be discarded.  */
+
+  discarded[0] = zalloc (filevec[0].buffered_lines
+			 + filevec[1].buffered_lines);
+  discarded[1] = discarded[0] + filevec[0].buffered_lines;
+
+  /* Mark to be discarded each line that matches no line of the other file.
+     If a line matches many lines, mark it as provisionally discardable.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      size_t end = filevec[f].buffered_lines;
+      char *discards = discarded[f];
+      lin *counts = equiv_count[1 - f];
+      lin *equivs = filevec[f].equivs;
+      size_t many = 5;
+      size_t tem = end / 64;
+
+      /* Multiply MANY by approximate square root of number of lines.
+	 That is the threshold for provisionally discardable lines.  */
+      while ((tem = tem >> 2) > 0)
+	many *= 2;
+
+      for (i = 0; i < end; i++)
+	{
+	  lin nmatch;
+	  if (equivs[i] == 0)
+	    continue;
+	  nmatch = counts[equivs[i]];
+	  if (nmatch == 0)
+	    discards[i] = 1;
+	  else if (nmatch > many)
+	    discards[i] = 2;
+	}
+    }
+
+  /* Don't really discard the provisional lines except when they occur
+     in a run of discardables, with nonprovisionals at the beginning
+     and end.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      lin end = filevec[f].buffered_lines;
+      register char *discards = discarded[f];
+
+      for (i = 0; i < end; i++)
+	{
+	  /* Cancel provisional discards not in middle of run of discards.  */
+	  if (discards[i] == 2)
+	    discards[i] = 0;
+	  else if (discards[i] != 0)
+	    {
+	      /* We have found a nonprovisional discard.  */
+	      register lin j;
+	      lin length;
+	      lin provisional = 0;
+
+	      /* Find end of this run of discardable lines.
+		 Count how many are provisionally discardable.  */
+	      for (j = i; j < end; j++)
+		{
+		  if (discards[j] == 0)
+		    break;
+		  if (discards[j] == 2)
+		    ++provisional;
+		}
+
+	      /* Cancel provisional discards at end, and shrink the run.  */
+	      while (j > i && discards[j - 1] == 2)
+		discards[--j] = 0, --provisional;
+
+	      /* Now we have the length of a run of discardable lines
+		 whose first and last are not provisional.  */
+	      length = j - i;
+
+	      /* If 1/4 of the lines in the run are provisional,
+		 cancel discarding of all provisional lines in the run.  */
+	      if (provisional * 4 > length)
+		{
+		  while (j > i)
+		    if (discards[--j] == 2)
+		      discards[j] = 0;
+		}
+	      else
+		{
+		  register lin consec;
+		  lin minimum = 1;
+		  lin tem = length >> 2;
+
+		  /* MINIMUM is approximate square root of LENGTH/4.
+		     A subrun of two or more provisionals can stand
+		     when LENGTH is at least 16.
+		     A subrun of 4 or more can stand when LENGTH >= 64.  */
+		  while (0 < (tem >>= 2))
+		    minimum <<= 1;
+		  minimum++;
+
+		  /* Cancel any subrun of MINIMUM or more provisionals
+		     within the larger run.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    if (discards[i + j] != 2)
+		      consec = 0;
+		    else if (minimum == ++consec)
+		      /* Back up to start of subrun, to cancel it all.  */
+		      j -= consec;
+		    else if (minimum < consec)
+		      discards[i + j] = 0;
+
+		  /* Scan from beginning of run
+		     until we find 3 or more nonprovisionals in a row
+		     or until the first nonprovisional at least 8 lines in.
+		     Until that point, cancel any provisionals.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i + j] == 1)
+			break;
+		      if (discards[i + j] == 2)
+			consec = 0, discards[i + j] = 0;
+		      else if (discards[i + j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+
+		  /* I advances to the last line of the run.  */
+		  i += length - 1;
+
+		  /* Same thing, from end.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i - j] == 1)
+			break;
+		      if (discards[i - j] == 2)
+			consec = 0, discards[i - j] = 0;
+		      else if (discards[i - j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+		}
+	    }
+	}
+    }
+
+  /* Actually discard the lines. */
+  for (f = 0; f < 2; f++)
+    {
+      char *discards = discarded[f];
+      lin end = filevec[f].buffered_lines;
+      lin j = 0;
+      for (i = 0; i < end; ++i)
+	if (minimal || discards[i] == 0)
+	  {
+	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
+	    filevec[f].realindexes[j++] = i;
+	  }
+	else
+	  filevec[f].changed[i] = 1;
+      filevec[f].nondiscarded_lines = j;
+    }
+
+  free (discarded[0]);
+  free (equiv_count[0]);
+}
+
+/* Adjust inserts/deletes of identical lines to join changes
+   as much as possible.
+
+   We do something when a run of changed lines include a
+   line at one end and have an excluded, identical line at the other.
+   We are free to choose which identical line is included.
+   'compareseq' usually chooses the one at the beginning,
+   but usually it is cleaner to consider the following identical line
+   to be the "change".  */
+
+static void
+shift_boundaries (struct file_data filevec[])
+{
+  int f;
+
+  for (f = 0; f < 2; f++)
+    {
+      char *changed = filevec[f].changed;
+      char *other_changed = filevec[1 - f].changed;
+      lin const *equivs = filevec[f].equivs;
+      lin i = 0;
+      lin j = 0;
+      lin i_end = filevec[f].buffered_lines;
+
+      while (1)
+	{
+	  lin runlength, start, corresponding;
+
+	  /* Scan forwards to find beginning of another run of changes.
+	     Also keep track of the corresponding point in the other file.  */
+
+	  while (i < i_end && !changed[i])
+	    {
+	      while (other_changed[j++])
+		continue;
+	      i++;
+	    }
+
+	  if (i == i_end)
+	    break;
+
+	  start = i;
+
+	  /* Find the end of this run of changes.  */
+
+	  while (changed[++i])
+	    continue;
+	  while (other_changed[j])
+	    j++;
+
+	  do
+	    {
+	      /* Record the length of this run of changes, so that
+		 we can later determine whether the run has grown.  */
+	      runlength = i - start;
+
+	      /* Move the changed region back, so long as the
+		 previous unchanged line matches the last changed one.
+		 This merges with previous changed regions.  */
+
+	      while (start && equivs[start - 1] == equivs[i - 1])
+		{
+		  changed[--start] = 1;
+		  changed[--i] = 0;
+		  while (changed[start - 1])
+		    start--;
+		  while (other_changed[--j])
+		    continue;
+		}
+
+	      /* Set CORRESPONDING to the end of the changed run, at the last
+		 point where it corresponds to a changed run in the other file.
+		 CORRESPONDING == I_END means no such point has been found.  */
+	      corresponding = other_changed[j - 1] ? i : i_end;
+
+	      /* Move the changed region forward, so long as the
+		 first changed line matches the following unchanged one.
+		 This merges with following changed regions.
+		 Do this second, so that if there are no merges,
+		 the changed region is moved forward as far as possible.  */
+
+	      while (i != i_end && equivs[start] == equivs[i])
+		{
+		  changed[start++] = 0;
+		  changed[i++] = 1;
+		  while (changed[i])
+		    i++;
+		  while (other_changed[++j])
+		    corresponding = i;
+		}
+	    }
+	  while (runlength != i - start);
+
+	  /* If possible, move the fully-merged run of changes
+	     back to a corresponding run in the other file.  */
+
+	  while (corresponding < i)
+	    {
+	      changed[--start] = 1;
+	      changed[--i] = 0;
+	      while (other_changed[--j])
+		continue;
+	    }
+	}
+    }
+}
+
+/* Cons an additional entry onto the front of an edit script OLD.
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+static struct change *
+add_change (lin line0, lin line1, lin deleted, lin inserted,
+	    struct change *old)
+{
+  struct change *new = xmalloc (sizeof *new);
+
+  new->line0 = line0;
+  new->line1 = line1;
+  new->inserted = inserted;
+  new->deleted = deleted;
+  new->link = old;
+  return new;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in reverse order.  */
+
+static struct change *
+build_reverse_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin len0 = filevec[0].buffered_lines;
+  lin len1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[lenN] does exist, and is 0.  */
+
+  lin i0 = 0, i1 = 0;
+
+  while (i0 < len0 || i1 < len1)
+    {
+      if (changed0[i0] | changed1[i1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0]) ++i0;
+	  while (changed1[i1]) ++i1;
+
+	  /* Record this change.  */
+	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0++, i1++;
+    }
+
+  return script;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in forward order.  */
+
+static struct change *
+build_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[-1] does exist, and is 0.  */
+
+  while (i0 >= 0 || i1 >= 0)
+    {
+      if (changed0[i0 - 1] | changed1[i1 - 1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0 - 1]) --i0;
+	  while (changed1[i1 - 1]) --i1;
+
+	  /* Record this change.  */
+	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0--, i1--;
+    }
+
+  return script;
+}
+
+/* If CHANGES, briefly report that two files differed.  */
+static void
+briefly_report (int changes, struct file_data const filevec[])
+{
+  if (changes)
+    message ((brief
+	      ? _("Files %s and %s differ\n")
+	      : _("Binary files %s and %s differ\n")),
+	     file_label[0] ? file_label[0] : filevec[0].name,
+	     file_label[1] ? file_label[1] : filevec[1].name);
+}
+
+/* Report the differences of two files.  */
+int
+diff_2_files (struct comparison *cmp)
+{
+  int f;
+  struct change *e, *p;
+  struct change *script;
+  int changes;
+
+
+  /* If we have detected that either file is binary,
+     compare the two files as binary.  This can happen
+     only when the first chunk is read.
+     Also, --brief without any --ignore-* options means
+     we can speed things up by treating the files as binary.  */
+
+  if (read_files (cmp->file, files_can_be_treated_as_binary))
+    {
+      /* Files with different lengths must be different.  */
+      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
+	  && 0 < cmp->file[0].stat.st_size
+	  && 0 < cmp->file[1].stat.st_size
+	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+	changes = 1;
+
+      /* Standard input equals itself.  */
+      else if (cmp->file[0].desc == cmp->file[1].desc)
+	changes = 0;
+
+      else
+	/* Scan both files, a buffer at a time, looking for a difference.  */
+	{
+	  /* Allocate same-sized buffers for both files.  */
+	  size_t lcm_max = PTRDIFF_MAX - 1;
+	  size_t buffer_size =
+	    buffer_lcm (sizeof (word),
+			buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
+				    STAT_BLOCKSIZE (cmp->file[1].stat),
+				    lcm_max),
+			lcm_max);
+	  for (f = 0; f < 2; f++)
+	    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
+
+	  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
+	    {
+	      /* Read a buffer's worth from both files.  */
+	      for (f = 0; f < 2; f++)
+		if (0 <= cmp->file[f].desc)
+		  file_block_read (&cmp->file[f],
+				   buffer_size - cmp->file[f].buffered);
+
+	      /* If the buffers differ, the files differ.  */
+	      if (cmp->file[0].buffered != cmp->file[1].buffered
+		  || memcmp (cmp->file[0].buffer,
+			     cmp->file[1].buffer,
+			     cmp->file[0].buffered))
+		{
+		  changes = 1;
+		  break;
+		}
+
+	      /* If we reach end of file, the files are the same.  */
+	      if (cmp->file[0].buffered != buffer_size)
+		{
+		  changes = 0;
+		  break;
+		}
+	    }
+	}
+
+      briefly_report (changes, cmp->file);
+    }
+  else
+    {
+      struct context ctxt;
+      lin diags;
+      lin too_expensive;
+
+      /* Allocate vectors for the results of comparison:
+	 a flag for each line of each file, saying whether that line
+	 is an insertion or deletion.
+	 Allocate an extra element, always 0, at each end of each vector.  */
+
+      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;
+      char *flag_space = zalloc (s);
+      cmp->file[0].changed = flag_space + 1;
+      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;
+
+      /* Some lines are obviously insertions or deletions
+	 because they don't match anything.  Detect them now, and
+	 avoid even thinking about them in the main comparison algorithm.  */
+
+      discard_confusing_lines (cmp->file);
+
+      /* Now do the main comparison algorithm, considering just the
+	 undiscarded lines.  */
+
+      ctxt.xvec = cmp->file[0].undiscarded;
+      ctxt.yvec = cmp->file[1].undiscarded;
+      diags = (cmp->file[0].nondiscarded_lines
+	       + cmp->file[1].nondiscarded_lines + 3);
+      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));
+      ctxt.bdiag = ctxt.fdiag + diags;
+      ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;
+      ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1;
+
+      ctxt.heuristic = speed_large_files;
+
+      /* Set TOO_EXPENSIVE to be the approximate square root of the
+	 input size, bounded below by 4096.  4096 seems to be good for
+	 circa-2016 CPUs; see Bug#16848 and Bug#24715.  */
+      too_expensive = 1;
+      for (;  diags != 0;  diags >>= 2)
+	too_expensive <<= 1;
+      ctxt.too_expensive = MAX (4096, too_expensive);
+
+      files[0] = cmp->file[0];
+      files[1] = cmp->file[1];
+
+      compareseq (0, cmp->file[0].nondiscarded_lines,
+		  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
+
+      free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));
+
+      /* Modify the results slightly to make them prettier
+	 in cases where that can validly be done.  */
+
+      shift_boundaries (cmp->file);
+
+      /* Get the results of comparison in the form of a chain
+	 of 'struct change's -- an edit script.  */
+
+      if (output_style == OUTPUT_ED)
+	script = build_reverse_script (cmp->file);
+      else
+	script = build_script (cmp->file);
+
+      /* Set CHANGES if we had any diffs.
+	 If some changes are ignored, we must scan the script to decide.  */
+      if (ignore_blank_lines || ignore_regexp.fastmap)
+	{
+	  struct change *next = script;
+	  changes = 0;
+
+	  while (next && changes == 0)
+	    {
+	      struct change *this, *end;
+	      lin first0, last0, first1, last1;
+
+	      /* Find a set of changes that belong together.  */
+	      this = next;
+	      end = find_change (next);
+
+	      /* Disconnect them from the rest of the changes, making them
+		 a hunk, and remember the rest for next iteration.  */
+	      next = end->link;
+	      end->link = 0;
+
+	      /* Determine whether this hunk is really a difference.  */
+	      if (analyze_hunk (this, &first0, &last0, &first1, &last1))
+		changes = 1;
+
+	      /* Reconnect the script so it will all be freed properly.  */
+	      end->link = next;
+	    }
+	}
+      else
+	changes = (script != 0);
+
+      if (brief)
+	briefly_report (changes, cmp->file);
+      else
+	{
+	  if (changes || !no_diff_means_no_output)
+	    {
+	      /* Record info for starting up output,
+		 to be used if and when we have some output to print.  */
+	      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
+			    file_label[1] ? file_label[1] : cmp->file[1].name,
+			    cmp->parent != 0);
+
+	      switch (output_style)
+		{
+		case OUTPUT_CONTEXT:
+		  print_context_script (script, false);
+		  break;
+
+		case OUTPUT_UNIFIED:
+		  print_context_script (script, true);
+		  break;
+
+		case OUTPUT_ED:
+		  print_ed_script (script);
+		  break;
+
+		case OUTPUT_FORWARD_ED:
+		  pr_forward_ed_script (script);
+		  break;
+
+		case OUTPUT_RCS:
+		  print_rcs_script (script);
+		  break;
+
+		case OUTPUT_NORMAL:
+		  print_normal_script (script);
+		  break;
+
+		case OUTPUT_IFDEF:
+		  print_ifdef_script (script);
+		  break;
+
+		case OUTPUT_SDIFF:
+		  print_sdiff_script (script);
+		  break;
+
+		default:
+		  abort ();
+		}
+
+	      finish_output ();
+	    }
+	}
+
+      free (cmp->file[0].undiscarded);
+
+      free (flag_space);
+
+      for (f = 0; f < 2; f++)
+	{
+	  free (cmp->file[f].equivs);
+	  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
+	}
+
+      for (e = script; e; e = p)
+	{
+	  p = e->link;
+	  free (e);
+	}
+
+      if (! ROBUST_OUTPUT_STYLE (output_style))
+	for (f = 0; f < 2; ++f)
+	  if (cmp->file[f].missing_newline)
+	    {
+	      error (0, 0, "%s: %s\n",
+		     file_label[f] ? file_label[f] : cmp->file[f].name,
+		     _("No newline at end of file"));
+	      changes = 2;
+	    }
+    }
+
+  if (cmp->file[0].buffer != cmp->file[1].buffer)
+    free (cmp->file[0].buffer);
+  free (cmp->file[1].buffer);
+
+  return changes;
+}
diff --git a/diffutils-3.0/src/cmp.c b/diffutils-3.0/src/cmp.c
new file mode 100644
index 0000000..04638e3
--- /dev/null
+++ b/diffutils-3.0/src/cmp.c
@@ -0,0 +1,693 @@
+/* GNU cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include "die.h"
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <binary-io.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *) _GL_ATTRIBUTE_PURE;
+static size_t count_newlines (char *, size_t);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  die (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value '%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    die (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    die (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b, --print-bytes          print differing bytes"),
+  N_("-i, --ignore-initial=SKIP         skip first SKIP bytes of both inputs"),
+  N_("-i, --ignore-initial=SKIP1:SKIP2  skip first SKIP1 bytes of FILE1 and\n"
+     "                                      first SKIP2 bytes of FILE2"),
+  N_("-l, --verbose              output byte numbers and differing byte values"),
+  N_("-n, --bytes=LIMIT          compare at most LIMIT bytes"),
+  N_("-s, --quiet, --silent      suppress all normal output"),
+  N_("    --help                 display this help and exit"),
+  N_("-v, --version              output version information and exit"),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n", _("Compare two files byte by byte."));
+  printf ("\n%s\n\n",
+_("The optional SKIP1 and SKIP2 specify the number of bytes to skip\n"
+  "at the beginning of each file (zero by default)."));
+
+  fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n\n%s\n%s\n",
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after '%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand '%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    set_binary_mode (STDIN_FILENO, O_BINARY);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    die (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      die (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on 'file_desc[0]' and 'file_desc[1]',
+   using 'buffer[0]' and 'buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  bool at_line_start = true;
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of 'read0' and 'read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    die (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	die (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	die (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      smaller = MIN (read0, read1);
+
+      /* Optimize the common case where the buffers are the same.  */
+      if (memcmp (buf0, buf1, smaller) == 0)
+	first_diff = smaller;
+      else
+	{
+	  /* Insert sentinels for the block compare.  */
+	  buf0[read0] = ~buf1[read0];
+	  buf1[read1] = ~buf0[read1];
+
+	  first_diff = block_compare (buffer0, buffer1);
+	}
+
+      byte_number += first_diff;
+      if (comparison_type == type_first_diff && first_diff != 0)
+	{
+	  line_number += count_newlines (buf0, first_diff);
+	  at_line_start = buf0[first_diff - 1] == '\n';
+	}
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX for this format.  This message is
+		       used only in the POSIX locale, so it need not
+		       be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		  }
+	      }
+	      FALLTHROUGH;
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      char const *shorter_file = file[read1 < read0];
+
+	      /* POSIX says that each of these format strings must be
+		 "cmp: EOF on %s", optionally followed by a blank and
+		 extra text sans newline, then terminated by "\n".  */
+	      if (byte_number == 1)
+		fprintf (stderr, _("cmp: EOF on %s which is empty\n"),
+			 shorter_file);
+	      else
+		{
+		  char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		  char const *byte_num = offtostr (byte_number - 1, byte_buf);
+
+		  if (comparison_type == type_first_diff)
+		    {
+		      char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *line_num
+			= offtostr (line_number - at_line_start, line_buf);
+		      fprintf (stderr,
+			       (at_line_start
+				? _("cmp: EOF on %s after byte %s, line %s\n")
+				: _("cmp: EOF on %s after byte %s,"
+				    " in line %s\n")),
+			       shorter_file, byte_num, line_num);
+		    }
+		  else
+		    fprintf (stderr,
+			     _("cmp: EOF on %s after byte %s\n"),
+			     shorter_file, byte_num);
+		}
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Return the number of newlines in BUF, of size BUFSIZE,
+   where BUF[NBYTES] is available for use as a sentinel.  */
+
+static size_t
+count_newlines (char *buf, size_t bufsize)
+{
+  size_t count = 0;
+  char *p;
+  char *lim = buf + bufsize;
+  *lim = '\n';
+  for (p = buf; (p = rawmemchr (p, '\n')) != lim; p++)
+    count++;
+  return count;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/diffutils-3.0/src/context.c b/diffutils-3.0/src/context.c
new file mode 100644
index 0000000..4dd882d
--- /dev/null
+++ b/diffutils-3.0/src/context.c
@@ -0,0 +1,537 @@
+/* Context-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include "c-ctype.h"
+#include <stat-time.h>
+#include <strftime.h>
+
+static char const *find_function (char const * const *, lin);
+static struct change *find_hunk (struct change *);
+static void mark_ignorable (struct change *);
+static void pr_context_hunk (struct change *);
+static void pr_unidiff_hunk (struct change *);
+
+/* Last place find_function started searching from.  */
+static lin find_function_last_search;
+
+/* The value find_function returned when it started searching there.  */
+static lin find_function_last_match;
+
+/* Print a label for a context diff, with a file name and date or a label.  */
+
+static void
+print_context_label (char const *mark,
+		     struct file_data *inf,
+		     char const *name,
+		     char const *label)
+{
+  if (label)
+    fprintf (outfile, "%s %s\n", mark, label);
+  else
+    {
+      char buf[MAX (INT_STRLEN_BOUND (int) + 32,
+		    INT_STRLEN_BOUND (time_t) + 11)];
+      struct tm const *tm = localtime (&inf->stat.st_mtime);
+      int nsec = get_stat_mtime_ns (&inf->stat);
+      if (! (tm && nstrftime (buf, sizeof buf, time_format, tm, 0, nsec)))
+	{
+	  verify (TYPE_IS_INTEGER (time_t));
+	  if (LONG_MIN <= TYPE_MINIMUM (time_t)
+	      && TYPE_MAXIMUM (time_t) <= LONG_MAX)
+	    {
+	      long int sec = inf->stat.st_mtime;
+	      sprintf (buf, "%ld.%.9d", sec, nsec);
+	    }
+	  else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
+	    {
+	      intmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
+	    }
+	  else
+	    {
+	      uintmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+	    }
+	}
+      fprintf (outfile, "%s %s\t%s\n", mark, name, buf);
+    }
+}
+
+/* Print a header for a context diff, with the file names and dates.  */
+
+void
+print_context_header (struct file_data inf[], char const *const *names, bool unidiff)
+{
+  set_color_context (HEADER_CONTEXT);
+  if (unidiff)
+    {
+      print_context_label ("---", &inf[0], names[0], file_label[0]);
+      print_context_label ("+++", &inf[1], names[1], file_label[1]);
+    }
+  else
+    {
+      print_context_label ("***", &inf[0], names[0], file_label[0]);
+      print_context_label ("---", &inf[1], names[1], file_label[1]);
+    }
+  set_color_context (RESET_CONTEXT);
+}
+
+/* Print an edit script in context format.  */
+
+void
+print_context_script (struct change *script, bool unidiff)
+{
+  if (ignore_blank_lines || ignore_regexp.fastmap)
+    mark_ignorable (script);
+  else
+    {
+      struct change *e;
+      for (e = script; e; e = e->link)
+	e->ignore = false;
+    }
+
+  find_function_last_search = - files[0].prefix_lines;
+  find_function_last_match = LIN_MAX;
+
+  if (unidiff)
+    print_script (script, find_hunk, pr_unidiff_hunk);
+  else
+    print_script (script, find_hunk, pr_context_hunk);
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is not greater, use the first in place of it.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_context_number_range (struct file_data const *file, lin a, lin b)
+{
+  printint trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B <= A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.
+
+     POSIX 1003.1-2001 requires two line numbers separated by a comma
+     even if the line numbers are the same.  However, this does not
+     match existing practice and is surely an error in the
+     specification.  */
+
+  if (trans_b <= trans_a)
+    fprintf (outfile, "%"pI"d", trans_b);
+  else
+    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b);
+}
+
+/* Print FUNCTION in a context header.  */
+static void
+print_context_function (FILE *out, char const *function)
+{
+  int i, j;
+  putc (' ', out);
+  for (i = 0; c_isspace ((unsigned char) function[i]) && function[i] != '\n'; i++)
+    continue;
+  for (j = i; j < i + 40 && function[j] != '\n'; j++)
+    continue;
+  while (i < j && c_isspace ((unsigned char) function[j - 1]))
+    j--;
+  fwrite (function + i, sizeof (char), j - i, out);
+}
+
+/* Print a portion of an edit script in context format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a 'link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_context_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1, i;
+  char const *prefix;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (! changes)
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("***************", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  putc ('\n', out);
+  set_color_context (LINE_NUMBER_CONTEXT);
+  fputs ("*** ", out);
+  print_context_number_range (&files[0], first0, last0);
+  fputs (" ****", out);
+  set_color_context (RESET_CONTEXT);
+  putc ('\n', out);
+
+  if (changes & OLD)
+    {
+      struct change *next = hunk;
+
+      if (first0 <= last0)
+        set_color_context (DELETE_CONTEXT);
+
+      for (i = first0; i <= last0; i++)
+	{
+	  /* Skip past changes that apply (in file 0)
+	     only to lines before line I.  */
+
+	  while (next && next->line0 + next->deleted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line0 <= i)
+            {
+              /* The change NEXT covers this line.
+                 If lines were inserted here in file 1, this is "changed".
+                 Otherwise it is "deleted".  */
+              prefix = (next->inserted > 0 ? "!" : "-");
+            }
+	  print_1_line_nl (prefix, &files[0].linbuf[i], true);
+          if (i == last0)
+            set_color_context (RESET_CONTEXT);
+          if (files[0].linbuf[i + 1][-1] == '\n')
+            putc ('\n', out);
+	}
+    }
+
+  set_color_context (LINE_NUMBER_CONTEXT);
+  fputs ("--- ", out);
+  print_context_number_range (&files[1], first1, last1);
+  fputs (" ----", out);
+  set_color_context (RESET_CONTEXT);
+  putc ('\n', out);
+
+  if (changes & NEW)
+    {
+      struct change *next = hunk;
+
+      if (first1 <= last1)
+        set_color_context (ADD_CONTEXT);
+
+      for (i = first1; i <= last1; i++)
+	{
+	  /* Skip past changes that apply (in file 1)
+	     only to lines before line I.  */
+
+	  while (next && next->line1 + next->inserted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line1 <= i)
+            {
+              /* The change NEXT covers this line.
+                 If lines were deleted here in file 0, this is "changed".
+                 Otherwise it is "inserted".  */
+              prefix = (next->deleted > 0 ? "!" : "+");
+            }
+	  print_1_line_nl (prefix, &files[1].linbuf[i], true);
+          if (i == last1)
+            set_color_context (RESET_CONTEXT);
+          if (files[1].linbuf[i + 1][-1] == '\n')
+            putc ('\n', out);
+	}
+    }
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is smaller, use the first in place of it.
+   If the numbers are equal, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+{
+  printint trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B < A in the case of a range of no lines.
+     In this case, we print the line number before the range,
+     which is B.  It would be more logical to print A, but
+     'patch' expects B in order to detect diffs against empty files.  */
+  if (trans_b <= trans_a)
+    fprintf (outfile, trans_b < trans_a ? "%"pI"d,0" : "%"pI"d", trans_b);
+  else
+    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b - trans_a + 1);
+}
+
+/* Print a portion of an edit script in unidiff format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a 'link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_unidiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  lin i, j, k;
+  struct change *next;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  if (! analyze_hunk (hunk, &first0, &last0, &first1, &last1))
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  set_color_context (LINE_NUMBER_CONTEXT);
+  fputs ("@@ -", out);
+  print_unidiff_number_range (&files[0], first0, last0);
+  fputs (" +", out);
+  print_unidiff_number_range (&files[1], first1, last1);
+  fputs (" @@", out);
+  set_color_context (RESET_CONTEXT);
+
+  if (function)
+    print_context_function (out, function);
+
+  putc ('\n', out);
+
+  next = hunk;
+  i = first0;
+  j = first1;
+
+  while (i <= last0 || j <= last1)
+    {
+
+      /* If the line isn't a difference, output the context from file 0. */
+
+      if (!next || i < next->line0)
+	{
+	  char const *const *line = &files[0].linbuf[i++];
+	  if (! (suppress_blank_empty && **line == '\n'))
+	    putc (initial_tab ? '\t' : ' ', out);
+	  print_1_line (NULL, line);
+	  j++;
+	}
+      else
+	{
+	  /* For each difference, first output the deleted part. */
+
+	  k = next->deleted;
+          if (k)
+            set_color_context (DELETE_CONTEXT);
+
+	  while (k--)
+	    {
+	      char const * const *line = &files[0].linbuf[i++];
+	      putc ('-', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line_nl (NULL, line, true);
+
+              if (!k)
+                set_color_context (RESET_CONTEXT);
+
+              if (line[1][-1] == '\n')
+                putc ('\n', out);
+	    }
+
+	  /* Then output the inserted part. */
+
+	  k = next->inserted;
+          if (k)
+            set_color_context (ADD_CONTEXT);
+
+          while (k--)
+	    {
+	      char const * const *line = &files[1].linbuf[j++];
+	      putc ('+', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line_nl (NULL, line, true);
+
+              if (!k)
+                set_color_context (RESET_CONTEXT);
+
+              if (line[1][-1] == '\n')
+                putc ('\n', out);
+	    }
+
+	  /* We're done with this hunk, so on to the next! */
+
+	  next = next->link;
+	}
+    }
+}
+
+/* Scan a (forward-ordered) edit script for the first place that more than
+   2*CONTEXT unchanged lines appear, and return a pointer
+   to the 'struct change' for the last change before those lines.  */
+
+static struct change * _GL_ATTRIBUTE_PURE
+find_hunk (struct change *start)
+{
+  struct change *prev;
+  lin top0, top1;
+  lin thresh;
+
+  /* Threshold distance is CONTEXT if the second change is ignorable,
+     2 * CONTEXT + 1 otherwise.  Integer overflow can't happen, due
+     to CONTEXT_LIM.  */
+  lin ignorable_threshold = context;
+  lin non_ignorable_threshold = 2 * context + 1;
+
+  do
+    {
+      /* Compute number of first line in each file beyond this changed.  */
+      top0 = start->line0 + start->deleted;
+      top1 = start->line1 + start->inserted;
+      prev = start;
+      start = start->link;
+      thresh = (start && start->ignore
+		? ignorable_threshold
+		: non_ignorable_threshold);
+      /* It is not supposed to matter which file we check in the end-test.
+	 If it would matter, crash.  */
+      if (start && start->line0 - top0 != start->line1 - top1)
+	abort ();
+    } while (start
+	     /* Keep going if less than THRESH lines
+		elapse before the affected line.  */
+	     && start->line0 - top0 < thresh);
+
+  return prev;
+}
+
+/* Set the 'ignore' flag properly in each change in SCRIPT.
+   It should be 1 if all the lines inserted or deleted in that change
+   are ignorable lines.  */
+
+static void
+mark_ignorable (struct change *script)
+{
+  while (script)
+    {
+      struct change *next = script->link;
+      lin first0, last0, first1, last1;
+
+      /* Turn this change into a hunk: detach it from the others.  */
+      script->link = NULL;
+
+      /* Determine whether this change is ignorable.  */
+      script->ignore = ! analyze_hunk (script,
+				       &first0, &last0, &first1, &last1);
+
+      /* Reconnect the chain as before.  */
+      script->link = next;
+
+      /* Advance to the following change.  */
+      script = next;
+    }
+}
+
+/* Find the last function-header line in LINBUF prior to line number LINENUM.
+   This is a line containing a match for the regexp in 'function_regexp'.
+   Return the address of the text, or NULL if no function-header is found.  */
+
+static char const *
+find_function (char const * const *linbuf, lin linenum)
+{
+  lin i = linenum;
+  lin last = find_function_last_search;
+  find_function_last_search = i;
+
+  while (last <= --i)
+    {
+      /* See if this line is what we want.  */
+      char const *line = linbuf[i];
+      size_t linelen = linbuf[i + 1] - line - 1;
+
+      /* FIXME: re_search's size args should be size_t, not int.  */
+      int len = MIN (linelen, INT_MAX);
+
+      if (0 <= re_search (&function_regexp, line, len, 0, len, NULL))
+	{
+	  find_function_last_match = i;
+	  return line;
+	}
+    }
+  /* If we search back to where we started searching the previous time,
+     find the line we found last time.  */
+  if (find_function_last_match != LIN_MAX)
+    return linbuf[find_function_last_match];
+
+  return NULL;
+}
diff --git a/diffutils-3.0/src/die.h b/diffutils-3.0/src/die.h
new file mode 100644
index 0000000..f56945f
--- /dev/null
+++ b/diffutils-3.0/src/die.h
@@ -0,0 +1,31 @@
+/* Report an error and exit.
+   Copyright 2016-2018 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifndef DIE_H
+# define DIE_H
+
+# include <error.h>
+# include <stdbool.h>
+# include <verify.h>
+
+/* Like 'error (STATUS, ...)', except STATUS must be a nonzero constant.
+   This may pacify the compiler or help it generate better code.  */
+# define die(status, ...) \
+  verify_expr (status, (error (status, __VA_ARGS__), assume (false)))
+
+#endif /* DIE_H */
diff --git a/diffutils-3.0/src/diff.c b/diffutils-3.0/src/diff.c
new file mode 100644
index 0000000..474da1e
--- /dev/null
+++ b/diffutils-3.0/src/diff.c
@@ -0,0 +1,1473 @@
+/* GNU diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2013, 2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include "die.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <filenamecat.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xreadlink.h>
+#include <binary-io.h>
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in 'regexps' */
+  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void specify_colors_style (char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* If one file is missing, treat it as present but empty (-N).  */
+static bool new_file;
+
+/* If the first file is missing, treat it as present but empty
+   (--unidirectional-new-file).  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:yZ";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_DEREFERENCE_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION,
+
+  COLOR_OPTION,
+  COLOR_PALETTE_OPTION,
+
+  PRESUME_OUTPUT_TTY_OPTION,
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"color", 2, 0, COLOR_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"ignore-trailing-space", 0, 0, 'Z'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-dereference", 0, 0, NO_DEREFERENCE_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"palette", 1, 0, COLOR_PALETTE_OPTION},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+
+  /* This is solely for testing.  Do not document.  */
+  {"-presume-output-tty", no_argument, NULL, PRESUME_OUTPUT_TTY_OPTION},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+  presume_output_tty = false;
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  ocontext = (! ISDIGIT (prev)
+		      ? c - '0'
+		      : (ocontext - (c - '0' <= CONTEXT_MAX % 10)
+			 < CONTEXT_MAX / 10)
+		      ? 10 * ocontext + (c - '0')
+		      : CONTEXT_MAX);
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'Z':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space |= IGNORE_TRAILING_SPACE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (CONTEXT_MAX < numval)
+		  numval = CONTEXT_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space |= IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    set_binary_mode (STDOUT_FILENO, O_BINARY);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_DEREFERENCE_OPTION:
+	  no_dereference_symlinks = true;
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX - GUTTER_WIDTH_MINIMUM)
+	      || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	case COLOR_OPTION:
+	  specify_colors_style (optarg);
+	  break;
+
+	case COLOR_PALETTE_OPTION:
+	  set_color_palette (optarg);
+	  break;
+
+        case PRESUME_OUTPUT_TTY_OPTION:
+          presume_output_tty = true;
+          break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (colors_style == AUTO)
+    {
+      char const *t = getenv ("TERM");
+      if (t && STREQ (t, "dumb"))
+        colors_style = NEVER;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    size_t t = expand_tabs ? 1 : tabsize;
+    size_t w = width;
+    size_t t_plus_g = t + GUTTER_WIDTH_MINIMUM;
+    size_t unaligned_off = (w >> 1) + (t_plus_g >> 1) + (w & t_plus_g & 1);
+    size_t off = unaligned_off - unaligned_off % t;
+    sdiff_half_width = (off <= GUTTER_WIDTH_MINIMUM || w <= off
+			? 0
+			: MIN (off - GUTTER_WIDTH_MINIMUM, w - off));
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (EXIT_TROUBLE, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    die (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("    --normal                  output a normal diff (the default)"),
+  N_("-q, --brief                   report only when files differ"),
+  N_("-s, --report-identical-files  report when two files are the same"),
+  N_("-c, -C NUM, --context[=NUM]   output NUM (default 3) lines of copied context"),
+  N_("-u, -U NUM, --unified[=NUM]   output NUM (default 3) lines of unified context"),
+  N_("-e, --ed                      output an ed script"),
+  N_("-n, --rcs                     output an RCS format diff"),
+  N_("-y, --side-by-side            output in two columns"),
+  N_("-W, --width=NUM               output at most NUM (default 130) print columns"),
+  N_("    --left-column             output only the left column of common lines"),
+  N_("    --suppress-common-lines   do not output common lines"),
+  "",
+  N_("-p, --show-c-function         show which C function each change is in"),
+  N_("-F, --show-function-line=RE   show the most recent line matching RE"),
+  N_("    --label LABEL             use LABEL instead of file name and timestamp\n"
+     "                                (can be repeated)"),
+  "",
+  N_("-t, --expand-tabs             expand tabs to spaces in output"),
+  N_("-T, --initial-tab             make tabs line up by prepending a tab"),
+  N_("    --tabsize=NUM             tab stops every NUM (default 8) print columns"),
+  N_("    --suppress-blank-empty    suppress space or tab before empty output lines"),
+  N_("-l, --paginate                pass output through 'pr' to paginate it"),
+  "",
+  N_("-r, --recursive                 recursively compare any subdirectories found"),
+  N_("    --no-dereference            don't follow symbolic links"),
+  N_("-N, --new-file                  treat absent files as empty"),
+  N_("    --unidirectional-new-file   treat absent first files as empty"),
+  N_("    --ignore-file-name-case     ignore case when comparing file names"),
+  N_("    --no-ignore-file-name-case  consider case when comparing file names"),
+  N_("-x, --exclude=PAT               exclude files that match PAT"),
+  N_("-X, --exclude-from=FILE         exclude files that match any pattern in FILE"),
+  N_("-S, --starting-file=FILE        start with FILE when comparing directories"),
+  N_("    --from-file=FILE1           compare FILE1 to all operands;\n"
+     "                                  FILE1 can be a directory"),
+  N_("    --to-file=FILE2             compare all operands to FILE2;\n"
+     "                                  FILE2 can be a directory"),
+  "",
+  N_("-i, --ignore-case               ignore case differences in file contents"),
+  N_("-E, --ignore-tab-expansion      ignore changes due to tab expansion"),
+  N_("-Z, --ignore-trailing-space     ignore white space at line end"),
+  N_("-b, --ignore-space-change       ignore changes in the amount of white space"),
+  N_("-w, --ignore-all-space          ignore all white space"),
+  N_("-B, --ignore-blank-lines        ignore changes where lines are all blank"),
+  N_("-I, --ignore-matching-lines=RE  ignore changes where all lines match RE"),
+  "",
+  N_("-a, --text                      treat all files as text"),
+  N_("    --strip-trailing-cr         strip trailing carriage return on input"),
+#if O_BINARY
+  N_("    --binary                    read and write data in binary mode"),
+#endif
+  "",
+  N_("-D, --ifdef=NAME                output merged file with '#ifdef NAME' diffs"),
+  N_("    --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT"),
+  N_("    --line-format=LFMT          format all input lines with LFMT"),
+  N_("    --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT"),
+  N_("  These format options provide fine-grained control over the output\n"
+     "    of diff, generalizing -D/--ifdef."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+  N_("  GFMT (only) may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1\n\
+    %(A=B?T:E)  if A equals B then T else E"),
+  N_("  LFMT (only) may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Both GFMT and LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO\n\
+    C    the character C (other characters represent themselves)"),
+  "",
+  N_("-d, --minimal            try hard to find a smaller set of changes"),
+  N_("    --horizon-lines=NUM  keep NUM lines of the common prefix and suffix"),
+  N_("    --speed-large-files  assume large files and many scattered small changes"),
+  N_("    --color[=WHEN]       colorize the output; WHEN can be 'never', 'always',\n"
+     "                           or 'auto' (the default)"),
+  N_("    --palette=PALETTE    the colors to use when --color is active; PALETTE is\n"
+     "                           a colon-separated list of terminfo capabilities"),
+  "",
+  N_("    --help               display this help and exit"),
+  N_("-v, --version            output version information and exit"),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE' or 'FILE DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILE(s)."),
+  N_("If a FILE is '-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+  printf ("%s\n\n", _("Compare FILES line by line."));
+
+  fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && ! STREQ (*var, value))
+    {
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the color mode.  */
+static void
+specify_colors_style (char const *value)
+{
+  if (value == NULL || STREQ (value, "auto"))
+    colors_style = AUTO;
+  else if (STREQ (value, "always"))
+    colors_style = ALWAYS;
+  else if (STREQ (value, "never"))
+    colors_style = NEVER;
+  else
+    try_help ("invalid color '%s'", value);
+}
+
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= file_name_concat (parent->file[0].name, name0, NULL);
+      cmp.file[1].name = free1
+	= file_name_concat (parent->file[1].name, name1, NULL);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (binary && ! isatty (STDIN_FILENO))
+		set_binary_mode (STDIN_FILENO, O_BINARY);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if ((no_dereference_symlinks
+		    ? lstat (cmp.file[f].name, &cmp.file[f].stat)
+		    : stat (cmp.file[f].name, &cmp.file[f].stat))
+		   != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : ((cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+		|| cmp.file[f].desc == ERRNO_ENCODE (EBADF))
+	       && ! parent
+	       && (cmp.file[1 - f].desc == UNOPENED
+		   || cmp.file[1 - f].desc == STDIN_FILENO))))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= find_dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare '-' to a directory");
+
+      if ((no_dereference_symlinks
+	   ? lstat (filename, &cmp.file[dir_arg].stat)
+	   : stat (filename, &cmp.file[dir_arg].stat))
+	  != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && !((S_ISREG (cmp.file[0].stat.st_mode)
+		     || S_ISLNK (cmp.file[0].stat.st_mode))
+		    && (S_ISREG (cmp.file[1].stat.st_mode)
+			|| S_ISLNK  (cmp.file[1].stat.st_mode)))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (S_ISLNK (cmp.file[0].stat.st_mode)
+	   || S_ISLNK (cmp.file[1].stat.st_mode))
+    {
+      /* We get here only if we use lstat(), not stat().  */
+      assert (no_dereference_symlinks);
+
+      if (S_ISLNK (cmp.file[0].stat.st_mode)
+	  && S_ISLNK (cmp.file[1].stat.st_mode))
+	{
+	  /* Compare the values of the symbolic links.  */
+	  char *link_value[2] = { NULL, NULL };
+
+	  for (f = 0; f < 2; f++)
+	    {
+	      link_value[f] = xreadlink (cmp.file[f].name);
+	      if (link_value[f] == NULL)
+		{
+		  perror_with_name (cmp.file[f].name);
+		  status = EXIT_TROUBLE;
+		  break;
+		}
+	    }
+	  if (status == EXIT_SUCCESS)
+	    {
+	      if ( ! STREQ (link_value[0], link_value[1]))
+		{
+		  message ("Symbolic links %s and %s differ\n",
+			   cmp.file[0].name, cmp.file[1].name);
+		  /* This is a difference.  */
+		  status = EXIT_FAILURE;
+		}
+	    }
+	  for (f = 0; f < 2; f++)
+	    free (link_value[f]);
+	}
+      else
+	{
+	  /* We have two files that are not to be compared, because
+	     one of them is a symbolic link and the other one is not.  */
+
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size
+	   && 0 < cmp.file[0].stat.st_size
+	   && 0 < cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/diffutils-3.0/src/diff.h b/diffutils-3.0/src/diff.h
new file mode 100644
index 0000000..03daaa4
--- /dev/null
+++ b/diffutils-3.0/src/diff.h
@@ -0,0 +1,423 @@
+/* Shared definitions for GNU DIFF
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include <regex.h>
+#include <stdio.h>
+#include <unlocked-io.h>
+
+/* What kind of changes a hunk contains.  */
+enum changes
+{
+  /* No changes: lines common to both files.  */
+  UNCHANGED,
+
+  /* Deletes only: lines taken from just the first file.  */
+  OLD,
+
+  /* Inserts only: lines taken from just the second file.  */
+  NEW,
+
+  /* Both deletes and inserts: a hunk containing both old and new lines.  */
+  CHANGED
+};
+
+/* When colors should be used in the output.  */
+enum colors_style
+{
+  /* Never output colors.  */
+  NEVER,
+
+  /* Output colors if the output is a terminal.  */
+  AUTO,
+
+  /* Always output colors.  */
+  ALWAYS,
+};
+
+/* Variables for command line options */
+
+#ifndef GDIFF_MAIN
+# define XTERN extern
+#else
+# define XTERN
+#endif
+
+enum output_style
+{
+  /* No output style specified.  */
+  OUTPUT_UNSPECIFIED,
+
+  /* Default output style.  */
+  OUTPUT_NORMAL,
+
+  /* Output the differences with lines of context before and after (-c).  */
+  OUTPUT_CONTEXT,
+
+  /* Output the differences in a unified context diff format (-u).  */
+  OUTPUT_UNIFIED,
+
+  /* Output the differences as commands suitable for 'ed' (-e).  */
+  OUTPUT_ED,
+
+  /* Output the diff as a forward ed script (-f).  */
+  OUTPUT_FORWARD_ED,
+
+  /* Like -f, but output a count of changed lines in each "command" (-n).  */
+  OUTPUT_RCS,
+
+  /* Output merged #ifdef'd file (-D).  */
+  OUTPUT_IFDEF,
+
+  /* Output sdiff style (-y).  */
+  OUTPUT_SDIFF
+};
+
+/* True for output styles that are robust,
+   i.e. can handle a file that ends in a non-newline.  */
+#define ROBUST_OUTPUT_STYLE(S) ((S) != OUTPUT_ED && (S) != OUTPUT_FORWARD_ED)
+
+XTERN enum output_style output_style;
+
+/* Define the current color context used to print a line.  */
+XTERN enum colors_style colors_style;
+
+/* Nonzero if output cannot be generated for identical files.  */
+XTERN bool no_diff_means_no_output;
+
+/* Number of lines of context to show in each set of diffs.
+   This is zero when context is not to be shown.  */
+XTERN lin context;
+
+/* Consider all files as text files (-a).
+   Don't interpret codes over 0177 as implying a "binary file".  */
+XTERN bool text;
+
+/* Number of lines to keep in identical prefix and suffix.  */
+XTERN lin horizon_lines;
+
+/* The significance of white space during comparisons.  */
+enum DIFF_white_space
+{
+  /* All white space is significant (the default).  */
+  IGNORE_NO_WHITE_SPACE,
+
+  /* Ignore changes due to tab expansion (-E).  */
+  IGNORE_TAB_EXPANSION,
+
+  /* Ignore changes in trailing horizontal white space (-Z).  */
+  IGNORE_TRAILING_SPACE,
+
+  /* IGNORE_TAB_EXPANSION and IGNORE_TRAILING_SPACE are a special case
+     because they are independent and can be ORed together, yielding
+     IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE.  */
+  IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE,
+
+  /* Ignore changes in horizontal white space (-b).  */
+  IGNORE_SPACE_CHANGE,
+
+  /* Ignore all horizontal white space (-w).  */
+  IGNORE_ALL_SPACE
+};
+XTERN enum DIFF_white_space ignore_white_space;
+
+/* Ignore changes that affect only blank lines (-B).  */
+XTERN bool ignore_blank_lines;
+
+/* Files can be compared byte-by-byte, as if they were binary.
+   This depends on various options.  */
+XTERN bool files_can_be_treated_as_binary;
+
+/* Ignore differences in case of letters (-i).  */
+XTERN bool ignore_case;
+
+/* Ignore differences in case of letters in file names.  */
+XTERN bool ignore_file_name_case;
+
+/* Act on symbolic links themselves rather than on their target
+   (--no-dereference).  */
+XTERN bool no_dereference_symlinks;
+
+/* File labels for '-c' output headers (--label).  */
+XTERN char *file_label[2];
+
+/* Regexp to identify function-header lines (-F).  */
+XTERN struct re_pattern_buffer function_regexp;
+
+/* Ignore changes that affect only lines matching this regexp (-I).  */
+XTERN struct re_pattern_buffer ignore_regexp;
+
+/* Say only whether files differ, not how (-q).  */
+XTERN bool brief;
+
+/* Expand tabs in the output so the text lines up properly
+   despite the characters added to the front of each line (-t).  */
+XTERN bool expand_tabs;
+
+/* Number of columns between tab stops.  */
+XTERN size_t tabsize;
+
+/* Use a tab in the output, rather than a space, before the text of an
+   input line, so as to keep the proper alignment in the input line
+   without changing the characters in it (-T).  */
+XTERN bool initial_tab;
+
+/* Do not output an initial space or tab before the text of an empty line.  */
+XTERN bool suppress_blank_empty;
+
+/* Remove trailing carriage returns from input.  */
+XTERN bool strip_trailing_cr;
+
+/* In directory comparison, specify file to start with (-S).
+   This is used for resuming an aborted comparison.
+   All file names less than this name are ignored.  */
+XTERN char const *starting_file;
+
+/* Pipe each file's output through pr (-l).  */
+XTERN bool paginate;
+
+/* Line group formats for unchanged, old, new, and changed groups.  */
+XTERN char const *group_format[CHANGED + 1];
+
+/* Line formats for unchanged, old, and new lines.  */
+XTERN char const *line_format[NEW + 1];
+
+/* If using OUTPUT_SDIFF print extra information to help the sdiff filter.  */
+XTERN bool sdiff_merge_assist;
+
+/* Tell OUTPUT_SDIFF to show only the left version of common lines.  */
+XTERN bool left_column;
+
+/* Tell OUTPUT_SDIFF to not show common lines.  */
+XTERN bool suppress_common_lines;
+
+/* The half line width and column 2 offset for OUTPUT_SDIFF.  */
+XTERN size_t sdiff_half_width;
+XTERN size_t sdiff_column2_offset;
+
+/* String containing all the command options diff received,
+   with spaces between and at the beginning but none at the end.
+   If there were no options given, this string is empty.  */
+XTERN char *switch_string;
+
+/* Use heuristics for better speed with large files with a small
+   density of changes.  */
+XTERN bool speed_large_files;
+
+/* Patterns that match file names to be excluded.  */
+XTERN struct exclude *excluded;
+
+/* Don't discard lines.  This makes things slower (sometimes much
+   slower) but will find a guaranteed minimal set of changes.  */
+XTERN bool minimal;
+
+/* The strftime format to use for time strings.  */
+XTERN char const *time_format;
+
+/* The result of comparison is an "edit script": a chain of 'struct change'.
+   Each 'struct change' represents one place where some lines are deleted
+   and some are inserted.
+
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+struct change
+{
+  struct change *link;		/* Previous or next edit command  */
+  lin inserted;			/* # lines of file 1 changed here.  */
+  lin deleted;			/* # lines of file 0 changed here.  */
+  lin line0;			/* Line number of 1st deleted line.  */
+  lin line1;			/* Line number of 1st inserted line.  */
+  bool ignore;			/* Flag used in context.c.  */
+};
+
+/* Structures that describe the input files.  */
+
+/* Data on one input file being compared.  */
+
+struct file_data {
+    int             desc;	/* File descriptor  */
+    char const      *name;	/* File name  */
+    struct stat     stat;	/* File status */
+
+    /* Buffer in which text of file is read.  */
+    word *buffer;
+
+    /* Allocated size of buffer, in bytes.  Always a multiple of
+       sizeof *buffer.  */
+    size_t bufsize;
+
+    /* Number of valid bytes now in the buffer.  */
+    size_t buffered;
+
+    /* Array of pointers to lines in the file.  */
+    char const **linbuf;
+
+    /* linbuf_base <= buffered_lines <= valid_lines <= alloc_lines.
+       linebuf[linbuf_base ... buffered_lines - 1] are possibly differing.
+       linebuf[linbuf_base ... valid_lines - 1] contain valid data.
+       linebuf[linbuf_base ... alloc_lines - 1] are allocated.  */
+    lin linbuf_base, buffered_lines, valid_lines, alloc_lines;
+
+    /* Pointer to end of prefix of this file to ignore when hashing.  */
+    char const *prefix_end;
+
+    /* Count of lines in the prefix.
+       There are this many lines in the file before linbuf[0].  */
+    lin prefix_lines;
+
+    /* Pointer to start of suffix of this file to ignore when hashing.  */
+    char const *suffix_begin;
+
+    /* Vector, indexed by line number, containing an equivalence code for
+       each line.  It is this vector that is actually compared with that
+       of another file to generate differences.  */
+    lin *equivs;
+
+    /* Vector, like the previous one except that
+       the elements for discarded lines have been squeezed out.  */
+    lin *undiscarded;
+
+    /* Vector mapping virtual line numbers (not counting discarded lines)
+       to real ones (counting those lines).  Both are origin-0.  */
+    lin *realindexes;
+
+    /* Total number of nondiscarded lines.  */
+    lin nondiscarded_lines;
+
+    /* Vector, indexed by real origin-0 line number,
+       containing 1 for a line that is an insertion or a deletion.
+       The results of comparison are stored here.  */
+    char *changed;
+
+    /* 1 if file ends in a line with no final newline.  */
+    bool missing_newline;
+
+    /* 1 if at end of file.  */
+    bool eof;
+
+    /* 1 more than the maximum equivalence value used for this or its
+       sibling file.  */
+    lin equiv_max;
+};
+
+/* The file buffer, considered as an array of bytes rather than
+   as an array of words.  */
+#define FILE_BUFFER(f) ((char *) (f)->buffer)
+
+/* Data on two input files being compared.  */
+
+struct comparison
+  {
+    struct file_data file[2];
+    struct comparison const *parent;  /* parent, if a recursive comparison */
+  };
+
+/* Describe the two files currently being compared.  */
+
+XTERN struct file_data files[2];
+
+/* Stdio stream to output diffs to.  */
+
+XTERN FILE *outfile;
+
+/* Declare various functions.  */
+
+/* analyze.c */
+extern int diff_2_files (struct comparison *);
+
+/* context.c */
+extern void print_context_header (struct file_data[], char const * const *, bool);
+extern void print_context_script (struct change *, bool);
+
+/* dir.c */
+extern int diff_dirs (struct comparison const *,
+                      int (*) (struct comparison const *,
+                               char const *, char const *));
+extern char *find_dir_file_pathname (char const *, char const *);
+
+/* ed.c */
+extern void print_ed_script (struct change *);
+extern void pr_forward_ed_script (struct change *);
+
+/* ifdef.c */
+extern void print_ifdef_script (struct change *);
+
+/* io.c */
+extern void file_block_read (struct file_data *, size_t);
+extern bool read_files (struct file_data[], bool);
+
+/* normal.c */
+extern void print_normal_script (struct change *);
+
+/* rcs.c */
+extern void print_rcs_script (struct change *);
+
+/* side.c */
+extern void print_sdiff_script (struct change *);
+
+/* util.c */
+extern char const change_letter[4];
+extern char const pr_program[];
+extern char *concat (char const *, char const *, char const *);
+extern bool lines_differ (char const *, char const *) _GL_ATTRIBUTE_PURE;
+extern lin translate_line_number (struct file_data const *, lin);
+extern struct change *find_change (struct change *);
+extern struct change *find_reverse_change (struct change *);
+extern void *zalloc (size_t);
+extern enum changes analyze_hunk (struct change *, lin *, lin *, lin *, lin *);
+extern void begin_output (void);
+extern void debug_script (struct change *);
+extern void fatal (char const *) __attribute__((noreturn));
+extern void finish_output (void);
+extern void message (char const *, char const *, char const *);
+extern void message5 (char const *, char const *, char const *,
+                      char const *, char const *);
+extern void output_1_line (char const *, char const *, char const *,
+                           char const *);
+extern void perror_with_name (char const *);
+extern void pfatal_with_name (char const *) __attribute__((noreturn));
+extern void print_1_line (char const *, char const * const *);
+extern void print_1_line_nl (char const *, char const * const *, bool);
+extern void print_message_queue (void);
+extern void print_number_range (char, struct file_data *, lin, lin);
+extern void print_script (struct change *, struct change * (*) (struct change *),
+                          void (*) (struct change *));
+extern void setup_output (char const *, char const *, bool);
+extern void translate_range (struct file_data const *, lin, lin,
+                             printint *, printint *);
+
+enum color_context
+{
+  HEADER_CONTEXT,
+  ADD_CONTEXT,
+  DELETE_CONTEXT,
+  RESET_CONTEXT,
+  LINE_NUMBER_CONTEXT,
+};
+
+XTERN bool presume_output_tty;
+
+extern void set_color_context (enum color_context color_context);
+extern void set_color_palette (char const *palette);
diff --git a/diffutils-3.0/src/diff3.c b/diffutils-3.0/src/diff3.c
new file mode 100644
index 0000000..ec414a9
--- /dev/null
+++ b/diffutils-3.0/src/diff3.c
@@ -0,0 +1,1790 @@
+/* GNU diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include "die.h"
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <system-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+#ifdef lint
+  struct diff_block *n2;	/* Used only when freeing.  */
+#endif
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include ':wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **, char **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+static void
+free_diff_block (struct diff_block *p)
+{
+#ifndef lint
+  (void)p;
+#else
+  while (p)
+    {
+      free (p->lines[0]);
+      free (p->lines[1]);
+      free (p->lengths[0]);
+      free (p->lengths[1]);
+      struct diff_block *next = p->n2;
+      free (p);
+      p = next;
+    }
+#endif
+}
+
+/* Copy each next pointer to n2, since make_3way_diff would clobber the former,
+   yet we will still need something to free these buffers.  */
+static void
+next_to_n2 (struct diff_block *p)
+{
+#ifndef lint
+  (void)p;
+#else
+  while (p)
+    p = p->n2 = p->next;
+#endif
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  FALLTHROUGH;
+	case 'E':
+	  flagging = true;
+	  FALLTHROUGH;
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  /* -AeExX3 without -m implies ed script.  */
+  edscript = incompat & ~(int) merge;
+
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("'-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (! STREQ (file[i], "-"))
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  die (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  char *b0, *b1;
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block, &b1);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block, &b0);
+
+  next_to_n2 (thread0);
+  next_to_n2 (thread1);
+
+  diff3 = make_3way_diff (thread0, thread1);
+
+  free_diff_block (thread0);
+  free_diff_block (thread1);
+
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  free (b0);
+  free (b1);
+  check_stdout ();
+  exit (conflicts_found);
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  die (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-A, --show-all              output all changes, bracketing conflicts"),
+  "",
+  N_("-e, --ed                    output ed script incorporating changes\n"
+     "                                from OLDFILE to YOURFILE into MYFILE"),
+  N_("-E, --show-overlap          like -e, but bracket conflicts"),
+  N_("-3, --easy-only             like -e, but incorporate only nonoverlapping changes"),
+  N_("-x, --overlap-only          like -e, but incorporate only overlapping changes"),
+  N_("-X                          like -x, but bracket conflicts"),
+  N_("-i                          append 'w' and 'q' commands to ed scripts"),
+  "",
+  N_("-m, --merge                 output actual merged file, according to\n"
+     "                                -A if no other options are given"),
+  "",
+  N_("-a, --text                  treat all files as text"),
+  N_("    --strip-trailing-cr     strip trailing carriage return on input"),
+  N_("-T, --initial-tab           make tabs line up by prepending a tab"),
+  N_("    --diff-program=PROGRAM  use PROGRAM to compare files"),
+  N_("-L, --label=LABEL           use LABEL instead of file name\n"
+     "                                (can be repeated up to three times)"),
+  "",
+  N_("    --help                  display this help and exit"),
+  N_("-v, --version               output version information and exit"),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+
+  fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  fputs (_("\n\
+The default output format is a somewhat human-readable representation of\n\
+the changes.\n\
+\n\
+The -e, -E, -x, -X (and corresponding long) options cause an ed script\n\
+to be output instead of the default.\n\
+\n\
+Finally, the -m (--merge) option causes diff3 to do the merge internally\n\
+and output the actual merged file.  For unusual input, this is more\n\
+robust than using ed.\n"), stdout);
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block,
+	      char **buf_to_free)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  *buf_to_free = diff_contents;
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char * _GL_ATTRIBUTE_PURE
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+  char const *argv[9];
+  char const **ap;
+#if HAVE_WORKING_FORK
+  int fds[2];
+  pid_t pid;
+#else
+  FILE *fpipe;
+  char *command;
+#endif
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+#if HAVE_WORKING_FORK
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = fork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  command = system_quote_argv (SCI_SYSTEM, (char **) argv);
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! HAVE_WORKING_FORK
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    die (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  printint llowt = lowt;
+	  printint lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%"pI"da\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%"pI"dc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%"pI"d,%"pI"dc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, printint start, printint num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%"pI"ds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%"pI"d,%"pI"ds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in 'output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      printint low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%"pI"da\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%"pI"da\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%"pI"dd\n", low0);
+	  else
+	    fprintf (outputfile, "%"pI"d,%"pI"dd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%"pI"da\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%"pI"dc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%"pI"d,%"pI"dc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  die (EXIT_TROUBLE, 0, "%s", _(msgid));
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  die (EXIT_TROUBLE, errno, "%s", string);
+}
diff --git a/diffutils-3.0/src/dir.c b/diffutils-3.0/src/dir.c
new file mode 100644
index 0000000..734603e
--- /dev/null
+++ b/diffutils-3.0/src/dir.c
@@ -0,0 +1,385 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2013, 2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <filenamecat.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the 'data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the 'names' table from the 'data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare strings in a locale-specific way, returning a value
+   compatible with strcmp.  */
+
+static int
+compare_collated (char const *name1, char const *name2)
+{
+  int r;
+  errno = 0;
+  if (ignore_file_name_case)
+    r = strcasecoll (name1, name2);
+  else
+    r = strcoll (name1, name2);
+  if (errno)
+    {
+      error (0, errno, _("cannot compare file names '%s' and '%s'"),
+	     name1, name2);
+      longjmp (failed_locale_specific_sorting, 1);
+    }
+  return r;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int diff = compare_collated (name1, name2);
+      if (diff || ignore_file_name_case)
+	return diff;
+    }
+  return file_name_cmp (name1, name2);
+}
+
+/* Compare names FILE1 and FILE2 when sorting a directory.
+   Prefer filtered comparison, breaking ties with file_name_cmp.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  char const *name1 = *f1;
+  char const *name2 = *f2;
+  if (locale_specific_sorting)
+    {
+      int diff = compare_collated (name1, name2);
+      if (diff)
+	return diff;
+    }
+  return file_name_cmp (name1, name2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If '-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+
+	  /* Prefer a file_name_cmp match if available.  This algorithm is
+	     O(N**2), where N is the number of names in a directory
+	     that compare_names says are all equal, but in practice N
+	     is so small it's not worth tuning.  */
+	  if (nameorder == 0 && ignore_file_name_case)
+	    {
+	      int raw_order = file_name_cmp (*names[0], *names[1]);
+	      if (raw_order != 0)
+		{
+		  int greater_side = raw_order < 0;
+		  int lesser_side = 1 - greater_side;
+		  char const **lesser = names[lesser_side];
+		  char const *greater_name = *names[greater_side];
+		  char const **p;
+
+		  for (p = lesser + 1;
+		       *p && compare_names (*p, greater_name) == 0;
+		       p++)
+		    {
+		      int c = file_name_cmp (*p, greater_name);
+		      if (0 <= c)
+			{
+			  if (c == 0)
+			    {
+			      memmove (lesser + 1, lesser,
+				       (char *) p - (char *) lesser);
+			      *lesser = greater_name;
+			    }
+			  break;
+			}
+		    }
+		}
+	    }
+
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool _GL_ATTRIBUTE_PURE
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
+
+/* Find a matching filename in a directory.  */
+
+char *
+find_dir_file_pathname (char const *dir, char const *file)
+{
+  /* The 'IF_LINT (volatile)' works around what appears to be a bug in
+     gcc 4.8.0 20120825; see
+     <http://lists.gnu.org/archive/html/bug-diffutils/2012-08/msg00007.html>.
+     */
+  char const * IF_LINT (volatile) match = file;
+
+  char *val;
+  struct dirdata dirdata;
+  dirdata.names = NULL;
+  dirdata.data = NULL;
+
+  if (ignore_file_name_case)
+    {
+      struct file_data filedata;
+      filedata.name = dir;
+      filedata.desc = 0;
+
+      if (dir_read (&filedata, &dirdata))
+	{
+	  locale_specific_sorting = true;
+	  if (setjmp (failed_locale_specific_sorting))
+	    match = file; /* longjmp may mess up MATCH.  */
+	  else
+	    {
+	      for (char const **p = dirdata.names; *p; p++)
+		if (compare_names (*p, file) == 0)
+		  {
+		    if (file_name_cmp (*p, file) == 0)
+		      {
+			match = *p;
+			break;
+		      }
+		    if (match == file)
+		      match = *p;
+		  }
+	    }
+	}
+    }
+
+  val = file_name_concat (dir, match, NULL);
+  free (dirdata.names);
+  free (dirdata.data);
+  return val;
+}
diff --git a/diffutils-3.0/src/ed.c b/diffutils-3.0/src/ed.c
new file mode 100644
index 0000000..73771a2
--- /dev/null
+++ b/diffutils-3.0/src/ed.c
@@ -0,0 +1,177 @@
+/* Output routines for ed-script format.
+
+   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_ed_hunk (struct change *);
+static void print_rcs_hunk (struct change *);
+static void pr_forward_ed_hunk (struct change *);
+
+/* Print our script as ed commands.  */
+
+void
+print_ed_script (struct change *script)
+{
+  print_script (script, find_reverse_change, print_ed_hunk);
+}
+
+/* Print a hunk of an ed diff */
+
+static void
+print_ed_hunk (struct change *hunk)
+{
+  lin f0, l0, f1, l1;
+  enum changes changes;
+
+#ifdef DEBUG
+  debug_script (hunk);
+#endif
+
+  /* Determine range of line numbers involved in each file.  */
+  changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], f0, l0);
+  fputc (change_letter[changes], outfile);
+  fputc ('\n', outfile);
+
+  /* Print new/changed lines from second file, if needed */
+  if (changes != OLD)
+    {
+      lin i;
+      bool insert_mode = true;
+
+      for (i = f1; i <= l1; i++)
+	{
+	  if (!insert_mode)
+	    {
+	      fputs ("a\n", outfile);
+	      insert_mode = true;
+	    }
+	  if (files[1].linbuf[i][0] == '.' && files[1].linbuf[i][1] == '\n')
+	    {
+	      /* The file's line is just a dot, and it would exit
+		 insert mode.  Precede the dot with another dot, exit
+		 insert mode and remove the extra dot.  */
+	      fputs ("..\n.\ns/.//\n", outfile);
+	      insert_mode = false;
+	    }
+	  else
+	    print_1_line ("", &files[1].linbuf[i]);
+	}
+
+      if (insert_mode)
+	fputs (".\n", outfile);
+    }
+}
+
+/* Print change script in the style of ed commands,
+   but print the changes in the order they appear in the input files,
+   which means that the commands are not truly useful with ed.
+   Because of the issue with lines containing just a dot, the output
+   is not even parseable.  */
+
+void
+pr_forward_ed_script (struct change *script)
+{
+  print_script (script, find_change, pr_forward_ed_hunk);
+}
+
+static void
+pr_forward_ed_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  fputc (change_letter[changes], outfile);
+  print_number_range (' ', files, f0, l0);
+  fputc ('\n', outfile);
+
+  /* If deletion only, print just the number range.  */
+
+  if (changes == OLD)
+    return;
+
+  /* For insertion (with or without deletion), print the number range
+     and the lines from file 2.  */
+
+  for (i = f1; i <= l1; i++)
+    print_1_line ("", &files[1].linbuf[i]);
+
+  fputs (".\n", outfile);
+}
+
+/* Print in a format somewhat like ed commands
+   except that each insert command states the number of lines it inserts.
+   This format is used for RCS.  */
+
+void
+print_rcs_script (struct change *script)
+{
+  print_script (script, find_change, print_rcs_hunk);
+}
+
+/* Print a hunk of an RCS diff */
+
+static void
+print_rcs_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+  printint tf0, tl0, tf1, tl1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  translate_range (&files[0], f0, l0, &tf0, &tl0);
+
+  if (changes & OLD)
+    {
+      /* For deletion, print just the starting line number from file 0
+	 and the number of lines deleted.  */
+      fprintf (outfile, "d%"pI"d %"pI"d\n", tf0,
+	       tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+    }
+
+  if (changes & NEW)
+    {
+      /* Take last-line-number from file 0 and # lines from file 1.  */
+      translate_range (&files[1], f1, l1, &tf1, &tl1);
+      fprintf (outfile, "a%"pI"d %"pI"d\n", tl0,
+	       tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+
+      /* Print the inserted lines.  */
+      for (i = f1; i <= l1; i++)
+	print_1_line ("", &files[1].linbuf[i]);
+    }
+}
diff --git a/diffutils-3.0/src/ifdef.c b/diffutils-3.0/src/ifdef.c
new file mode 100644
index 0000000..0ecc2c0
--- /dev/null
+++ b/diffutils-3.0/src/ifdef.c
@@ -0,0 +1,431 @@
+/* #ifdef-format output routines for GNU DIFF.
+
+   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2013, 2015-2018
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <xalloc.h>
+
+struct group
+{
+  struct file_data const *file;
+  lin from, upto; /* start and limit lines for this group of lines */
+};
+
+static char const *format_group (FILE *, char const *, char,
+				 struct group const *);
+static char const *do_printf_spec (FILE *, char const *,
+				   struct file_data const *, lin,
+				   struct group const *);
+static char const *scan_char_literal (char const *, char *);
+static lin groups_letter_value (struct group const *, char);
+static void format_ifdef (char const *, lin, lin, lin, lin);
+static void print_ifdef_hunk (struct change *);
+static void print_ifdef_lines (FILE *, char const *, struct group const *);
+
+static lin next_line0;
+static lin next_line1;
+
+/* Print the edit-script SCRIPT as a merged #ifdef file.  */
+
+void
+print_ifdef_script (struct change *script)
+{
+  next_line0 = next_line1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_ifdef_hunk);
+  if (next_line0 < files[0].valid_lines
+      || next_line1 < files[1].valid_lines)
+    {
+      begin_output ();
+      format_ifdef (group_format[UNCHANGED],
+		    next_line0, files[0].valid_lines,
+		    next_line1, files[1].valid_lines);
+    }
+}
+
+/* Print a hunk of an ifdef diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_ifdef_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print lines up to this change.  */
+  if (next_line0 < first0 || next_line1 < first1)
+    format_ifdef (group_format[UNCHANGED],
+		  next_line0, first0,
+		  next_line1, first1);
+
+  /* Print this change.  */
+  next_line0 = last0 + 1;
+  next_line1 = last1 + 1;
+  format_ifdef (group_format[changes],
+		first0, next_line0,
+		first1, next_line1);
+}
+
+/* Print a set of lines according to FORMAT.
+   Lines BEG0 up to END0 are from the first file;
+   lines BEG1 up to END1 are from the second file.  */
+
+static void
+format_ifdef (char const *format, lin beg0, lin end0, lin beg1, lin end1)
+{
+  struct group groups[2];
+
+  groups[0].file = &files[0];
+  groups[0].from = beg0;
+  groups[0].upto = end0;
+  groups[1].file = &files[1];
+  groups[1].from = beg1;
+  groups[1].upto = end1;
+  format_group (outfile, format, 0, groups);
+}
+
+/* Print to file OUT a set of lines according to FORMAT.
+   The format ends at the first free instance of ENDCHAR.
+   Yield the address of the terminating character.
+   GROUPS specifies which lines to print.
+   If OUT is zero, do not actually print anything; just scan the format.  */
+
+static char const *
+format_group (register FILE *out, char const *format, char endchar,
+	      struct group const *groups)
+{
+  register char c;
+  register char const *f = format;
+
+  while ((c = *f) != endchar && c != 0)
+    {
+      char const *f1 = ++f;
+      if (c == '%')
+	switch ((c = *f++))
+	  {
+	  case '%':
+	    break;
+
+	  case '(':
+	    /* Print if-then-else format e.g. '%(n=1?thenpart:elsepart)'.  */
+	    {
+	      int i;
+	      uintmax_t value[2];
+	      FILE *thenout, *elseout;
+
+	      for (i = 0; i < 2; i++)
+		{
+		  if (ISDIGIT (*f))
+		    {
+		      char *fend;
+		      errno = 0;
+		      value[i] = strtoumax (f, &fend, 10);
+		      if (errno)
+			goto bad_format;
+		      f = fend;
+		    }
+		  else
+		    {
+		      value[i] = groups_letter_value (groups, *f);
+		      if (value[i] == -1)
+			goto bad_format;
+		      f++;
+		    }
+		  if (*f++ != "=?"[i])
+		    goto bad_format;
+		}
+	      if (value[0] == value[1])
+		thenout = out, elseout = 0;
+	      else
+		thenout = 0, elseout = out;
+	      f = format_group (thenout, f, ':', groups);
+	      if (*f)
+		{
+		  f = format_group (elseout, f + 1, ')', groups);
+		  if (*f)
+		    f++;
+		}
+	    }
+	    continue;
+
+	  case '<':
+	    /* Print lines deleted from first file.  */
+	    print_ifdef_lines (out, line_format[OLD], &groups[0]);
+	    continue;
+
+	  case '=':
+	    /* Print common lines.  */
+	    print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
+	    continue;
+
+	  case '>':
+	    /* Print lines inserted from second file.  */
+	    print_ifdef_lines (out, line_format[NEW], &groups[1]);
+	    continue;
+
+	  default:
+	    f = do_printf_spec (out, f - 2, 0, 0, groups);
+	    if (f)
+	      continue;
+	    /* Fall through. */
+	  bad_format:
+	    c = '%';
+	    f = f1;
+	    break;
+	  }
+
+      if (out)
+	putc (c, out);
+    }
+
+  return f;
+}
+
+/* For the line group pair G, return the number corresponding to LETTER.
+   Return -1 if LETTER is not a group format letter.  */
+static lin
+groups_letter_value (struct group const *g, char letter)
+{
+  switch (letter)
+    {
+    case 'E': letter = 'e'; g++; break;
+    case 'F': letter = 'f'; g++; break;
+    case 'L': letter = 'l'; g++; break;
+    case 'M': letter = 'm'; g++; break;
+    case 'N': letter = 'n'; g++; break;
+    }
+
+  switch (letter)
+    {
+      case 'e': return translate_line_number (g->file, g->from) - 1;
+      case 'f': return translate_line_number (g->file, g->from);
+      case 'l': return translate_line_number (g->file, g->upto) - 1;
+      case 'm': return translate_line_number (g->file, g->upto);
+      case 'n': return g->upto - g->from;
+      default: return -1;
+    }
+}
+
+/* Print to file OUT, using FORMAT to print the line group GROUP.
+   But do nothing if OUT is zero.  */
+static void
+print_ifdef_lines (register FILE *out, char const *format,
+		   struct group const *group)
+{
+  struct file_data const *file = group->file;
+  char const * const *linbuf = file->linbuf;
+  lin from = group->from, upto = group->upto;
+
+  if (!out)
+    return;
+
+  /* If possible, use a single fwrite; it's faster.  */
+  if (!expand_tabs && format[0] == '%')
+    {
+      if (format[1] == 'l' && format[2] == '\n' && !format[3] && from < upto)
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
+		  out);
+	  return;
+	}
+      if (format[1] == 'L' && !format[2])
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] -  linbuf[from], out);
+	  return;
+	}
+    }
+
+  for (;  from < upto;  from++)
+    {
+      register char c;
+      register char const *f = format;
+
+      while ((c = *f++) != 0)
+	{
+	  char const *f1 = f;
+	  if (c == '%')
+	    switch ((c = *f++))
+	      {
+	      case '%':
+		break;
+
+	      case 'l':
+		output_1_line (linbuf[from],
+			       (linbuf[from + 1]
+				- (linbuf[from + 1][-1] == '\n')),
+			       0, 0);
+		continue;
+
+	      case 'L':
+		output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
+		continue;
+
+	      default:
+		f = do_printf_spec (out, f - 2, file, from, 0);
+		if (f)
+		  continue;
+		c = '%';
+		f = f1;
+		break;
+	      }
+
+	  putc (c, out);
+	}
+    }
+}
+
+static char const *
+do_printf_spec (FILE *out, char const *spec,
+		struct file_data const *file, lin n,
+		struct group const *groups)
+{
+  char const *f = spec;
+  char c;
+  char c1;
+
+  /* Scan printf-style SPEC of the form %[-'0]*[0-9]*(.[0-9]*)?[cdoxX].  */
+  /* assert (*f == '%'); */
+  f++;
+  while ((c = *f++) == '-' || c == '\'' || c == '0')
+    continue;
+  while (ISDIGIT (c))
+    c = *f++;
+  if (c == '.')
+    while (ISDIGIT (c = *f++))
+      continue;
+  c1 = *f++;
+
+  switch (c)
+    {
+    case 'c':
+      if (c1 != '\'')
+	return 0;
+      else
+	{
+	  char value IF_LINT (= 0);
+	  f = scan_char_literal (f, &value);
+	  if (!f)
+	    return 0;
+	  if (out)
+	    putc (value, out);
+	}
+      break;
+
+    case 'd': case 'o': case 'x': case 'X':
+      {
+	lin value;
+
+	if (file)
+	  {
+	    if (c1 != 'n')
+	      return 0;
+	    value = translate_line_number (file, n);
+	  }
+	else
+	  {
+	    value = groups_letter_value (groups, c1);
+	    if (value < 0)
+	      return 0;
+	  }
+
+	if (out)
+	  {
+	    /* For example, if the spec is "%3xn" and pI is "l", use the printf
+	       format spec "%3lx".  Here the spec prefix is "%3".  */
+	    printint print_value = value;
+	    size_t spec_prefix_len = f - spec - 2;
+	    size_t pI_len = sizeof pI - 1;
+#if 0
+	    char format[spec_prefix_len + pI_len + 2];
+#else
+	    char *format = xmalloc (spec_prefix_len + pI_len + 2);
+#endif
+	    char *p = format + spec_prefix_len + pI_len;
+	    memcpy (format, spec, spec_prefix_len);
+	    memcpy (format + spec_prefix_len, pI, pI_len);
+	    *p++ = c;
+	    *p = '\0';
+	    fprintf (out, format, print_value);
+#if ! HAVE_C_VARARRAYS
+	    free (format);
+#endif
+	  }
+      }
+      break;
+
+    default:
+      return 0;
+    }
+
+  return f;
+}
+
+/* Scan the character literal represented in the string LIT; LIT points just
+   after the initial apostrophe.  Put the literal's value into *VALPTR.
+   Yield the address of the first character after the closing apostrophe,
+   or a null pointer if the literal is ill-formed.  */
+static char const *
+scan_char_literal (char const *lit, char *valptr)
+{
+  register char const *p = lit;
+  char value;
+  ptrdiff_t digits;
+  char c = *p++;
+
+  switch (c)
+    {
+      case 0:
+      case '\'':
+	return NULL;
+
+      case '\\':
+	value = 0;
+	while ((c = *p++) != '\'')
+	  {
+	    unsigned int digit = c - '0';
+	    if (8 <= digit)
+	      return NULL;
+	    value = 8 * value + digit;
+	  }
+	digits = p - lit - 2;
+	if (! (1 <= digits && digits <= 3))
+	  return NULL;
+	break;
+
+      default:
+	value = c;
+	if (*p++ != '\'')
+	  return NULL;
+	break;
+    }
+
+  *valptr = value;
+  return p;
+}
diff --git a/diffutils-3.0/src/io.c b/diffutils-3.0/src/io.c
new file mode 100644
index 0000000..fb86392
--- /dev/null
+++ b/diffutils-3.0/src/io.c
@@ -0,0 +1,830 @@
+/* File I/O for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <binary-io.h>
+#include <cmpbuf.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* Rotate an unsigned value to the left.  */
+#define ROL(v, n) ((v) << (n) | (v) >> (sizeof (v) * CHAR_BIT - (n)))
+
+/* Given a hash value and a new character, return a new hash value.  */
+#define HASH(h, c) ((c) + ROL (h, 7))
+
+/* The type of a hash value.  */
+typedef size_t hash_value;
+verify (! TYPE_SIGNED (hash_value));
+
+/* Lines are put into equivalence classes of lines that match in lines_differ.
+   Each equivalence class is represented by one of these structures,
+   but only while the classes are being computed.
+   Afterward, each class is represented by a number.  */
+struct equivclass
+{
+  lin next;		/* Next item in this bucket.  */
+  hash_value hash;	/* Hash of lines in this class.  */
+  char const *line;	/* A line that fits this class.  */
+  size_t length;	/* That line's length, not counting its newline.  */
+};
+
+/* Hash-table: array of buckets, each being a chain of equivalence classes.
+   buckets[-1] is reserved for incomplete lines.  */
+static lin *buckets;
+
+/* Number of buckets in the hash table array, not counting buckets[-1].  */
+static size_t nbuckets;
+
+/* Array in which the equivalence classes are allocated.
+   The bucket-chains go through the elements in this array.
+   The number of an equivalence class is its index in this array.  */
+static struct equivclass *equivs;
+
+/* Index of first free element in the array 'equivs'.  */
+static lin equivs_index;
+
+/* Number of elements allocated in the array 'equivs'.  */
+static lin equivs_alloc;
+
+/* Read a block of data into a file buffer, checking for EOF and error.  */
+
+void
+file_block_read (struct file_data *current, size_t size)
+{
+  if (size && ! current->eof)
+    {
+      size_t s = block_read (current->desc,
+			     FILE_BUFFER (current) + current->buffered, size);
+      if (s == SIZE_MAX)
+	pfatal_with_name (current->name);
+      current->buffered += s;
+      current->eof = s < size;
+    }
+}
+
+/* Check for binary files and compare them for exact identity.  */
+
+/* Return 1 if BUF contains a non text character.
+   SIZE is the number of characters in BUF.  */
+
+#define binary_file_p(buf, size) (memchr (buf, 0, size) != 0)
+
+/* Get ready to read the current file.
+   Return nonzero if SKIP_TEST is zero,
+   and if it appears to be a binary file.  */
+
+static bool
+sip (struct file_data *current, bool skip_test)
+{
+  /* If we have a nonexistent file at this stage, treat it as empty.  */
+  if (current->desc < 0)
+    {
+      /* Leave room for a sentinel.  */
+      current->bufsize = sizeof (word);
+      current->buffer = xmalloc (current->bufsize);
+    }
+  else
+    {
+      current->bufsize = buffer_lcm (sizeof (word),
+				     STAT_BLOCKSIZE (current->stat),
+				     PTRDIFF_MAX - 2 * sizeof (word));
+      current->buffer = xmalloc (current->bufsize);
+
+#ifdef __KLIBC__
+      /* Skip test if seek is not possible */
+      skip_test = skip_test
+		  || (lseek (current->desc, 0, SEEK_CUR) < 0
+		      && errno == ESPIPE);
+#endif
+
+      if (! skip_test)
+	{
+	  /* Check first part of file to see if it's a binary file.  */
+
+	  int prev_mode = set_binary_mode (current->desc, O_BINARY);
+	  off_t buffered;
+	  file_block_read (current, current->bufsize);
+	  buffered = current->buffered;
+
+	  if (prev_mode != O_BINARY)
+	    {
+	      /* Revert to text mode and seek back to the start to reread
+		 the file.  Use relative seek, since file descriptors
+		 like stdin might not start at offset zero.  */
+	      if (lseek (current->desc, - buffered, SEEK_CUR) < 0)
+		pfatal_with_name (current->name);
+	      set_binary_mode (current->desc, prev_mode);
+	      current->buffered = 0;
+	      current->eof = false;
+	    }
+
+	  return binary_file_p (current->buffer, buffered);
+	}
+    }
+
+  current->buffered = 0;
+  current->eof = false;
+  return false;
+}
+
+/* Slurp the rest of the current file completely into memory.  */
+
+static void
+slurp (struct file_data *current)
+{
+  size_t cc;
+
+  if (current->desc < 0)
+    {
+      /* The file is nonexistent.  */
+      return;
+    }
+
+  if (S_ISREG (current->stat.st_mode))
+    {
+      /* It's a regular file; slurp in the rest all at once.  */
+
+      /* Get the size out of the stat block.
+	 Allocate just enough room for appended newline plus word sentinel,
+	 plus word-alignment since we want the buffer word-aligned.  */
+      size_t file_size = current->stat.st_size;
+      cc = file_size + 2 * sizeof (word) - file_size % sizeof (word);
+      if (file_size != current->stat.st_size || cc < file_size
+	  || PTRDIFF_MAX <= cc)
+	xalloc_die ();
+
+      if (current->bufsize < cc)
+	{
+	  current->bufsize = cc;
+	  current->buffer = xrealloc (current->buffer, cc);
+	}
+
+      /* Try to read at least 1 more byte than the size indicates, to
+	 detect whether the file is growing.  This is a nicety for
+	 users who run 'diff' on files while they are changing.  */
+
+      if (current->buffered <= file_size)
+	{
+	  file_block_read (current, file_size + 1 - current->buffered);
+	  if (current->buffered <= file_size)
+	    return;
+	}
+    }
+
+  /* It's not a regular file, or it's a growing regular file; read it,
+     growing the buffer as needed.  */
+
+  file_block_read (current, current->bufsize - current->buffered);
+
+  if (current->buffered)
+    {
+      while (current->buffered == current->bufsize)
+	{
+	  if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
+	    xalloc_die ();
+	  current->bufsize *= 2;
+	  current->buffer = xrealloc (current->buffer, current->bufsize);
+	  file_block_read (current, current->bufsize - current->buffered);
+	}
+
+      /* Allocate just enough room for appended newline plus word
+	 sentinel, plus word-alignment.  */
+      cc = current->buffered + 2 * sizeof (word);
+      current->bufsize = cc - cc % sizeof (word);
+      current->buffer = xrealloc (current->buffer, current->bufsize);
+    }
+}
+
+/* Split the file into lines, simultaneously computing the equivalence
+   class for each line.  */
+
+static void
+find_and_hash_each_line (struct file_data *current)
+{
+  char const *p = current->prefix_end;
+  lin i, *bucket;
+  size_t length;
+
+  /* Cache often-used quantities in local variables to help the compiler.  */
+  char const **linbuf = current->linbuf;
+  lin alloc_lines = current->alloc_lines;
+  lin line = 0;
+  lin linbuf_base = current->linbuf_base;
+  lin *cureqs = xmalloc (alloc_lines * sizeof *cureqs);
+  struct equivclass *eqs = equivs;
+  lin eqs_index = equivs_index;
+  lin eqs_alloc = equivs_alloc;
+  char const *suffix_begin = current->suffix_begin;
+  char const *bufend = FILE_BUFFER (current) + current->buffered;
+  bool ig_case = ignore_case;
+  enum DIFF_white_space ig_white_space = ignore_white_space;
+  bool diff_length_compare_anyway =
+    ig_white_space != IGNORE_NO_WHITE_SPACE;
+  bool same_length_diff_contents_compare_anyway =
+    diff_length_compare_anyway | ig_case;
+
+  while (p < suffix_begin)
+    {
+      char const *ip = p;
+      hash_value h = 0;
+      unsigned char c;
+
+      /* Hash this line until we find a newline.  */
+      switch (ig_white_space)
+	{
+	case IGNORE_ALL_SPACE:
+	  while ((c = *p++) != '\n')
+	    if (! isspace (c))
+	      h = HASH (h, ig_case ? tolower (c) : c);
+	  break;
+
+	case IGNORE_SPACE_CHANGE:
+	  while ((c = *p++) != '\n')
+	    {
+	      if (isspace (c))
+		{
+		  do
+		    if ((c = *p++) == '\n')
+		      goto hashing_done;
+		  while (isspace (c));
+
+		  h = HASH (h, ' ');
+		}
+
+	      /* C is now the first non-space.  */
+	      h = HASH (h, ig_case ? tolower (c) : c);
+	    }
+	  break;
+
+	case IGNORE_TAB_EXPANSION:
+	case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
+	case IGNORE_TRAILING_SPACE:
+	  {
+	    size_t column = 0;
+	    while ((c = *p++) != '\n')
+	      {
+		if (ig_white_space & IGNORE_TRAILING_SPACE
+		    && isspace (c))
+		  {
+		    char const *p1 = p;
+		    unsigned char c1;
+		    do
+		      if ((c1 = *p1++) == '\n')
+			{
+			  p = p1;
+			  goto hashing_done;
+			}
+		    while (isspace (c1));
+		  }
+
+		size_t repetitions = 1;
+
+		if (ig_white_space & IGNORE_TAB_EXPANSION)
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      column++;
+		      break;
+		    }
+
+		if (ig_case)
+		  c = tolower (c);
+
+		do
+		  h = HASH (h, c);
+		while (--repetitions != 0);
+	      }
+	  }
+	  break;
+
+	default:
+	  if (ig_case)
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, tolower (c));
+	  else
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, c);
+	  break;
+	}
+
+   hashing_done:;
+
+      bucket = &buckets[h % nbuckets];
+      length = p - ip - 1;
+
+      if (p == bufend
+	  && current->missing_newline
+	  && ROBUST_OUTPUT_STYLE (output_style))
+	{
+	  /* The last line is incomplete and we do not silently
+	     complete lines.  If the line cannot compare equal to any
+	     complete line, put it into buckets[-1] so that it can
+	     compare equal only to the other file's incomplete line
+	     (if one exists).  */
+	  if (ig_white_space < IGNORE_TRAILING_SPACE)
+	    bucket = &buckets[-1];
+	}
+
+      for (i = *bucket;  ;  i = eqs[i].next)
+	if (!i)
+	  {
+	    /* Create a new equivalence class in this bucket.  */
+	    i = eqs_index++;
+	    if (i == eqs_alloc)
+	      {
+		if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
+		  xalloc_die ();
+		eqs_alloc *= 2;
+		eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
+	      }
+	    eqs[i].next = *bucket;
+	    eqs[i].hash = h;
+	    eqs[i].line = ip;
+	    eqs[i].length = length;
+	    *bucket = i;
+	    break;
+	  }
+	else if (eqs[i].hash == h)
+	  {
+	    char const *eqline = eqs[i].line;
+
+	    /* Reuse existing class if lines_differ reports the lines
+               equal.  */
+	    if (eqs[i].length == length)
+	      {
+		/* Reuse existing equivalence class if the lines are identical.
+		   This detects the common case of exact identity
+		   faster than lines_differ would.  */
+		if (memcmp (eqline, ip, length) == 0)
+		  break;
+		if (!same_length_diff_contents_compare_anyway)
+		  continue;
+	      }
+	    else if (!diff_length_compare_anyway)
+	      continue;
+
+	    if (! lines_differ (eqline, ip))
+	      break;
+	  }
+
+      /* Maybe increase the size of the line table.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = ip;
+      cureqs[line] = i;
+      ++line;
+    }
+
+  current->buffered_lines = line;
+
+  for (i = 0;  ;  i++)
+    {
+      /* Record the line start for lines in the suffix that we care about.
+	 Record one more line start than lines,
+	 so that we can compute the length of any buffered line.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = p;
+
+      if (p == bufend)
+	{
+	  /* If the last line is incomplete and we do not silently
+	     complete lines, don't count its appended newline.  */
+	  if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
+	    linbuf[line]--;
+	  break;
+	}
+
+      if (context <= i && no_diff_means_no_output)
+	break;
+
+      line++;
+
+      while (*p++ != '\n')
+	continue;
+    }
+
+  /* Done with cache in local variables.  */
+  current->linbuf = linbuf;
+  current->valid_lines = line;
+  current->alloc_lines = alloc_lines;
+  current->equivs = cureqs;
+  equivs = eqs;
+  equivs_alloc = eqs_alloc;
+  equivs_index = eqs_index;
+}
+
+/* Prepare the text.  Make sure the text end is initialized.
+   Make sure text ends in a newline,
+   but remember that we had to add one.
+   Strip trailing CRs, if that was requested.  */
+
+static void
+prepare_text (struct file_data *current)
+{
+  size_t buffered = current->buffered;
+  char *p = FILE_BUFFER (current);
+
+  if (buffered == 0 || p[buffered - 1] == '\n')
+    current->missing_newline = false;
+  else
+    {
+      p[buffered++] = '\n';
+      current->missing_newline = true;
+    }
+
+  if (!p)
+    return;
+
+  /* Don't use uninitialized storage when planting or using sentinels.  */
+  memset (p + buffered, 0, sizeof (word));
+
+  if (strip_trailing_cr)
+    {
+      char *dst;
+      char *srclim = p + buffered;
+      *srclim = '\r';
+      dst = rawmemchr (p, '\r');
+
+      if (dst != srclim)
+	{
+	  char const *src = dst;
+	  do
+	    {
+	      *dst = *src++;
+	      dst += ! (*dst == '\r' && *src == '\n');
+	    }
+	  while (src < srclim);
+
+	  buffered -= src - dst;
+	}
+    }
+
+  current->buffered = buffered;
+}
+
+/* We have found N lines in a buffer of size S; guess the
+   proportionate number of lines that will be found in a buffer of
+   size T.  However, do not guess a number of lines so large that the
+   resulting line table might cause overflow in size calculations.  */
+static lin
+guess_lines (lin n, size_t s, size_t t)
+{
+  size_t guessed_bytes_per_line = n < 10 ? 32 : s / (n - 1);
+  lin guessed_lines = MAX (1, t / guessed_bytes_per_line);
+  return MIN (guessed_lines, PTRDIFF_MAX / (2 * sizeof (char *) + 1) - 5) + 5;
+}
+
+/* Given a vector of two file_data objects, find the identical
+   prefixes and suffixes of each object.  */
+
+static void
+find_identical_ends (struct file_data filevec[])
+{
+  word *w0, *w1;
+  char *p0, *p1, *buffer0, *buffer1;
+  char const *end0, *beg0;
+  char const **linbuf0, **linbuf1;
+  lin i, lines;
+  size_t n0, n1;
+  lin alloc_lines0, alloc_lines1;
+  bool prefix_needed;
+  lin buffered_prefix, prefix_count, prefix_mask;
+  lin middle_guess, suffix_guess;
+
+  slurp (&filevec[0]);
+  prepare_text (&filevec[0]);
+  if (filevec[0].desc != filevec[1].desc)
+    {
+      slurp (&filevec[1]);
+      prepare_text (&filevec[1]);
+    }
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+      filevec[1].missing_newline = filevec[0].missing_newline;
+    }
+
+  /* Find identical prefix.  */
+
+  w0 = filevec[0].buffer;
+  w1 = filevec[1].buffer;
+  p0 = buffer0 = (char *) w0;
+  p1 = buffer1 = (char *) w1;
+  n0 = filevec[0].buffered;
+  n1 = filevec[1].buffered;
+
+  if (p0 == p1)
+    /* The buffers are the same; sentinels won't work.  */
+    p0 = p1 += n1;
+  else
+    {
+      /* Insert end sentinels, in this case characters that are guaranteed
+	 to make the equality test false, and thus terminate the loop.  */
+
+      if (n0 < n1)
+	p0[n0] = ~p1[n0];
+      else
+	p1[n1] = ~p0[n1];
+
+      /* Loop until first mismatch, or to the sentinel characters.  */
+
+      /* Compare a word at a time for speed.  */
+      while (*w0 == *w1)
+	w0++, w1++;
+
+      /* Do the last few bytes of comparison a byte at a time.  */
+      p0 = (char *) w0;
+      p1 = (char *) w1;
+      while (*p0 == *p1)
+	p0++, p1++;
+
+      /* Don't mistakenly count missing newline as part of prefix.  */
+      if (ROBUST_OUTPUT_STYLE (output_style)
+	  && ((buffer0 + n0 - filevec[0].missing_newline < p0)
+	      !=
+	      (buffer1 + n1 - filevec[1].missing_newline < p1)))
+	p0--, p1--;
+    }
+
+  /* Now P0 and P1 point at the first nonmatching characters.  */
+
+  /* Skip back to last line-beginning in the prefix,
+     and then discard up to HORIZON_LINES lines from the prefix.  */
+  i = horizon_lines;
+  while (p0 != buffer0 && (p0[-1] != '\n' || i--))
+    p0--, p1--;
+
+  /* Record the prefix.  */
+  filevec[0].prefix_end = p0;
+  filevec[1].prefix_end = p1;
+
+  /* Find identical suffix.  */
+
+  /* P0 and P1 point beyond the last chars not yet compared.  */
+  p0 = buffer0 + n0;
+  p1 = buffer1 + n1;
+
+  if (! ROBUST_OUTPUT_STYLE (output_style)
+      || filevec[0].missing_newline == filevec[1].missing_newline)
+    {
+      end0 = p0;	/* Addr of last char in file 0.  */
+
+      /* Get value of P0 at which we should stop scanning backward:
+	 this is when either P0 or P1 points just past the last char
+	 of the identical prefix.  */
+      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);
+
+      /* Scan back until chars don't match or we reach that point.  */
+      while (p0 != beg0)
+	if (*--p0 != *--p1)
+	  {
+	    /* Point at the first char of the matching suffix.  */
+	    ++p0, ++p1;
+	    beg0 = p0;
+	    break;
+	  }
+
+      /* Are we at a line-beginning in both files?  If not, add the rest of
+	 this line to the main body.  Discard up to HORIZON_LINES lines from
+	 the identical suffix.  Also, discard one extra line,
+	 because shift_boundaries may need it.  */
+      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n')
+			    &&
+			    (buffer1 == p1 || p1[-1] == '\n'));
+      while (i-- && p0 != end0)
+	while (*p0++ != '\n')
+	  continue;
+
+      p1 += p0 - beg0;
+    }
+
+  /* Record the suffix.  */
+  filevec[0].suffix_begin = p0;
+  filevec[1].suffix_begin = p1;
+
+  /* Calculate number of lines of prefix to save.
+
+     prefix_count == 0 means save the whole prefix;
+     we need this for options like -D that output the whole file,
+     or for enormous contexts (to avoid worrying about arithmetic overflow).
+     We also need it for options like -F that output some preceding line;
+     at least we will need to find the last few lines,
+     but since we don't know how many, it's easiest to find them all.
+
+     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
+     of the line buffer; they'll be moved to the proper location later.
+     Handle 1 more line than the context says (because we count 1 too many),
+     rounded up to the next power of 2 to speed index computation.  */
+
+  if (no_diff_means_no_output && ! function_regexp.fastmap
+      && context < LIN_MAX / 4 && context < n0)
+    {
+      middle_guess = guess_lines (0, 0, p0 - filevec[0].prefix_end);
+      suffix_guess = guess_lines (0, 0, buffer0 + n0 - p0);
+      for (prefix_count = 1;  prefix_count <= context;  prefix_count *= 2)
+	continue;
+      alloc_lines0 = (prefix_count + middle_guess
+		      + MIN (context, suffix_guess));
+    }
+  else
+    {
+      prefix_count = 0;
+      alloc_lines0 = guess_lines (0, 0, n0);
+    }
+
+  prefix_mask = prefix_count - 1;
+  lines = 0;
+  linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
+  prefix_needed = ! (no_diff_means_no_output
+		     && filevec[0].prefix_end == p0
+		     && filevec[1].prefix_end == p1);
+  p0 = buffer0;
+
+  /* If the prefix is needed, find the prefix lines.  */
+  if (prefix_needed)
+    {
+      end0 = filevec[0].prefix_end;
+      while (p0 != end0)
+	{
+	  lin l = lines++ & prefix_mask;
+	  if (l == alloc_lines0)
+	    {
+	      if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
+		xalloc_die ();
+	      alloc_lines0 *= 2;
+	      linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
+	    }
+	  linbuf0[l] = p0;
+	  while (*p0++ != '\n')
+	    continue;
+	}
+    }
+  buffered_prefix = prefix_count && context < lines ? context : lines;
+
+  /* Allocate line buffer 1.  */
+
+  middle_guess = guess_lines (lines, p0 - buffer0, p1 - filevec[1].prefix_end);
+  suffix_guess = guess_lines (lines, p0 - buffer0, buffer1 + n1 - p1);
+  alloc_lines1 = buffered_prefix + middle_guess + MIN (context, suffix_guess);
+  if (alloc_lines1 < buffered_prefix
+      || PTRDIFF_MAX / sizeof *linbuf1 <= alloc_lines1)
+    xalloc_die ();
+  linbuf1 = xmalloc (alloc_lines1 * sizeof *linbuf1);
+
+  if (buffered_prefix != lines)
+    {
+      /* Rotate prefix lines to proper location.  */
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf0[i] = linbuf1[i];
+    }
+
+  /* Initialize line buffer 1 from line buffer 0.  */
+  for (i = 0; i < buffered_prefix; i++)
+    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;
+
+  /* Record the line buffer, adjusted so that
+     linbuf[0] points at the first differing line.  */
+  filevec[0].linbuf = linbuf0 + buffered_prefix;
+  filevec[1].linbuf = linbuf1 + buffered_prefix;
+  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
+  filevec[0].alloc_lines = alloc_lines0 - buffered_prefix;
+  filevec[1].alloc_lines = alloc_lines1 - buffered_prefix;
+  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
+}
+
+/* If 1 < k, then (2**k - prime_offset[k]) is the largest prime less
+   than 2**k.  This table is derived from Chris K. Caldwell's list
+   <http://www.utm.edu/research/primes/lists/2small/>.  */
+
+static unsigned char const prime_offset[] =
+{
+  0, 0, 1, 1, 3, 1, 3, 1, 5, 3, 3, 9, 3, 1, 3, 19, 15, 1, 5, 1, 3, 9, 3,
+  15, 3, 39, 5, 39, 57, 3, 35, 1, 5, 9, 41, 31, 5, 25, 45, 7, 87, 21,
+  11, 57, 17, 55, 21, 115, 59, 81, 27, 129, 47, 111, 33, 55, 5, 13, 27,
+  55, 93, 1, 57, 25
+};
+
+/* Verify that this host's size_t is not too wide for the above table.  */
+
+verify (sizeof (size_t) * CHAR_BIT <= sizeof prime_offset);
+
+/* Given a vector of two file_data objects, read the file associated
+   with each one, and build the table of equivalence classes.
+   Return nonzero if either file appears to be a binary file.
+   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
+
+bool
+read_files (struct file_data filevec[], bool pretend_binary)
+{
+  int i;
+  bool skip_test = text | pretend_binary;
+  bool appears_binary = pretend_binary | sip (&filevec[0], skip_test);
+
+  if (filevec[0].desc != filevec[1].desc)
+    appears_binary |= sip (&filevec[1], skip_test | appears_binary);
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+    }
+  if (appears_binary)
+    {
+      set_binary_mode (filevec[0].desc, O_BINARY);
+      set_binary_mode (filevec[1].desc, O_BINARY);
+      return true;
+    }
+
+  find_identical_ends (filevec);
+
+  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
+  if (PTRDIFF_MAX / sizeof *equivs <= equivs_alloc)
+    xalloc_die ();
+  equivs = xmalloc (equivs_alloc * sizeof *equivs);
+  /* Equivalence class 0 is permanently safe for lines that were not
+     hashed.  Real equivalence classes start at 1.  */
+  equivs_index = 1;
+
+  /* Allocate (one plus) a prime number of hash buckets.  Use a prime
+     number between 1/3 and 2/3 of the value of equiv_allocs,
+     approximately.  */
+  for (i = 9; (size_t) 1 << i < equivs_alloc / 3; i++)
+    continue;
+  nbuckets = ((size_t) 1 << i) - prime_offset[i];
+  if (PTRDIFF_MAX / sizeof *buckets <= nbuckets)
+    xalloc_die ();
+  buckets = zalloc ((nbuckets + 1) * sizeof *buckets);
+  buckets++;
+
+  for (i = 0; i < 2; i++)
+    find_and_hash_each_line (&filevec[i]);
+
+  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;
+
+  free (equivs);
+  free (buckets - 1);
+
+  return false;
+}
diff --git a/diffutils-3.0/src/normal.c b/diffutils-3.0/src/normal.c
new file mode 100644
index 0000000..c6aac07
--- /dev/null
+++ b/diffutils-3.0/src/normal.c
@@ -0,0 +1,91 @@
+/* Normal-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2013, 2015-2018
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_normal_hunk (struct change *);
+
+/* Print the edit-script SCRIPT as a normal diff.
+   INF points to an array of descriptions of the two files.  */
+
+void
+print_normal_script (struct change *script)
+{
+  print_script (script, find_change, print_normal_hunk);
+}
+
+/* Print a hunk of a normal diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_normal_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  set_color_context (LINE_NUMBER_CONTEXT);
+  print_number_range (',', &files[0], first0, last0);
+  fputc (change_letter[changes], outfile);
+  print_number_range (',', &files[1], first1, last1);
+  set_color_context (RESET_CONTEXT);
+  fputc ('\n', outfile);
+
+  /* Print the lines that the first file has.  */
+  if (changes & OLD)
+    {
+      if (first0 <= last0)
+        set_color_context (DELETE_CONTEXT);
+      for (i = first0; i <= last0; i++)
+        {
+          print_1_line_nl ("<", &files[0].linbuf[i], true);
+          if (i == last0)
+            set_color_context (RESET_CONTEXT);
+          if (files[0].linbuf[i + 1][-1] == '\n')
+            putc ('\n', outfile);
+        }
+    }
+
+  if (changes == CHANGED)
+    fputs ("---\n", outfile);
+
+  /* Print the lines that the second file has.  */
+  if (changes & NEW)
+    {
+      if (first1 <= last1)
+        set_color_context (ADD_CONTEXT);
+      for (i = first1; i <= last1; i++)
+        {
+          print_1_line_nl (">", &files[1].linbuf[i], true);
+          if (i == last1)
+            set_color_context (RESET_CONTEXT);
+          if (files[1].linbuf[i + 1][-1] == '\n')
+            putc ('\n', outfile);
+        }
+    }
+}
diff --git a/diffutils-3.0/src/sdiff.c b/diffutils-3.0/src/sdiff.c
new file mode 100644
index 0000000..caef59e
--- /dev/null
+++ b/diffutils-3.0/src/sdiff.c
@@ -0,0 +1,1173 @@
+/* GNU sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include "die.h"
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <system-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+#endif
+       SIGINT
+};
+enum
+  {
+    NUM_SIGS = sizeof sigs / sizeof *sigs,
+    handler_index_of_SIGINT = NUM_SIGS - 1
+  };
+
+#if HAVE_SIGACTION
+  /* Prefer 'sigaction' if available, since 'signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"ignore-trailing-space", 0, 0, 'Z'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o, --output=FILE            operate interactively, sending output to FILE"),
+  "",
+  N_("-i, --ignore-case            consider upper- and lower-case to be the same"),
+  N_("-E, --ignore-tab-expansion   ignore changes due to tab expansion"),
+  N_("-Z, --ignore-trailing-space  ignore white space at line end"),
+  N_("-b, --ignore-space-change    ignore changes in the amount of white space"),
+  N_("-W, --ignore-all-space       ignore all white space"),
+  N_("-B, --ignore-blank-lines     ignore changes whose lines are all blank"),
+  N_("-I, --ignore-matching-lines=RE  ignore changes all whose lines match RE"),
+  N_("    --strip-trailing-cr      strip trailing carriage return on input"),
+  N_("-a, --text                   treat all files as text"),
+  "",
+  N_("-w, --width=NUM              output at most NUM (default 130) print columns"),
+  N_("-l, --left-column            output only the left column of common lines"),
+  N_("-s, --suppress-common-lines  do not output common lines"),
+  "",
+  N_("-t, --expand-tabs            expand tabs to spaces in output"),
+  N_("    --tabsize=NUM            tab stops at every NUM (default 8) print columns"),
+  "",
+  N_("-d, --minimal                try hard to find a smaller set of changes"),
+  N_("-H, --speed-large-files      assume large files, many scattered small changes"),
+  N_("    --diff-program=PROGRAM   use PROGRAM to compare files"),
+  "",
+  N_("    --help                   display this help and exit"),
+  N_("-v, --version                output version information and exit"),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n",
+          _("Side-by-side merge of differences between FILE1 and FILE2."));
+
+  fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = rawmemchr (lf->bufpos, '\n');
+      if (lf->bufpos == lf->buflim)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = rawmemchr (lf->bufpos, '\n');
+      if (lf->bufpos == lf->buflim)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = rawmemchr (start, '\n');
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:WZ", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case 'Z':
+	  diffarg ("-Z");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! HAVE_WORKING_FORK
+      {
+	char *command = system_quote_argv (SCI_SYSTEM, (char **) diffargv);
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+	diffpid = fork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! HAVE_WORKING_FORK
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      raise (s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      FALLTHROUGH;
+	    default:
+	      flush_line ();
+	      FALLTHROUGH;
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    printint l1 = lline;
+		    printint l2 = lline + llen - 1;
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %"pI"d\n", lname, l1);
+		    else
+		      fprintf (tmp, "--- %s %"pI"d,%"pI"d\n", lname, l1, l2);
+		  }
+		FALLTHROUGH;
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    printint l1 = rline;
+		    printint l2 = rline + rlen - 1;
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %"pI"d\n", rname, l1);
+		    else
+		      fprintf (tmp, "+++ %s %"pI"d,%"pI"d\n", rname, l1, l2);
+		  }
+		FALLTHROUGH;
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      char const *argv[3];
+
+	      ignore_SIGINT = true;
+	      checksigs ();
+	      argv[0] = editor_program;
+	      argv[1] = tmpname;
+	      argv[2] = 0;
+
+	      {
+#if ! HAVE_WORKING_FORK
+		char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = fork ();
+		if (pid == 0)
+		  {
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  val = strtoumax (diff_help + 1, &numend, 10);
+	  if (LIN_MAX < val || errno || *numend != ',')
+	    fatal (diff_help);
+	  llen = val;
+	  val = strtoumax (numend + 1, &numend, 10);
+	  if (LIN_MAX < val || errno || *numend)
+	    fatal (diff_help);
+	  rlen = val;
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  fd = mkstemp (buf);
+  if (0 <= fd)
+    tmpname = buf;
+  return fd;
+}
diff --git a/diffutils-3.0/src/side.c b/diffutils-3.0/src/side.c
new file mode 100644
index 0000000..9670025
--- /dev/null
+++ b/diffutils-3.0/src/side.c
@@ -0,0 +1,335 @@
+/* sdiff-format output routines for GNU DIFF.
+
+   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2013, 2015-2018 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <wchar.h>
+
+static void print_sdiff_common_lines (lin, lin);
+static void print_sdiff_hunk (struct change *);
+
+/* Next line number to be printed in the two input files.  */
+static lin next0, next1;
+
+/* Print the edit-script SCRIPT as a sdiff style output.  */
+
+void
+print_sdiff_script (struct change *script)
+{
+  begin_output ();
+
+  next0 = next1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_sdiff_hunk);
+
+  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
+}
+
+/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */
+
+static size_t
+tab_from_to (size_t from, size_t to)
+{
+  FILE *out = outfile;
+  size_t tab;
+  size_t tab_size = tabsize;
+
+  if (!expand_tabs)
+    for (tab = from + tab_size - from % tab_size;  tab <= to;  tab += tab_size)
+      {
+	putc ('\t', out);
+	from = tab;
+      }
+  while (from++ < to)
+    putc (' ', out);
+  return to;
+}
+
+/* Print the text for half an sdiff line.  This means truncate to
+   width observing tabs, and trim a trailing newline.  Return the
+   last column written (not the number of chars).  */
+
+static size_t
+print_half_line (char const *const *line, size_t indent, size_t out_bound)
+{
+  FILE *out = outfile;
+  register size_t in_position = 0;
+  register size_t out_position = 0;
+  register char const *text_pointer = line[0];
+  register char const *text_limit = line[1];
+  mbstate_t mbstate = { 0 };
+
+  while (text_pointer < text_limit)
+    {
+      char const *tp0 = text_pointer;
+      register char c = *text_pointer++;
+
+      switch (c)
+	{
+	case '\t':
+	  {
+	    size_t spaces = tabsize - in_position % tabsize;
+	    if (in_position == out_position)
+	      {
+		size_t tabstop = out_position + spaces;
+		if (expand_tabs)
+		  {
+		    if (out_bound < tabstop)
+		      tabstop = out_bound;
+		    for (;  out_position < tabstop;  out_position++)
+		      putc (' ', out);
+		  }
+		else
+		  if (tabstop < out_bound)
+		    {
+		      out_position = tabstop;
+		      putc (c, out);
+		    }
+	      }
+	    in_position += spaces;
+	  }
+	  break;
+
+	case '\r':
+	  {
+	    putc (c, out);
+	    tab_from_to (0, indent);
+	    in_position = out_position = 0;
+	  }
+	  break;
+
+	case '\b':
+	  if (in_position != 0 && --in_position < out_bound)
+	    {
+	      if (out_position <= in_position)
+		/* Add spaces to make up for suppressed tab past out_bound.  */
+		for (;  out_position < in_position;  out_position++)
+		  putc (' ', out);
+	      else
+		{
+		  out_position = in_position;
+		  putc (c, out);
+		}
+	    }
+	  break;
+
+	default:
+	  {
+	    wchar_t wc;
+	    size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
+
+	    if (0 < bytes && bytes < (size_t) -2)
+	      {
+		int width = wcwidth (wc);
+		if (0 < width)
+		  in_position += width;
+		if (in_position <= out_bound)
+		  {
+		    out_position = in_position;
+		    fwrite (tp0, 1, bytes, stdout);
+		  }
+		text_pointer = tp0 + bytes;
+		break;
+	      }
+	  }
+	  FALLTHROUGH;
+	case '\f':
+	case '\v':
+	  if (in_position < out_bound)
+	    putc (c, out);
+	  break;
+
+	case ' ': case '!': case '"': case '#': case '%':
+	case '&': case '\'': case '(': case ')': case '*':
+	case '+': case ',': case '-': case '.': case '/':
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+	case ':': case ';': case '<': case '=': case '>':
+	case '?':
+	case 'A': case 'B': case 'C': case 'D': case 'E':
+	case 'F': case 'G': case 'H': case 'I': case 'J':
+	case 'K': case 'L': case 'M': case 'N': case 'O':
+	case 'P': case 'Q': case 'R': case 'S': case 'T':
+	case 'U': case 'V': case 'W': case 'X': case 'Y':
+	case 'Z':
+	case '[': case '\\': case ']': case '^': case '_':
+	case 'a': case 'b': case 'c': case 'd': case 'e':
+	case 'f': case 'g': case 'h': case 'i': case 'j':
+	case 'k': case 'l': case 'm': case 'n': case 'o':
+	case 'p': case 'q': case 'r': case 's': case 't':
+	case 'u': case 'v': case 'w': case 'x': case 'y':
+	case 'z': case '{': case '|': case '}': case '~':
+	  /* These characters are printable ASCII characters.  */
+	  if (in_position++ < out_bound)
+	    {
+	      out_position = in_position;
+	      putc (c, out);
+	    }
+	  break;
+
+	case '\n':
+	  return out_position;
+	}
+    }
+
+  return out_position;
+}
+
+/* Print side by side lines with a separator in the middle.
+   0 parameters are taken to indicate white space text.
+   Blank lines that can easily be caught are reduced to a single newline.  */
+
+static void
+print_1sdiff_line (char const *const *left, char sep,
+		   char const *const *right)
+{
+  FILE *out = outfile;
+  size_t hw = sdiff_half_width;
+  size_t c2o = sdiff_column2_offset;
+  size_t col = 0;
+  bool put_newline = false;
+  bool color_to_reset = false;
+
+  if (sep == '<')
+    {
+      set_color_context (DELETE_CONTEXT);
+      color_to_reset = true;
+    }
+  else if (sep == '>')
+    {
+      set_color_context (ADD_CONTEXT);
+      color_to_reset = true;
+    }
+
+  if (left)
+    {
+      put_newline |= left[1][-1] == '\n';
+      col = print_half_line (left, 0, hw);
+    }
+
+  if (sep != ' ')
+    {
+      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
+      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
+	sep = put_newline ? '/' : '\\';
+      putc (sep, out);
+    }
+
+  if (right)
+    {
+      put_newline |= right[1][-1] == '\n';
+      if (**right != '\n')
+	{
+	  col = tab_from_to (col, c2o);
+	  print_half_line (right, col, hw);
+	}
+    }
+
+  if (put_newline)
+    putc ('\n', out);
+
+  if (color_to_reset)
+    set_color_context (RESET_CONTEXT);
+}
+
+/* Print lines common to both files in side-by-side format.  */
+static void
+print_sdiff_common_lines (lin limit0, lin limit1)
+{
+  lin i0 = next0, i1 = next1;
+
+  if (!suppress_common_lines && (i0 != limit0 || i1 != limit1))
+    {
+      if (sdiff_merge_assist)
+	{
+	  printint len0 = limit0 - i0;
+	  printint len1 = limit1 - i1;
+	  fprintf (outfile, "i%"pI"d,%"pI"d\n", len0, len1);
+	}
+
+      if (!left_column)
+	{
+	  while (i0 != limit0 && i1 != limit1)
+	    print_1sdiff_line (&files[0].linbuf[i0++], ' ',
+			       &files[1].linbuf[i1++]);
+	  while (i1 != limit1)
+	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
+	}
+      while (i0 != limit0)
+	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
+    }
+
+  next0 = limit0;
+  next1 = limit1;
+}
+
+/* Print a hunk of an sdiff diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_sdiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i, j;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes =
+    analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  /* Print out lines up to this change.  */
+  print_sdiff_common_lines (first0, first1);
+
+  if (sdiff_merge_assist)
+    {
+      printint len0 = last0 - first0 + 1;
+      printint len1 = last1 - first1 + 1;
+      fprintf (outfile, "c%"pI"d,%"pI"d\n", len0, len1);
+    }
+
+  /* Print "xxx  |  xxx " lines.  */
+  if (changes == CHANGED)
+    {
+      for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
+      changes = (i <= last0 ? OLD : 0) + (j <= last1 ? NEW : 0);
+      next0 = first0 = i;
+      next1 = first1 = j;
+    }
+
+  /* Print "     >  xxx " lines.  */
+  if (changes & NEW)
+    {
+      for (j = first1; j <= last1; ++j)
+	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
+      next1 = j;
+    }
+
+  /* Print "xxx  <     " lines.  */
+  if (changes & OLD)
+    {
+      for (i = first0; i <= last0; ++i)
+	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
+      next0 = i;
+    }
+}
diff --git a/diffutils-3.0/src/system.h b/diffutils-3.0/src/system.h
new file mode 100644
index 0000000..0c351b9
--- /dev/null
+++ b/diffutils-3.0/src/system.h
@@ -0,0 +1,240 @@
+/* System dependent declarations.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Use this to suppress gcc's "...may be used before initialized" warnings. */
+#ifdef lint
+# define IF_LINT(Code) Code
+#else
+# define IF_LINT(Code) /* empty */
+#endif
+
+/* Define '__attribute__' and 'volatile' first
+   so that they're used consistently in all system includes.  */
+#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6) || __STRICT_ANSI__
+# define __attribute__(x)
+#endif
+
+#include <verify.h>
+
+#include <sys/types.h>
+
+#include <sys/stat.h>
+#include "stat-macros.h"
+
+#ifndef STAT_BLOCKSIZE
+# if HAVE_STRUCT_STAT_ST_BLKSIZE
+#  define STAT_BLOCKSIZE(s) ((s).st_blksize)
+# else
+#  define STAT_BLOCKSIZE(s) (8 * 1024)
+# endif
+#endif
+
+#include <unistd.h>
+
+#include <fcntl.h>
+#include <time.h>
+
+#include <sys/wait.h>
+
+#include <dirent.h>
+#ifndef _D_EXACT_NAMLEN
+# define _D_EXACT_NAMLEN(dp) strlen ((dp)->d_name)
+#endif
+
+#include <stdlib.h>
+#define EXIT_TROUBLE 2
+
+#include <limits.h>
+#include <locale.h>
+#include <stddef.h>
+#include <inttypes.h>
+
+#include <string.h>
+#if ! HAVE_STRCASECOLL
+# if HAVE_STRICOLL || defined stricoll
+#  define strcasecoll(a, b) stricoll (a, b)
+# else
+#  define strcasecoll(a, b) strcasecmp (a, b) /* best we can do */
+# endif
+#endif
+#if ! (HAVE_STRCASECMP || defined strcasecmp)
+int strcasecmp (char const *, char const *);
+#endif
+
+#include <gettext.h>
+#if ! ENABLE_NLS
+# undef textdomain
+# define textdomain(Domainname) /* empty */
+# undef bindtextdomain
+# define bindtextdomain(Domainname, Dirname) /* empty */
+#endif
+
+#define _(msgid) gettext (msgid)
+#define N_(msgid) msgid
+
+#include <ctype.h>
+
+/* ISDIGIT differs from isdigit, as follows:
+   - Its arg may be any int or unsigned int; it need not be an unsigned char.
+   - It's guaranteed to evaluate its argument exactly once.
+   - It's typically faster.
+   POSIX 1003.1-2001 says that only '0' through '9' are digits.
+   Prefer ISDIGIT to isdigit unless it's important to use the locale's
+   definition of 'digit' even when the host does not conform to POSIX.  */
+#define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)
+
+#include <errno.h>
+
+#include <signal.h>
+#if !defined SIGCHLD && defined SIGCLD
+# define SIGCHLD SIGCLD
+#endif
+
+#undef MIN
+#undef MAX
+#define MIN(a, b) ((a) <= (b) ? (a) : (b))
+#define MAX(a, b) ((a) >= (b) ? (a) : (b))
+
+#include <stdbool.h>
+#include <intprops.h>
+#include "propername.h"
+#include "version.h"
+
+/* Type used for fast comparison of several bytes at a time.
+   This used to be uintmax_t, but changing it to size_t
+   made plain 'cmp' 90% faster (GCC 4.8.1, x86).  */
+
+#ifndef word
+# define word size_t
+#endif
+
+/* The signed integer type of a line number.  Since files are read
+   into main memory, ptrdiff_t should be wide enough.  */
+
+typedef ptrdiff_t lin;
+#define LIN_MAX PTRDIFF_MAX
+
+/* The signed integer type for printing line numbers, and its printf
+   length modifier.  This is not simply ptrdiff_t, to cater to older
+   and/or nonstandard C libraries where "l" works but "ll" and "t" do
+   not, or where 'long' is too narrow and "ll" works but "t" does not.  */
+
+#if LIN_MAX <= LONG_MAX
+typedef long int printint;
+# define pI "l"
+#elif LIN_MAX <= LLONG_MAX
+typedef long long int printint;
+# define pI "ll"
+#else
+typedef ptrdiff_t printint;
+# define pI "t"
+#endif
+
+verify (TYPE_SIGNED (lin));
+verify (TYPE_SIGNED (printint));
+verify (LIN_MAX == TYPE_MAXIMUM (lin));
+verify (LIN_MAX <= TYPE_MAXIMUM (printint));
+
+/* Limit so that 2 * CONTEXT + 1 does not overflow.  */
+
+#define CONTEXT_MAX ((LIN_MAX - 1) / 2)
+
+
+/* This section contains POSIX-compliant defaults for macros
+   that are meant to be overridden by hand in config.h as needed.  */
+
+#ifndef file_name_cmp
+# define file_name_cmp strcmp
+#endif
+
+#ifndef initialize_main
+# define initialize_main(argcp, argvp)
+#endif
+
+#ifndef NULL_DEVICE
+# define NULL_DEVICE "/dev/null"
+#endif
+
+/* Do struct stat *S, *T describe the same special file?  */
+#ifndef same_special_file
+# if HAVE_STRUCT_STAT_ST_RDEV && defined S_ISBLK && defined S_ISCHR
+#  define same_special_file(s, t) \
+     (((S_ISBLK ((s)->st_mode) && S_ISBLK ((t)->st_mode)) \
+       || (S_ISCHR ((s)->st_mode) && S_ISCHR ((t)->st_mode))) \
+      && (s)->st_rdev == (t)->st_rdev)
+# else
+#  define same_special_file(s, t) 0
+# endif
+#endif
+
+/* Do struct stat *S, *T describe the same file?  Answer -1 if unknown.  */
+#ifndef same_file
+# define same_file(s, t) \
+    ((((s)->st_ino == (t)->st_ino) && ((s)->st_dev == (t)->st_dev)) \
+     || same_special_file (s, t))
+#endif
+
+/* Do struct stat *S, *T have the same file attributes?
+
+   POSIX says that two files are identical if st_ino and st_dev are
+   the same, but many file systems incorrectly assign the same (device,
+   inode) pair to two distinct files, including:
+
+   - GNU/Linux NFS servers that export all local file systems as a
+     single NFS file system, if a local device number (st_dev) exceeds
+     255, or if a local inode number (st_ino) exceeds 16777215.
+
+   - Network Appliance NFS servers in snapshot directories; see
+     Network Appliance bug #195.
+
+   - ClearCase MVFS; see bug id ATRia04618.
+
+   Check whether two files that purport to be the same have the same
+   attributes, to work around instances of this common bug.  Do not
+   inspect all attributes, only attributes useful in checking for this
+   bug.
+
+   It's possible for two distinct files on a buggy file system to have
+   the same attributes, but it's not worth slowing down all
+   implementations (or complicating the configuration) to cater to
+   these rare cases in buggy implementations.  */
+
+#ifndef same_file_attributes
+# define same_file_attributes(s, t) \
+   ((s)->st_mode == (t)->st_mode \
+    && (s)->st_nlink == (t)->st_nlink \
+    && (s)->st_uid == (t)->st_uid \
+    && (s)->st_gid == (t)->st_gid \
+    && (s)->st_size == (t)->st_size \
+    && (s)->st_mtime == (t)->st_mtime \
+    && (s)->st_ctime == (t)->st_ctime)
+#endif
+
+#define STREQ(a, b) (strcmp (a, b) == 0)
+
+#ifndef FALLTHROUGH
+# if __GNUC__ < 7
+#  define FALLTHROUGH ((void) 0)
+# else
+#  define FALLTHROUGH __attribute__ ((__fallthrough__))
+# endif
+#endif
diff --git a/diffutils-3.0/src/util.c b/diffutils-3.0/src/util.c
new file mode 100644
index 0000000..4f4d9bb
--- /dev/null
+++ b/diffutils-3.0/src/util.c
@@ -0,0 +1,1576 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2018 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include "argmatch.h"
+#include "die.h"
+#include <dirname.h>
+#include <error.h>
+#include <system-quote.h>
+#include <xalloc.h>
+#include "xvasprintf.h"
+#include <signal.h>
+
+/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
+   present.  */
+#ifndef SA_NOCLDSTOP
+# define SA_NOCLDSTOP 0
+# define sigprocmask(How, Set, Oset) /* empty */
+# define sigset_t int
+# if ! HAVE_SIGINTERRUPT
+#  define siginterrupt(sig, flag) /* empty */
+# endif
+#endif
+
+#ifndef SA_RESTART
+# define SA_RESTART 0
+#endif
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a 'struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  die (EXIT_TROUBLE, e, "%s", name);
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  die (EXIT_TROUBLE, 0, "%s", _(msgid));
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to 'message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* The set of signals that are caught.  */
+
+static sigset_t caught_signals;
+
+/* If nonzero, the value of the pending fatal signal.  */
+
+static sig_atomic_t volatile interrupt_signal;
+
+/* A count of the number of pending stop signals that have been received.  */
+
+static sig_atomic_t volatile stop_signal_count;
+
+/* An ordinary signal was received; arrange for the program to exit.  */
+
+static void
+sighandler (int sig)
+{
+  if (! SA_NOCLDSTOP)
+    signal (sig, SIG_IGN);
+  if (! interrupt_signal)
+    interrupt_signal = sig;
+}
+
+/* A SIGTSTP was received; arrange for the program to suspend itself.  */
+
+static void
+stophandler (int sig)
+{
+  if (! SA_NOCLDSTOP)
+    signal (sig, stophandler);
+  if (! interrupt_signal)
+    stop_signal_count++;
+}
+/* Process any pending signals.  If signals are caught, this function
+   should be called periodically.  Ideally there should never be an
+   unbounded amount of time when signals are not being processed.
+   Signal handling can restore the default colors, so callers must
+   immediately change colors after invoking this function.  */
+
+static void
+process_signals (void)
+{
+  while (interrupt_signal || stop_signal_count)
+    {
+      int sig;
+      int stops;
+      sigset_t oldset;
+
+      set_color_context (RESET_CONTEXT);
+      fflush (stdout);
+
+      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
+
+      /* Reload interrupt_signal and stop_signal_count, in case a new
+         signal was handled before sigprocmask took effect.  */
+      sig = interrupt_signal;
+      stops = stop_signal_count;
+
+      /* SIGTSTP is special, since the application can receive that signal
+         more than once.  In this case, don't set the signal handler to the
+         default.  Instead, just raise the uncatchable SIGSTOP.  */
+      if (stops)
+        {
+          stop_signal_count = stops - 1;
+          sig = SIGSTOP;
+        }
+      else
+        signal (sig, SIG_DFL);
+
+      /* Exit or suspend the program.  */
+      raise (sig);
+      sigprocmask (SIG_SETMASK, &oldset, NULL);
+
+      /* If execution reaches here, then the program has been
+         continued (after being suspended).  */
+    }
+}
+
+static void
+install_signal_handlers (void)
+{
+  /* The signals that are trapped, and the number of such signals.  */
+  static int const sig[] =
+    {
+      /* This one is handled specially.  */
+      SIGTSTP,
+
+      /* The usual suspects.  */
+      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+#ifdef SIGPOLL
+      SIGPOLL,
+#endif
+#ifdef SIGPROF
+      SIGPROF,
+#endif
+#ifdef SIGVTALRM
+      SIGVTALRM,
+#endif
+#ifdef SIGXCPU
+      SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+      SIGXFSZ,
+#endif
+    };
+  enum { nsigs = sizeof (sig) / sizeof *(sig) };
+
+#if ! SA_NOCLDSTOP
+  bool caught_sig[nsigs];
+#endif
+  {
+    int j;
+#if SA_NOCLDSTOP
+    struct sigaction act;
+
+    sigemptyset (&caught_signals);
+    for (j = 0; j < nsigs; j++)
+      {
+        sigaction (sig[j], NULL, &act);
+        if (act.sa_handler != SIG_IGN)
+          sigaddset (&caught_signals, sig[j]);
+      }
+
+    act.sa_mask = caught_signals;
+    act.sa_flags = SA_RESTART;
+
+    for (j = 0; j < nsigs; j++)
+      if (sigismember (&caught_signals, sig[j]))
+        {
+          act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
+          sigaction (sig[j], &act, NULL);
+        }
+#else
+    for (j = 0; j < nsigs; j++)
+      {
+        caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
+        if (caught_sig[j])
+          {
+            signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
+            siginterrupt (sig[j], 0);
+          }
+      }
+#endif
+    }
+}
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+static bool colors_enabled;
+
+static struct color_ext_type *color_ext_list = NULL;
+
+struct bin_str
+  {
+    size_t len;			/* Number of bytes */
+    const char *string;		/* Pointer to the same */
+  };
+
+struct color_ext_type
+  {
+    struct bin_str ext;		/* The extension we're looking for */
+    struct bin_str seq;		/* The sequence to output when we do */
+    struct color_ext_type *next;	/* Next in list */
+  };
+
+/* Parse a string as part of the --palette argument; this may involve
+   decoding all kinds of escape characters.  If equals_end is set an
+   unescaped equal sign ends the string, otherwise only a : or \0
+   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
+   true if successful.
+
+   The resulting string is *not* null-terminated, but may contain
+   embedded nulls.
+
+   Note that both dest and src are char **; on return they point to
+   the first free byte after the array and the character that ended
+   the input string, respectively.  */
+
+static bool
+get_funky_string (char **dest, const char **src, bool equals_end,
+                  size_t *output_count)
+{
+  char num;			/* For numerical codes */
+  size_t count;			/* Something to count with */
+  enum {
+    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
+  } state;
+  const char *p;
+  char *q;
+
+  p = *src;			/* We don't want to double-indirect */
+  q = *dest;			/* the whole darn time.  */
+
+  count = 0;			/* No characters counted in yet.  */
+  num = 0;
+
+  state = ST_GND;		/* Start in ground state.  */
+  while (state < ST_END)
+    {
+      switch (state)
+        {
+        case ST_GND:		/* Ground state (no escapes) */
+          switch (*p)
+            {
+            case ':':
+            case '\0':
+              state = ST_END;	/* End of string */
+              break;
+            case '\\':
+              state = ST_BACKSLASH; /* Backslash scape sequence */
+              ++p;
+              break;
+            case '^':
+              state = ST_CARET; /* Caret escape */
+              ++p;
+              break;
+            case '=':
+              if (equals_end)
+                {
+                  state = ST_END; /* End */
+                  break;
+                }
+              FALLTHROUGH;
+            default:
+              *(q++) = *(p++);
+              ++count;
+              break;
+            }
+          break;
+
+        case ST_BACKSLASH:	/* Backslash escaped character */
+          switch (*p)
+            {
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+              state = ST_OCTAL;	/* Octal sequence */
+              num = *p - '0';
+              break;
+            case 'x':
+            case 'X':
+              state = ST_HEX;	/* Hex sequence */
+              num = 0;
+              break;
+            case 'a':		/* Bell */
+              num = '\a';
+              break;
+            case 'b':		/* Backspace */
+              num = '\b';
+              break;
+            case 'e':		/* Escape */
+              num = 27;
+              break;
+            case 'f':		/* Form feed */
+              num = '\f';
+              break;
+            case 'n':		/* Newline */
+              num = '\n';
+              break;
+            case 'r':		/* Carriage return */
+              num = '\r';
+              break;
+            case 't':		/* Tab */
+              num = '\t';
+              break;
+            case 'v':		/* Vtab */
+              num = '\v';
+              break;
+            case '?':		/* Delete */
+              num = 127;
+              break;
+            case '_':		/* Space */
+              num = ' ';
+              break;
+            case '\0':		/* End of string */
+              state = ST_ERROR;	/* Error! */
+              break;
+            default:		/* Escaped character like \ ^ : = */
+              num = *p;
+              break;
+            }
+          if (state == ST_BACKSLASH)
+            {
+              *(q++) = num;
+              ++count;
+              state = ST_GND;
+            }
+          ++p;
+          break;
+
+        case ST_OCTAL:		/* Octal sequence */
+          if (*p < '0' || *p > '7')
+            {
+              *(q++) = num;
+              ++count;
+              state = ST_GND;
+            }
+          else
+            num = (num << 3) + (*(p++) - '0');
+          break;
+
+        case ST_HEX:		/* Hex sequence */
+          switch (*p)
+            {
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+            case '8':
+            case '9':
+              num = (num << 4) + (*(p++) - '0');
+              break;
+            case 'a':
+            case 'b':
+            case 'c':
+            case 'd':
+            case 'e':
+            case 'f':
+              num = (num << 4) + (*(p++) - 'a') + 10;
+              break;
+            case 'A':
+            case 'B':
+            case 'C':
+            case 'D':
+            case 'E':
+            case 'F':
+              num = (num << 4) + (*(p++) - 'A') + 10;
+              break;
+            default:
+              *(q++) = num;
+              ++count;
+              state = ST_GND;
+              break;
+            }
+          break;
+
+        case ST_CARET:		/* Caret escape */
+          state = ST_GND;	/* Should be the next state... */
+          if (*p >= '@' && *p <= '~')
+            {
+              *(q++) = *(p++) & 037;
+              ++count;
+            }
+          else if (*p == '?')
+            {
+              *(q++) = 127;
+              ++count;
+            }
+          else
+            state = ST_ERROR;
+          break;
+
+        default:
+          abort ();
+        }
+    }
+
+  *dest = q;
+  *src = p;
+  *output_count = count;
+
+  return state != ST_ERROR;
+}
+
+enum parse_state
+  {
+    PS_START = 1,
+    PS_2,
+    PS_3,
+    PS_4,
+    PS_DONE,
+    PS_FAIL
+  };
+
+#define LEN_STR_PAIR(s) sizeof (s) - 1, s
+
+static struct bin_str color_indicator[] =
+  {
+    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
+    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
+    { 0, NULL },			/* ec: End color (replaces lc+rs+rc) */
+    { LEN_STR_PAIR ("0") },		/* rs: Reset to ordinary colors */
+    { LEN_STR_PAIR ("1") },		/* hd: Header */
+    { LEN_STR_PAIR ("32") },		/* ad: Add line */
+    { LEN_STR_PAIR ("31") },		/* de: Delete line */
+    { LEN_STR_PAIR ("36") },		/* ln: Line number */
+  };
+
+static const char *const indicator_name[] =
+  {
+    "lc", "rc", "ec", "rs", "hd", "ad", "de", "ln", NULL
+  };
+ARGMATCH_VERIFY (indicator_name, color_indicator);
+
+static char const *color_palette;
+
+void
+set_color_palette (char const *palette)
+{
+  color_palette = palette;
+}
+
+static void
+parse_diff_color (void)
+{
+  char *color_buf;
+  const char *p;		/* Pointer to character being parsed */
+  char *buf;			/* color_buf buffer pointer */
+  int ind_no;			/* Indicator number */
+  char label[3];		/* Indicator label */
+  struct color_ext_type *ext;	/* Extension we are working on */
+
+  if ((p = color_palette) == NULL || *p == '\0')
+    return;
+
+  ext = NULL;
+  strcpy (label, "??");
+
+  /* This is an overly conservative estimate, but any possible
+     --palette string will *not* generate a color_buf longer than
+     itself, so it is a safe way of allocating a buffer in
+     advance.  */
+  buf = color_buf = xstrdup (p);
+
+  enum parse_state state = PS_START;
+  while (true)
+    {
+      switch (state)
+        {
+        case PS_START:		/* First label character */
+          switch (*p)
+            {
+            case ':':
+              ++p;
+              break;
+
+            case '*':
+              /* Allocate new extension block and add to head of
+                 linked list (this way a later definition will
+                 override an earlier one, which can be useful for
+                 having terminal-specific defs override global).  */
+
+              ext = xmalloc (sizeof *ext);
+              ext->next = color_ext_list;
+              color_ext_list = ext;
+
+              ++p;
+              ext->ext.string = buf;
+
+              state = (get_funky_string (&buf, &p, true, &ext->ext.len)
+                       ? PS_4 : PS_FAIL);
+              break;
+
+            case '\0':
+              state = PS_DONE;	/* Done! */
+              goto done;
+
+            default:	/* Assume it is file type label */
+              label[0] = *(p++);
+              state = PS_2;
+              break;
+            }
+          break;
+
+        case PS_2:		/* Second label character */
+          if (*p)
+            {
+              label[1] = *(p++);
+              state = PS_3;
+            }
+          else
+            state = PS_FAIL;	/* Error */
+          break;
+
+        case PS_3:		/* Equal sign after indicator label */
+          state = PS_FAIL;	/* Assume failure...  */
+          if (*(p++) == '=')/* It *should* be...  */
+            {
+              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
+                {
+                  if (STREQ (label, indicator_name[ind_no]))
+                    {
+                      color_indicator[ind_no].string = buf;
+                      state = (get_funky_string (&buf, &p, false,
+                                                 &color_indicator[ind_no].len)
+                               ? PS_START : PS_FAIL);
+                      break;
+                    }
+                }
+              if (state == PS_FAIL)
+                error (0, 0, _("unrecognized prefix: %s"), label);
+            }
+          break;
+
+        case PS_4:		/* Equal sign after *.ext */
+          if (*(p++) == '=')
+            {
+              ext->seq.string = buf;
+              state = (get_funky_string (&buf, &p, false, &ext->seq.len)
+                       ? PS_START : PS_FAIL);
+            }
+          else
+            state = PS_FAIL;
+          break;
+
+        case PS_FAIL:
+          goto done;
+
+        default:
+          abort ();
+        }
+    }
+ done:
+
+  if (state == PS_FAIL)
+    {
+      struct color_ext_type *e;
+      struct color_ext_type *e2;
+
+      error (0, 0,
+             _("unparsable value for --palette"));
+      free (color_buf);
+      for (e = color_ext_list; e != NULL; /* empty */)
+        {
+          e2 = e;
+          e = e->next;
+          free (e2);
+        }
+      colors_enabled = false;
+    }
+}
+
+static void
+check_color_output (bool is_pipe)
+{
+  bool output_is_tty;
+
+  if (! outfile || colors_style == NEVER)
+    return;
+
+  output_is_tty = presume_output_tty || (!is_pipe && isatty (fileno (outfile)));
+
+  colors_enabled = (colors_style == ALWAYS
+                    || (colors_style == AUTO && output_is_tty));
+
+  if (colors_enabled)
+    parse_diff_color ();
+
+  if (output_is_tty)
+    install_signal_handlers ();
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a 'pr' and make OUTFILE a pipe to it.
+   'pr' then outputs to our stdout.  */
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK
+static pid_t pr_pid;
+#endif
+
+static char c_escape_char (char c)
+{
+  switch (c) {
+    case '\a': return 'a';
+    case '\b': return 'b';
+    case '\t': return 't';
+    case '\n': return 'n';
+    case '\v': return 'v';
+    case '\f': return 'f';
+    case '\r': return 'r';
+    case '"': return '"';
+    case '\\': return '\\';
+    default:
+      return c < 32;
+  }
+}
+
+static char *
+c_escape (char const *str)
+{
+  char const *s;
+  size_t plus = 0;
+  bool must_quote = false;
+
+  for (s = str; *s; s++)
+    {
+      char c = *s;
+
+      if (c == ' ')
+	{
+	  must_quote = true;
+	  continue;
+	}
+      switch (c_escape_char (*s))
+	{
+	  case 1:
+	    plus += 3;
+	    /* fall through */
+	  case 0:
+	    break;
+	  default:
+	    plus++;
+	    break;
+	}
+    }
+
+  if (must_quote || plus)
+    {
+      size_t s_len = s - str;
+      char *buffer = xmalloc (s_len + plus + 3);
+      char *b = buffer;
+
+      *b++ = '"';
+      for (s = str; *s; s++)
+	{
+	  char c = *s;
+	  char escape = c_escape_char (c);
+
+	  switch (escape)
+	    {
+	      case 0:
+		*b++ = c;
+		break;
+	      case 1:
+		*b++ = '\\';
+		*b++ = ((c >> 6) & 03) + '0';
+		*b++ = ((c >> 3) & 07) + '0';
+		*b++ = ((c >> 0) & 07) + '0';
+		break;
+	      default:
+		*b++ = '\\';
+		*b++ = escape;
+		break;
+	    }
+	}
+      *b++ = '"';
+      *b = 0;
+      return buffer;
+    }
+
+  return (char *) str;
+}
+
+void
+begin_output (void)
+{
+  char *names[2];
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  names[0] = c_escape (current_name0);
+  names[1] = c_escape (current_name1);
+
+  /* Construct the header of this piece of diff.  */
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  name = xasprintf ("diff%s %s %s", switch_string, names[0], names[1]);
+
+  if (paginate)
+    {
+      char const *argv[4];
+
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      argv[0] = pr_program;
+      argv[1] = "-h";
+      argv[2] = name;
+      argv[3] = 0;
+
+      /* Make OUTFILE a pipe to a subsidiary 'pr'.  */
+      {
+#if HAVE_WORKING_FORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = fork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execv (pr_program, (char **) argv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	    check_color_output (true);
+	  }
+#else
+	char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	check_color_output (true);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to 'stdout'.  */
+
+      outfile = stdout;
+      check_color_output (false);
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, (char const *const *)names, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, (char const *const *)names, true);
+      break;
+
+    default:
+      break;
+    }
+
+  if (names[0] != current_name0)
+    free (names[0]);
+  if (names[1] != current_name1)
+    free (names[1]);
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the 'pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! HAVE_WORKING_FORK
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	die (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TRAILING_SPACE:
+	    case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
+	      if (isspace (c1) && isspace (c2))
+		{
+		  unsigned char c;
+		  if (c1 != '\n')
+		    {
+		      char const *p = t1;
+		      while ((c = *p) != '\n' && isspace (c))
+			++p;
+		      if (c != '\n')
+			break;
+		    }
+		  if (c2 != '\n')
+		    {
+		      char const *p = t2;
+		      while ((c = *p) != '\n' && isspace (c))
+			++p;
+		      if (c != '\n')
+			break;
+		    }
+		  /* Both lines have nothing but whitespace left.  */
+		  return false;
+		}
+	      if (ignore_white_space == IGNORE_TRAILING_SPACE)
+		break;
+	      FALLTHROUGH;
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change * _GL_ATTRIBUTE_CONST
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change * _GL_ATTRIBUTE_CONST
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  print_1_line_nl (line_flag, line, false);
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  If SKIP_NL is set, then
+   the final '\n' is not printed.  */
+
+void
+print_1_line_nl (char const *line_flag, char const *const *line, bool skip_nl)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit - (skip_nl && limit[-1] == '\n'), flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    {
+      set_color_context (RESET_CONTEXT);
+      fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+    }
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  const size_t MAX_CHUNK = 1024;
+  if (!expand_tabs)
+    {
+      size_t left = limit - base;
+      while (left)
+        {
+          size_t to_write = MIN (left, MAX_CHUNK);
+          size_t written = fwrite (base, sizeof (char), to_write, outfile);
+          if (written < to_write)
+            return;
+          base += written;
+          left -= written;
+          process_signals ();
+        }
+    }
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+      size_t counter_proc_signals = 0;
+
+      while (t < limit)
+        {
+          counter_proc_signals++;
+          if (counter_proc_signals == MAX_CHUNK)
+            {
+              process_signals ();
+              counter_proc_signals = 0;
+            }
+
+          switch ((c = *t++))
+            {
+            case '\t':
+              {
+                size_t spaces = tab_size - column % tab_size;
+                column += spaces;
+                do
+                  putc (' ', out);
+                while (--spaces);
+              }
+              break;
+
+            case '\r':
+              putc (c, out);
+              if (flag_format && t < limit && *t != '\n')
+                fprintf (out, flag_format, line_flag);
+              column = 0;
+              break;
+
+            case '\b':
+              if (column == 0)
+                continue;
+              column--;
+              putc (c, out);
+              break;
+
+            default:
+              column += isprint (c) != 0;
+              putc (c, out);
+              break;
+            }
+        }
+    }
+}
+
+enum indicator_no
+  {
+    C_LEFT, C_RIGHT, C_END, C_RESET, C_HEADER, C_ADD, C_DELETE, C_LINE
+  };
+
+static void
+put_indicator (const struct bin_str *ind)
+{
+  fwrite (ind->string, ind->len, 1, outfile);
+}
+
+static enum color_context last_context = RESET_CONTEXT;
+
+void
+set_color_context (enum color_context color_context)
+{
+  if (color_context != RESET_CONTEXT)
+    process_signals ();
+  if (colors_enabled && last_context != color_context)
+    {
+      put_indicator (&color_indicator[C_LEFT]);
+      switch (color_context)
+        {
+        case HEADER_CONTEXT:
+          put_indicator (&color_indicator[C_HEADER]);
+          break;
+
+        case LINE_NUMBER_CONTEXT:
+          put_indicator (&color_indicator[C_LINE]);
+          break;
+
+        case ADD_CONTEXT:
+          put_indicator (&color_indicator[C_ADD]);
+          break;
+
+        case DELETE_CONTEXT:
+          put_indicator (&color_indicator[C_DELETE]);
+          break;
+
+        case RESET_CONTEXT:
+          put_indicator (&color_indicator[C_RESET]);
+          break;
+
+        default:
+          abort ();
+        }
+      put_indicator (&color_indicator[C_RIGHT]);
+      last_context = color_context;
+    }
+}
+
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin _GL_ATTRIBUTE_PURE
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to printint rather than lin, so that the
+   caller can use printf with "%"pI"d" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 printint *aptr, printint *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  printint trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%"pI"d%c%"pI"d", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%"pI"d", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of 'struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+
+  bool skip_white_space =
+    ignore_blank_lines && IGNORE_TRAILING_SPACE <= ignore_white_space;
+  bool skip_leading_white_space =
+    skip_white_space && IGNORE_SPACE_CHANGE <= ignore_white_space;
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *lastbyte = linbuf0[i + 1] - 1;
+	  char const *newline = lastbyte + (*lastbyte != '\n');
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_white_space)
+	    for (; *p != '\n'; p++)
+	      if (! isspace ((unsigned char) *p))
+		{
+		  if (! skip_leading_white_space)
+		    p = line;
+		  break;
+		}
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *lastbyte = linbuf1[i + 1] - 1;
+	  char const *newline = lastbyte + (*lastbyte != '\n');
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_white_space)
+	    for (; *p != '\n'; p++)
+	      if (! isspace ((unsigned char) *p))
+		{
+		  if (! skip_leading_white_space)
+		    p = line;
+		  break;
+		}
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      printint line0 = sp->line0;
+      printint line1 = sp->line1;
+      printint deleted = sp->deleted;
+      printint inserted = sp->inserted;
+      fprintf (stderr, "%3"pI"d %3"pI"d delete %"pI"d insert %"pI"d\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
diff --git a/patch.txt b/patch.txt
new file mode 100644
index 0000000..22ca1a2
--- /dev/null
+++ b/patch.txt
@@ -0,0 +1,321 @@
+diff --git a/src/cmp.c b/src/cmp.c
+index 2455dc4..e19f013 100644
+--- a/src/cmp.c
++++ b/src/cmp.c
+@@ -115,7 +115,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -134,7 +134,7 @@ specify_ignore_initial (int f, char **argptr, char delimiter)
+   if (! (e == LONGINT_OK
+ 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+       || TYPE_MAXIMUM (off_t) < val)
+-    try_help ("invalid --ignore-initial value `%s'", arg);
++    try_help ("invalid --ignore-initial value '%s'", arg);
+   if (ignore_initial[f] < val)
+     ignore_initial[f] = val;
+ }
+@@ -185,7 +185,7 @@ usage (void)
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+-	  _("If a FILE is `-' or missing, read standard input."),
++	  _("If a FILE is '-' or missing, read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -231,7 +231,7 @@ main (int argc, char **argv)
+ 	{
+ 	  uintmax_t n;
+ 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+-	    try_help ("invalid --bytes value `%s'", optarg);
++	    try_help ("invalid --bytes value '%s'", optarg);
+ 	  if (n < bytes)
+ 	    bytes = n;
+ 	}
+@@ -257,7 +257,7 @@ main (int argc, char **argv)
+       }
+ 
+   if (optind == argc)
+-    try_help ("missing operand after `%s'", argv[argc - 1]);
++    try_help ("missing operand after '%s'", argv[argc - 1]);
+ 
+   file[0] = argv[optind++];
+   file[1] = optind < argc ? argv[optind++] : "-";
+@@ -269,7 +269,7 @@ main (int argc, char **argv)
+     }
+ 
+   if (optind < argc)
+-    try_help ("extra operand `%s'", argv[optind]);
++    try_help ("extra operand '%s'", argv[optind]);
+ 
+   for (f = 0; f < 2; f++)
+     {
+diff --git a/src/diff.c b/src/diff.c
+index cc1b611..365bea0 100644
+--- a/src/diff.c
++++ b/src/diff.c
+@@ -330,7 +330,7 @@ main (int argc, char **argv)
+ 	      {
+ 		numval = strtoumax (optarg, &numend, 10);
+ 		if (*numend)
+-		  try_help ("invalid context length `%s'", optarg);
++		  try_help ("invalid context length '%s'", optarg);
+ 		if (LIN_MAX < numval)
+ 		  numval = LIN_MAX;
+ 	      }
+@@ -505,7 +505,7 @@ main (int argc, char **argv)
+ 	case 'W':
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid width `%s'", optarg);
++	    try_help ("invalid width '%s'", optarg);
+ 	  if (width != numval)
+ 	    {
+ 	      if (width)
+@@ -534,7 +534,7 @@ main (int argc, char **argv)
+ 	case HORIZON_LINES_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (*numend)
+-	    try_help ("invalid horizon length `%s'", optarg);
++	    try_help ("invalid horizon length '%s'", optarg);
+ 	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+ 	  break;
+ 
+@@ -585,7 +585,7 @@ main (int argc, char **argv)
+ 	case TABSIZE_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid tabsize `%s'", optarg);
++	    try_help ("invalid tabsize '%s'", optarg);
+ 	  if (tabsize != numval)
+ 	    {
+ 	      if (tabsize)
+@@ -744,9 +744,9 @@ main (int argc, char **argv)
+ 	  if (argc - optind != 2)
+ 	    {
+ 	      if (argc - optind < 2)
+-		try_help ("missing operand after `%s'", argv[argc - 1]);
++		try_help ("missing operand after '%s'", argv[argc - 1]);
+ 	      else
+-		try_help ("extra operand `%s'", argv[optind + 2]);
++		try_help ("extra operand '%s'", argv[optind + 2]);
+ 	    }
+ 
+ 	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+@@ -826,7 +826,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -874,7 +874,7 @@ static char const * const option_help_msgid[] = {
+   N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+   N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+   N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+-  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
++  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+   N_("  GFMT may contain:\n\
+     %<  lines from FILE1\n\
+     %>  lines from FILE2\n\
+@@ -895,7 +895,7 @@ static char const * const option_help_msgid[] = {
+     %c'C'  the single character C\n\
+     %c'\\OOO'  the character with octal code OOO"),
+   "",
+-  N_("-l  --paginate  Pass the output through `pr' to paginate it."),
++  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+   N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+   N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+@@ -918,9 +918,9 @@ static char const * const option_help_msgid[] = {
+   N_("-v  --version  Output version info."),
+   N_("--help  Output this help."),
+   "",
+-  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
++  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+   N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+-  N_("If a FILE is `-', read standard input."),
++  N_("If a FILE is '-', read standard input."),
+   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+   0
+ };
+@@ -960,7 +960,7 @@ specify_value (char const **var, char const *value, char const *option)
+ {
+   if (*var && strcmp (*var, value) != 0)
+     {
+-      error (0, 0, _("conflicting %s option value `%s'"), option, value);
++      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+       try_help (NULL, NULL);
+     }
+   *var = value;
+@@ -1159,7 +1159,7 @@ compare_files (struct comparison const *parent,
+ 	= dir_file_pathname (dir, last_component (fnm));
+ 
+       if (STREQ (fnm, "-"))
+-	fatal ("cannot compare `-' to a directory");
++	fatal ("cannot compare '-' to a directory");
+ 
+       if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+ 	{
+diff --git a/src/diff3.c b/src/diff3.c
+index 0f11fdc..885a194 100644
+--- a/src/diff3.c
++++ b/src/diff3.c
+@@ -316,9 +316,9 @@ main (int argc, char **argv)
+   if (argc - optind != 3)
+     {
+       if (argc - optind < 3)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 3]);
++	try_help ("extra operand '%s'", argv[optind + 3]);
+     }
+ 
+   file = &argv[optind];
+@@ -351,7 +351,7 @@ main (int argc, char **argv)
+ 	 file instead.  */
+       common = 3 - common;
+       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+-	fatal ("`-' specified for more than one input file");
++	fatal ("'-' specified for more than one input file");
+     }
+ 
+   mapping[0] = 0;
+@@ -412,7 +412,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -435,7 +435,7 @@ static char const * const option_help_msgid[] = {
+   "",
+   N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+   N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+-  N_("-i  Append `w' and `q' commands to ed scripts."),
++  N_("-i  Append 'w' and `q' commands to ed scripts."),
+   N_("-a  --text  Treat all files as text."),
+   N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+@@ -460,7 +460,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -1275,12 +1275,12 @@ read_diff (char const *filea,
+   if (EXIT_TROUBLE <= status)
+     error (EXIT_TROUBLE, werrno,
+ 	   _(status == 126
+-	     ? "subsidiary program `%s' could not be invoked"
++	     ? "subsidiary program '%s' could not be invoked"
+ 	     : status == 127
+-	     ? "subsidiary program `%s' not found"
++	     ? "subsidiary program '%s' not found"
+ 	     : status == INT_MAX
+-	     ? "subsidiary program `%s' failed"
+-	     : "subsidiary program `%s' failed (exit status %d)"),
++	     ? "subsidiary program '%s' failed"
++	     : "subsidiary program '%s' failed (exit status %d)"),
+ 	   diff_program, status);
+ 
+   return diff_result + total;
+diff --git a/src/dir.c b/src/dir.c
+index 5b4eaec..5e08318 100644
+--- a/src/dir.c
++++ b/src/dir.c
+@@ -154,7 +154,7 @@ compare_names (char const *name1, char const *name2)
+ 	r = strcoll (name1, name2);
+       if (errno)
+ 	{
+-	  error (0, errno, _("cannot compare file names `%s' and `%s'"),
++	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+ 		 name1, name2);
+ 	  longjmp (failed_locale_specific_sorting, 1);
+ 	}
+diff --git a/src/sdiff.c b/src/sdiff.c
+index 4344e8d..6ea6f0a 100644
+--- a/src/sdiff.c
++++ b/src/sdiff.c
+@@ -175,7 +175,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -230,7 +230,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -286,12 +286,12 @@ check_child_status (int werrno, int wstatus, int max_ok_status,
+     {
+       error (0, werrno,
+ 	     _(status == 126
+-	       ? "subsidiary program `%s' could not be invoked"
++	       ? "subsidiary program '%s' could not be invoked"
+ 	       : status == 127
+-	       ? "subsidiary program `%s' not found"
++	       ? "subsidiary program '%s' not found"
+ 	       : status == INT_MAX
+-	       ? "subsidiary program `%s' failed"
+-	       : "subsidiary program `%s' failed (exit status %d)"),
++	       ? "subsidiary program '%s' failed"
++	       : "subsidiary program '%s' failed (exit status %d)"),
+ 	     subsidiary_program, status);
+       exiterr ();
+     }
+@@ -572,9 +572,9 @@ main (int argc, char *argv[])
+   if (argc - optind != 2)
+     {
+       if (argc - optind < 2)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 2]);
++	try_help ("extra operand '%s'", argv[optind + 2]);
+     }
+ 
+   if (! output)
+diff --git a/src/util.c b/src/util.c
+index 3be03e9..d18bf38 100644
+--- a/src/util.c
++++ b/src/util.c
+@@ -298,12 +298,12 @@ finish_output (void)
+       if (status)
+ 	error (EXIT_TROUBLE, werrno,
+ 	       _(status == 126
+-		 ? "subsidiary program `%s' could not be invoked"
++		 ? "subsidiary program '%s' could not be invoked"
+ 		 : status == 127
+-		 ? "subsidiary program `%s' not found"
++		 ? "subsidiary program '%s' not found"
+ 		 : status == INT_MAX
+-		 ? "subsidiary program `%s' failed"
+-		 : "subsidiary program `%s' failed (exit status %d)"),
++		 ? "subsidiary program '%s' failed"
++		 : "subsidiary program '%s' failed (exit status %d)"),
+ 	       pr_program, status);
+     }
+ 
diff --git a/quote-3.0-patch.txt b/quote-3.0-patch.txt
new file mode 100644
index 0000000..22ca1a2
--- /dev/null
+++ b/quote-3.0-patch.txt
@@ -0,0 +1,321 @@
+diff --git a/src/cmp.c b/src/cmp.c
+index 2455dc4..e19f013 100644
+--- a/src/cmp.c
++++ b/src/cmp.c
+@@ -115,7 +115,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -134,7 +134,7 @@ specify_ignore_initial (int f, char **argptr, char delimiter)
+   if (! (e == LONGINT_OK
+ 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+       || TYPE_MAXIMUM (off_t) < val)
+-    try_help ("invalid --ignore-initial value `%s'", arg);
++    try_help ("invalid --ignore-initial value '%s'", arg);
+   if (ignore_initial[f] < val)
+     ignore_initial[f] = val;
+ }
+@@ -185,7 +185,7 @@ usage (void)
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+-	  _("If a FILE is `-' or missing, read standard input."),
++	  _("If a FILE is '-' or missing, read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -231,7 +231,7 @@ main (int argc, char **argv)
+ 	{
+ 	  uintmax_t n;
+ 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+-	    try_help ("invalid --bytes value `%s'", optarg);
++	    try_help ("invalid --bytes value '%s'", optarg);
+ 	  if (n < bytes)
+ 	    bytes = n;
+ 	}
+@@ -257,7 +257,7 @@ main (int argc, char **argv)
+       }
+ 
+   if (optind == argc)
+-    try_help ("missing operand after `%s'", argv[argc - 1]);
++    try_help ("missing operand after '%s'", argv[argc - 1]);
+ 
+   file[0] = argv[optind++];
+   file[1] = optind < argc ? argv[optind++] : "-";
+@@ -269,7 +269,7 @@ main (int argc, char **argv)
+     }
+ 
+   if (optind < argc)
+-    try_help ("extra operand `%s'", argv[optind]);
++    try_help ("extra operand '%s'", argv[optind]);
+ 
+   for (f = 0; f < 2; f++)
+     {
+diff --git a/src/diff.c b/src/diff.c
+index cc1b611..365bea0 100644
+--- a/src/diff.c
++++ b/src/diff.c
+@@ -330,7 +330,7 @@ main (int argc, char **argv)
+ 	      {
+ 		numval = strtoumax (optarg, &numend, 10);
+ 		if (*numend)
+-		  try_help ("invalid context length `%s'", optarg);
++		  try_help ("invalid context length '%s'", optarg);
+ 		if (LIN_MAX < numval)
+ 		  numval = LIN_MAX;
+ 	      }
+@@ -505,7 +505,7 @@ main (int argc, char **argv)
+ 	case 'W':
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid width `%s'", optarg);
++	    try_help ("invalid width '%s'", optarg);
+ 	  if (width != numval)
+ 	    {
+ 	      if (width)
+@@ -534,7 +534,7 @@ main (int argc, char **argv)
+ 	case HORIZON_LINES_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (*numend)
+-	    try_help ("invalid horizon length `%s'", optarg);
++	    try_help ("invalid horizon length '%s'", optarg);
+ 	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+ 	  break;
+ 
+@@ -585,7 +585,7 @@ main (int argc, char **argv)
+ 	case TABSIZE_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid tabsize `%s'", optarg);
++	    try_help ("invalid tabsize '%s'", optarg);
+ 	  if (tabsize != numval)
+ 	    {
+ 	      if (tabsize)
+@@ -744,9 +744,9 @@ main (int argc, char **argv)
+ 	  if (argc - optind != 2)
+ 	    {
+ 	      if (argc - optind < 2)
+-		try_help ("missing operand after `%s'", argv[argc - 1]);
++		try_help ("missing operand after '%s'", argv[argc - 1]);
+ 	      else
+-		try_help ("extra operand `%s'", argv[optind + 2]);
++		try_help ("extra operand '%s'", argv[optind + 2]);
+ 	    }
+ 
+ 	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+@@ -826,7 +826,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -874,7 +874,7 @@ static char const * const option_help_msgid[] = {
+   N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+   N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+   N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+-  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
++  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+   N_("  GFMT may contain:\n\
+     %<  lines from FILE1\n\
+     %>  lines from FILE2\n\
+@@ -895,7 +895,7 @@ static char const * const option_help_msgid[] = {
+     %c'C'  the single character C\n\
+     %c'\\OOO'  the character with octal code OOO"),
+   "",
+-  N_("-l  --paginate  Pass the output through `pr' to paginate it."),
++  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+   N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+   N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+@@ -918,9 +918,9 @@ static char const * const option_help_msgid[] = {
+   N_("-v  --version  Output version info."),
+   N_("--help  Output this help."),
+   "",
+-  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
++  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+   N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+-  N_("If a FILE is `-', read standard input."),
++  N_("If a FILE is '-', read standard input."),
+   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+   0
+ };
+@@ -960,7 +960,7 @@ specify_value (char const **var, char const *value, char const *option)
+ {
+   if (*var && strcmp (*var, value) != 0)
+     {
+-      error (0, 0, _("conflicting %s option value `%s'"), option, value);
++      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+       try_help (NULL, NULL);
+     }
+   *var = value;
+@@ -1159,7 +1159,7 @@ compare_files (struct comparison const *parent,
+ 	= dir_file_pathname (dir, last_component (fnm));
+ 
+       if (STREQ (fnm, "-"))
+-	fatal ("cannot compare `-' to a directory");
++	fatal ("cannot compare '-' to a directory");
+ 
+       if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+ 	{
+diff --git a/src/diff3.c b/src/diff3.c
+index 0f11fdc..885a194 100644
+--- a/src/diff3.c
++++ b/src/diff3.c
+@@ -316,9 +316,9 @@ main (int argc, char **argv)
+   if (argc - optind != 3)
+     {
+       if (argc - optind < 3)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 3]);
++	try_help ("extra operand '%s'", argv[optind + 3]);
+     }
+ 
+   file = &argv[optind];
+@@ -351,7 +351,7 @@ main (int argc, char **argv)
+ 	 file instead.  */
+       common = 3 - common;
+       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+-	fatal ("`-' specified for more than one input file");
++	fatal ("'-' specified for more than one input file");
+     }
+ 
+   mapping[0] = 0;
+@@ -412,7 +412,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -435,7 +435,7 @@ static char const * const option_help_msgid[] = {
+   "",
+   N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+   N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+-  N_("-i  Append `w' and `q' commands to ed scripts."),
++  N_("-i  Append 'w' and `q' commands to ed scripts."),
+   N_("-a  --text  Treat all files as text."),
+   N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+@@ -460,7 +460,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -1275,12 +1275,12 @@ read_diff (char const *filea,
+   if (EXIT_TROUBLE <= status)
+     error (EXIT_TROUBLE, werrno,
+ 	   _(status == 126
+-	     ? "subsidiary program `%s' could not be invoked"
++	     ? "subsidiary program '%s' could not be invoked"
+ 	     : status == 127
+-	     ? "subsidiary program `%s' not found"
++	     ? "subsidiary program '%s' not found"
+ 	     : status == INT_MAX
+-	     ? "subsidiary program `%s' failed"
+-	     : "subsidiary program `%s' failed (exit status %d)"),
++	     ? "subsidiary program '%s' failed"
++	     : "subsidiary program '%s' failed (exit status %d)"),
+ 	   diff_program, status);
+ 
+   return diff_result + total;
+diff --git a/src/dir.c b/src/dir.c
+index 5b4eaec..5e08318 100644
+--- a/src/dir.c
++++ b/src/dir.c
+@@ -154,7 +154,7 @@ compare_names (char const *name1, char const *name2)
+ 	r = strcoll (name1, name2);
+       if (errno)
+ 	{
+-	  error (0, errno, _("cannot compare file names `%s' and `%s'"),
++	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+ 		 name1, name2);
+ 	  longjmp (failed_locale_specific_sorting, 1);
+ 	}
+diff --git a/src/sdiff.c b/src/sdiff.c
+index 4344e8d..6ea6f0a 100644
+--- a/src/sdiff.c
++++ b/src/sdiff.c
+@@ -175,7 +175,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -230,7 +230,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -286,12 +286,12 @@ check_child_status (int werrno, int wstatus, int max_ok_status,
+     {
+       error (0, werrno,
+ 	     _(status == 126
+-	       ? "subsidiary program `%s' could not be invoked"
++	       ? "subsidiary program '%s' could not be invoked"
+ 	       : status == 127
+-	       ? "subsidiary program `%s' not found"
++	       ? "subsidiary program '%s' not found"
+ 	       : status == INT_MAX
+-	       ? "subsidiary program `%s' failed"
+-	       : "subsidiary program `%s' failed (exit status %d)"),
++	       ? "subsidiary program '%s' failed"
++	       : "subsidiary program '%s' failed (exit status %d)"),
+ 	     subsidiary_program, status);
+       exiterr ();
+     }
+@@ -572,9 +572,9 @@ main (int argc, char *argv[])
+   if (argc - optind != 2)
+     {
+       if (argc - optind < 2)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 2]);
++	try_help ("extra operand '%s'", argv[optind + 2]);
+     }
+ 
+   if (! output)
+diff --git a/src/util.c b/src/util.c
+index 3be03e9..d18bf38 100644
+--- a/src/util.c
++++ b/src/util.c
+@@ -298,12 +298,12 @@ finish_output (void)
+       if (status)
+ 	error (EXIT_TROUBLE, werrno,
+ 	       _(status == 126
+-		 ? "subsidiary program `%s' could not be invoked"
++		 ? "subsidiary program '%s' could not be invoked"
+ 		 : status == 127
+-		 ? "subsidiary program `%s' not found"
++		 ? "subsidiary program '%s' not found"
+ 		 : status == INT_MAX
+-		 ? "subsidiary program `%s' failed"
+-		 : "subsidiary program `%s' failed (exit status %d)"),
++		 ? "subsidiary program '%s' failed"
++		 : "subsidiary program '%s' failed (exit status %d)"),
+ 	       pr_program, status);
+     }
+ 
diff --git a/quote-3.0-test.txt b/quote-3.0-test.txt
new file mode 100644
index 0000000..a6f9076
--- /dev/null
+++ b/quote-3.0-test.txt
@@ -0,0 +1,5080 @@
+Only in diffutils-3.0: quote-3.0-test.txt
+diff -pru diffutils-3.0/src/analyze.c diffutils-3.0-patch/src/analyze.c
+--- diffutils-3.0/src/analyze.c	2018-06-07 18:22:43.432128000 -0700
++++ diffutils-3.0-patch/src/analyze.c	2018-06-07 18:20:57.347085000 -0700
+@@ -1,7 +1,7 @@
+ /* Analyze file differences for GNU DIFF.
+ 
+    Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+-   2009-2013, 2015-2018 Free Software Foundation, Inc.
++   2009-2010 Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -38,7 +38,7 @@
+ 
+    A line which is discarded will not be considered by the actual
+    comparison algorithm; it will be as if that line were not in the file.
+-   The file's 'realindexes' table maps virtual line numbers
++   The file's `realindexes' table maps virtual line numbers
+    (which don't count the discarded lines) into real line numbers;
+    this is how the actual comparison algorithm produces results
+    that are comprehensible when the discarded lines are counted.
+@@ -251,7 +251,7 @@ discard_confusing_lines (struct file_dat
+    We do something when a run of changed lines include a
+    line at one end and have an excluded, identical line at the other.
+    We are free to choose which identical line is included.
+-   'compareseq' usually chooses the one at the beginning,
++   `compareseq' usually chooses the one at the beginning,
+    but usually it is cleaner to consider the following identical line
+    to be the "change".  */
+ 
+@@ -445,16 +445,26 @@ build_script (struct file_data const fil
+   return script;
+ }
+ 
+-/* If CHANGES, briefly report that two files differed.  */
+-static void
++/* If CHANGES, briefly report that two files differed.
++   Return 2 if trouble, CHANGES otherwise.  */
++static int
+ briefly_report (int changes, struct file_data const filevec[])
+ {
+   if (changes)
+-    message ((brief
+-	      ? _("Files %s and %s differ\n")
+-	      : _("Binary files %s and %s differ\n")),
+-	     file_label[0] ? file_label[0] : filevec[0].name,
+-	     file_label[1] ? file_label[1] : filevec[1].name);
++    {
++      char const *label0 = file_label[0] ? file_label[0] : filevec[0].name;
++      char const *label1 = file_label[1] ? file_label[1] : filevec[1].name;
++
++      if (brief)
++	message ("Files %s and %s differ\n", label0, label1);
++      else
++	{
++	  message ("Binary files %s and %s differ\n", label0, label1);
++	  changes = 2;
++	}
++    }
++
++  return changes;
+ }
+ 
+ /* Report the differences of two files.  */
+@@ -477,8 +487,6 @@ diff_2_files (struct comparison *cmp)
+     {
+       /* Files with different lengths must be different.  */
+       if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
+-	  && 0 < cmp->file[0].stat.st_size
+-	  && 0 < cmp->file[1].stat.st_size
+ 	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+ 	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+ 	changes = 1;
+@@ -528,7 +536,7 @@ diff_2_files (struct comparison *cmp)
+ 	    }
+ 	}
+ 
+-      briefly_report (changes, cmp->file);
++      changes = briefly_report (changes, cmp->file);
+     }
+   else
+     {
+@@ -566,13 +574,12 @@ diff_2_files (struct comparison *cmp)
+ 
+       ctxt.heuristic = speed_large_files;
+ 
+-      /* Set TOO_EXPENSIVE to be the approximate square root of the
+-	 input size, bounded below by 4096.  4096 seems to be good for
+-	 circa-2016 CPUs; see Bug#16848 and Bug#24715.  */
++      /* Set TOO_EXPENSIVE to be approximate square root of input size,
++	 bounded below by 256.  */
+       too_expensive = 1;
+       for (;  diags != 0;  diags >>= 2)
+ 	too_expensive <<= 1;
+-      ctxt.too_expensive = MAX (4096, too_expensive);
++      ctxt.too_expensive = MAX (256, too_expensive);
+ 
+       files[0] = cmp->file[0];
+       files[1] = cmp->file[1];
+@@ -588,7 +595,7 @@ diff_2_files (struct comparison *cmp)
+       shift_boundaries (cmp->file);
+ 
+       /* Get the results of comparison in the form of a chain
+-	 of 'struct change's -- an edit script.  */
++	 of `struct change's -- an edit script.  */
+ 
+       if (output_style == OUTPUT_ED)
+ 	script = build_reverse_script (cmp->file);
+@@ -628,7 +635,7 @@ diff_2_files (struct comparison *cmp)
+ 	changes = (script != 0);
+ 
+       if (brief)
+-	briefly_report (changes, cmp->file);
++	changes = briefly_report (changes, cmp->file);
+       else
+ 	{
+ 	  if (changes || !no_diff_means_no_output)
+Only in diffutils-3.0-patch/src: analyze.o
+Only in diffutils-3.0-patch/src: cmp
+diff -pru diffutils-3.0/src/cmp.c diffutils-3.0-patch/src/cmp.c
+--- diffutils-3.0/src/cmp.c	2018-06-07 18:22:43.434128000 -0700
++++ diffutils-3.0-patch/src/cmp.c	2018-06-07 18:20:57.327091000 -0700
+@@ -1,7 +1,7 @@
+-/* GNU cmp - compare two files byte by byte
++/* cmp - compare two files byte by byte
+ 
+-   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+@@ -23,7 +23,6 @@
+ 
+ #include <c-stack.h>
+ #include <cmpbuf.h>
+-#include "die.h"
+ #include <error.h>
+ #include <exitfail.h>
+ #include <file-type.h>
+@@ -34,10 +33,10 @@
+ #include <unlocked-io.h>
+ #include <version-etc.h>
+ #include <xalloc.h>
+-#include <binary-io.h>
++#include <xfreopen.h>
+ #include <xstrtol.h>
+ 
+-/* The official name of this program (e.g., no 'g' prefix).  */
++/* The official name of this program (e.g., no `g' prefix).  */
+ #define PROGRAM_NAME "cmp"
+ 
+ #define AUTHORS \
+@@ -52,8 +51,8 @@
+ 
+ static int cmp (void);
+ static off_t file_position (int);
+-static size_t block_compare (word const *, word const *) _GL_ATTRIBUTE_PURE;
+-static size_t count_newlines (char *, size_t);
++static size_t block_compare (word const *, word const *);
++static size_t block_compare_and_count (word const *, word const *, off_t *);
+ static void sprintc (char *, unsigned char);
+ 
+ /* Filenames of the compared files.  */
+@@ -115,8 +114,9 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  die (EXIT_TROUBLE, 0,
++  error (EXIT_TROUBLE, 0,
+ 	 _("Try '%s --help' for more information."), program_name);
++  abort ();
+ }
+ 
+ static char const valid_suffixes[] = "kKMGTPEZY0";
+@@ -152,21 +152,21 @@ static void
+ check_stdout (void)
+ {
+   if (ferror (stdout))
+-    die (EXIT_TROUBLE, 0, "%s", _("write failed"));
++    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+   else if (fclose (stdout) != 0)
+-    die (EXIT_TROUBLE, errno, "%s", _("standard output"));
++    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+ }
+ 
+ static char const * const option_help_msgid[] = {
+-  N_("-b, --print-bytes          print differing bytes"),
+-  N_("-i, --ignore-initial=SKIP         skip first SKIP bytes of both inputs"),
+-  N_("-i, --ignore-initial=SKIP1:SKIP2  skip first SKIP1 bytes of FILE1 and\n"
+-     "                                      first SKIP2 bytes of FILE2"),
+-  N_("-l, --verbose              output byte numbers and differing byte values"),
+-  N_("-n, --bytes=LIMIT          compare at most LIMIT bytes"),
+-  N_("-s, --quiet, --silent      suppress all normal output"),
+-  N_("    --help                 display this help and exit"),
+-  N_("-v, --version              output version information and exit"),
++  N_("-b  --print-bytes  Print differing bytes."),
++  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
++  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
++  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
++  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
++  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
++  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
++  N_("-v  --version  Output version info."),
++  N_("--help  Output this help."),
+   0
+ };
+ 
+@@ -177,17 +177,11 @@ usage (void)
+ 
+   printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+ 	  program_name);
+-  printf ("%s\n", _("Compare two files byte by byte."));
+-  printf ("\n%s\n\n",
+-_("The optional SKIP1 and SKIP2 specify the number of bytes to skip\n"
+-  "at the beginning of each file (zero by default)."));
+-
+-  fputs (_("\
+-Mandatory arguments to long options are mandatory for short options too.\n\
+-"), stdout);
++  printf ("%s\n\n", _("Compare two files byte by byte."));
+   for (p = option_help_msgid;  *p;  p++)
+     printf ("  %s\n", _(*p));
+-  printf ("\n%s\n\n%s\n%s\n",
++  printf ("\n%s\n%s\n\n%s\n%s\n",
++	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+@@ -248,7 +242,7 @@ main (int argc, char **argv)
+ 	break;
+ 
+       case 'v':
+-	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
++	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+ 		     AUTHORS, (char *) NULL);
+ 	check_stdout ();
+ 	return EXIT_SUCCESS;
+@@ -293,7 +287,7 @@ main (int argc, char **argv)
+ 	{
+ 	  file_desc[f1] = STDIN_FILENO;
+ 	  if (O_BINARY && ! isatty (STDIN_FILENO))
+-	    set_binary_mode (STDIN_FILENO, O_BINARY);
++	    xfreopen (NULL, "rb", stdin);
+ 	}
+       else
+ 	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+@@ -303,7 +297,7 @@ main (int argc, char **argv)
+ 	  if (file_desc[f1] < 0 && comparison_type == type_status)
+ 	    exit (EXIT_TROUBLE);
+ 	  else
+-	    die (EXIT_TROUBLE, errno, "%s", file[f1]);
++	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+ 	}
+     }
+ 
+@@ -363,28 +357,27 @@ main (int argc, char **argv)
+ 
+   for (f = 0; f < 2; f++)
+     if (close (file_desc[f]) != 0)
+-      die (EXIT_TROUBLE, errno, "%s", file[f]);
++      error (EXIT_TROUBLE, errno, "%s", file[f]);
+   if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+     check_stdout ();
+   exit (exit_status);
+   return exit_status;
+ }
+ 
+-/* Compare the two files already open on 'file_desc[0]' and 'file_desc[1]',
+-   using 'buffer[0]' and 'buffer[1]'.
++/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
++   using `buffer[0]' and `buffer[1]'.
+    Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+    >1 if error.  */
+ 
+ static int
+ cmp (void)
+ {
+-  bool at_line_start = true;
+   off_t line_number = 1;	/* Line number (1...) of difference. */
+   off_t byte_number = 1;	/* Byte number (1...) of difference. */
+   uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+   size_t read0, read1;		/* Number of bytes read from each file. */
+   size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+-  size_t smaller;		/* The lesser of 'read0' and 'read1'. */
++  size_t smaller;		/* The lesser of `read0' and `read1'. */
+   word *buffer0 = buffer[0];
+   word *buffer1 = buffer[1];
+   char *buf0 = (char *) buffer0;
+@@ -422,7 +415,7 @@ cmp (void)
+ 	      if (r != bytes_to_read)
+ 		{
+ 		  if (r == SIZE_MAX)
+-		    die (EXIT_TROUBLE, errno, "%s", file[f]);
++		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+ 		  break;
+ 		}
+ 	      ig -= r;
+@@ -444,31 +437,25 @@ cmp (void)
+ 
+       read0 = block_read (file_desc[0], buf0, bytes_to_read);
+       if (read0 == SIZE_MAX)
+-	die (EXIT_TROUBLE, errno, "%s", file[0]);
++	error (EXIT_TROUBLE, errno, "%s", file[0]);
+       read1 = block_read (file_desc[1], buf1, bytes_to_read);
+       if (read1 == SIZE_MAX)
+-	die (EXIT_TROUBLE, errno, "%s", file[1]);
++	error (EXIT_TROUBLE, errno, "%s", file[1]);
+ 
+-      smaller = MIN (read0, read1);
++      /* Insert sentinels for the block compare.  */
+ 
+-      /* Optimize the common case where the buffers are the same.  */
+-      if (memcmp (buf0, buf1, smaller) == 0)
+-	first_diff = smaller;
+-      else
+-	{
+-	  /* Insert sentinels for the block compare.  */
+-	  buf0[read0] = ~buf1[read0];
+-	  buf1[read1] = ~buf0[read1];
++      buf0[read0] = ~buf1[read0];
++      buf1[read1] = ~buf0[read1];
+ 
+-	  first_diff = block_compare (buffer0, buffer1);
+-	}
++      /* If the line number should be written for differing files,
++	 compare the blocks and count the number of newlines
++	 simultaneously.  */
++      first_diff = (comparison_type == type_first_diff
++		    ? block_compare_and_count (buffer0, buffer1, &line_number)
++		    : block_compare (buffer0, buffer1));
+ 
+       byte_number += first_diff;
+-      if (comparison_type == type_first_diff && first_diff != 0)
+-	{
+-	  line_number += count_newlines (buf0, first_diff);
+-	  at_line_start = buf0[first_diff - 1] == '\n';
+-	}
++      smaller = MIN (read0, read1);
+ 
+       if (first_diff < smaller)
+ 	{
+@@ -482,9 +469,9 @@ cmp (void)
+ 		char const *line_num = offtostr (line_number, line_buf);
+ 		if (!opt_print_bytes)
+ 		  {
+-		    /* See POSIX for this format.  This message is
+-		       used only in the POSIX locale, so it need not
+-		       be translated.  */
++		    /* See POSIX 1003.1-2001 for this format.  This
++		       message is used only in the POSIX locale, so it
++		       need not be translated.  */
+ 		    static char const char_message[] =
+ 		      "%s %s differ: char %s, line %s\n";
+ 
+@@ -514,9 +501,9 @@ cmp (void)
+ 		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+ 			    file[0], file[1], byte_num, line_num,
+ 			    c0, s0, c1, s1);
+-		  }
++		}
+ 	      }
+-	      FALLTHROUGH;
++	      /* Fall through.  */
+ 	    case type_status:
+ 	      return EXIT_FAILURE;
+ 
+@@ -531,7 +518,7 @@ cmp (void)
+ 		      char const *byte_num = offtostr (byte_number, byte_buf);
+ 		      if (!opt_print_bytes)
+ 			{
+-			  /* See POSIX for this format.  */
++			  /* See POSIX 1003.1-2001 for this format.  */
+ 			  printf ("%*s %3o %3o\n",
+ 				  offset_width, byte_num, c0, c1);
+ 			}
+@@ -562,36 +549,8 @@ cmp (void)
+ 	{
+ 	  if (differing <= 0 && comparison_type != type_status)
+ 	    {
+-	      char const *shorter_file = file[read1 < read0];
+-
+-	      /* POSIX says that each of these format strings must be
+-		 "cmp: EOF on %s", optionally followed by a blank and
+-		 extra text sans newline, then terminated by "\n".  */
+-	      if (byte_number == 1)
+-		fprintf (stderr, _("cmp: EOF on %s which is empty\n"),
+-			 shorter_file);
+-	      else
+-		{
+-		  char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+-		  char const *byte_num = offtostr (byte_number - 1, byte_buf);
+-
+-		  if (comparison_type == type_first_diff)
+-		    {
+-		      char line_buf[INT_BUFSIZE_BOUND (off_t)];
+-		      char const *line_num
+-			= offtostr (line_number - at_line_start, line_buf);
+-		      fprintf (stderr,
+-			       (at_line_start
+-				? _("cmp: EOF on %s after byte %s, line %s\n")
+-				: _("cmp: EOF on %s after byte %s,"
+-				    " in line %s\n")),
+-			       shorter_file, byte_num, line_num);
+-		    }
+-		  else
+-		    fprintf (stderr,
+-			     _("cmp: EOF on %s after byte %s\n"),
+-			     shorter_file, byte_num);
+-		}
++	      /* See POSIX 1003.1-2001 for this format.  */
++	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+ 	    }
+ 
+ 	  return EXIT_FAILURE;
+@@ -602,6 +561,54 @@ cmp (void)
+   return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+ }
+ 
++/* Compare two blocks of memory P0 and P1 until they differ,
++   and count the number of '\n' occurrences in the common
++   part of P0 and P1.
++   If the blocks are not guaranteed to be different, put sentinels at the ends
++   of the blocks before calling this function.
++
++   Return the offset of the first byte that differs.
++   Increment *COUNT by the count of '\n' occurrences.  */
++
++static size_t
++block_compare_and_count (word const *p0, word const *p1, off_t *count)
++{
++  word l;		/* One word from first buffer. */
++  word const *l0, *l1;	/* Pointers into each buffer. */
++  char const *c0, *c1;	/* Pointers for finding exact address. */
++  size_t cnt = 0;	/* Number of '\n' occurrences. */
++  word nnnn;		/* Newline, sizeof (word) times.  */
++  int i;
++
++  nnnn = 0;
++  for (i = 0; i < sizeof nnnn; i++)
++    nnnn = (nnnn << CHAR_BIT) | '\n';
++
++  /* Find the rough position of the first difference by reading words,
++     not bytes.  */
++
++  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
++    {
++      l ^= nnnn;
++      for (i = 0; i < sizeof l; i++)
++	{
++	  unsigned char uc = l;
++	  cnt += ! uc;
++	  l >>= CHAR_BIT;
++	}
++    }
++
++  /* Find the exact differing position (endianness independent).  */
++
++  for (c0 = (char const *) l0, c1 = (char const *) l1;
++       *c0 == *c1;
++       c0++, c1++)
++    cnt += *c0 == '\n';
++
++  *count += cnt;
++  return c0 - (char const *) p0;
++}
++
+ /* Compare two blocks of memory P0 and P1 until they differ.
+    If the blocks are not guaranteed to be different, put sentinels at the ends
+    of the blocks before calling this function.
+@@ -630,21 +637,6 @@ block_compare (word const *p0, word cons
+   return c0 - (char const *) p0;
+ }
+ 
+-/* Return the number of newlines in BUF, of size BUFSIZE,
+-   where BUF[NBYTES] is available for use as a sentinel.  */
+-
+-static size_t
+-count_newlines (char *buf, size_t bufsize)
+-{
+-  size_t count = 0;
+-  char *p;
+-  char *lim = buf + bufsize;
+-  *lim = '\n';
+-  for (p = buf; (p = rawmemchr (p, '\n')) != lim; p++)
+-    count++;
+-  return count;
+-}
+-
+ /* Put into BUF the unsigned char C, making unprintable bytes
+    visible by quoting like cat -t does.  */
+ 
+Only in diffutils-3.0-patch/src: cmp.o
+diff -pru diffutils-3.0/src/context.c diffutils-3.0-patch/src/context.c
+--- diffutils-3.0/src/context.c	2018-06-07 18:22:43.435129000 -0700
++++ diffutils-3.0-patch/src/context.c	2018-06-07 18:20:57.329084000 -0700
+@@ -1,7 +1,7 @@
+ /* Context-format output routines for GNU DIFF.
+ 
+-   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -20,6 +20,7 @@
+ 
+ #include "diff.h"
+ #include "c-ctype.h"
++#include <inttostr.h>
+ #include <stat-time.h>
+ #include <strftime.h>
+ 
+@@ -40,7 +41,6 @@ static lin find_function_last_match;
+ static void
+ print_context_label (char const *mark,
+ 		     struct file_data *inf,
+-		     char const *name,
+ 		     char const *label)
+ {
+   if (label)
+@@ -71,27 +71,25 @@ print_context_label (char const *mark,
+ 	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+ 	    }
+ 	}
+-      fprintf (outfile, "%s %s\t%s\n", mark, name, buf);
++      fprintf (outfile, "%s %s\t%s\n", mark, inf->name, buf);
+     }
+ }
+ 
+ /* Print a header for a context diff, with the file names and dates.  */
+ 
+ void
+-print_context_header (struct file_data inf[], char const *const *names, bool unidiff)
++print_context_header (struct file_data inf[], bool unidiff)
+ {
+-  set_color_context (HEADER_CONTEXT);
+   if (unidiff)
+     {
+-      print_context_label ("---", &inf[0], names[0], file_label[0]);
+-      print_context_label ("+++", &inf[1], names[1], file_label[1]);
++      print_context_label ("---", &inf[0], file_label[0]);
++      print_context_label ("+++", &inf[1], file_label[1]);
+     }
+   else
+     {
+-      print_context_label ("***", &inf[0], names[0], file_label[0]);
+-      print_context_label ("---", &inf[1], names[1], file_label[1]);
++      print_context_label ("***", &inf[0], file_label[0]);
++      print_context_label ("---", &inf[1], file_label[1]);
+     }
+-  set_color_context (RESET_CONTEXT);
+ }
+ 
+ /* Print an edit script in context format.  */
+@@ -126,7 +124,7 @@ print_context_script (struct change *scr
+ static void
+ print_context_number_range (struct file_data const *file, lin a, lin b)
+ {
+-  printint trans_a, trans_b;
++  long int trans_a, trans_b;
+   translate_range (file, a, b, &trans_a, &trans_b);
+ 
+   /* We can have B <= A in the case of a range of no lines.
+@@ -139,9 +137,9 @@ print_context_number_range (struct file_
+      specification.  */
+ 
+   if (trans_b <= trans_a)
+-    fprintf (outfile, "%"pI"d", trans_b);
++    fprintf (outfile, "%ld", trans_b);
+   else
+-    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b);
++    fprintf (outfile, "%ld,%ld", trans_a, trans_b);
+ }
+ 
+ /* Print FUNCTION in a context header.  */
+@@ -161,7 +159,7 @@ print_context_function (FILE *out, char
+ 
+ /* Print a portion of an edit script in context format.
+    HUNK is the beginning of the portion to be printed.
+-   The end is marked by a 'link' that has been nulled out.
++   The end is marked by a `link' that has been nulled out.
+ 
+    Prints out lines from both files, and precedes each
+    line with the appropriate flag-character.  */
+@@ -207,21 +205,14 @@ pr_context_hunk (struct change *hunk)
+   if (function)
+     print_context_function (out, function);
+ 
+-  putc ('\n', out);
+-  set_color_context (LINE_NUMBER_CONTEXT);
+-  fputs ("*** ", out);
++  fputs ("\n*** ", out);
+   print_context_number_range (&files[0], first0, last0);
+-  fputs (" ****", out);
+-  set_color_context (RESET_CONTEXT);
+-  putc ('\n', out);
++  fputs (" ****\n", out);
+ 
+   if (changes & OLD)
+     {
+       struct change *next = hunk;
+ 
+-      if (first0 <= last0)
+-        set_color_context (DELETE_CONTEXT);
+-
+       for (i = first0; i <= last0; i++)
+ 	{
+ 	  /* Skip past changes that apply (in file 0)
+@@ -234,34 +225,23 @@ pr_context_hunk (struct change *hunk)
+ 
+ 	  prefix = " ";
+ 	  if (next && next->line0 <= i)
+-            {
+-              /* The change NEXT covers this line.
+-                 If lines were inserted here in file 1, this is "changed".
+-                 Otherwise it is "deleted".  */
+-              prefix = (next->inserted > 0 ? "!" : "-");
+-            }
+-	  print_1_line_nl (prefix, &files[0].linbuf[i], true);
+-          if (i == last0)
+-            set_color_context (RESET_CONTEXT);
+-          if (files[0].linbuf[i + 1][-1] == '\n')
+-            putc ('\n', out);
++	    /* The change NEXT covers this line.
++	       If lines were inserted here in file 1, this is "changed".
++	       Otherwise it is "deleted".  */
++	    prefix = (next->inserted > 0 ? "!" : "-");
++
++	  print_1_line (prefix, &files[0].linbuf[i]);
+ 	}
+     }
+ 
+-  set_color_context (LINE_NUMBER_CONTEXT);
+   fputs ("--- ", out);
+   print_context_number_range (&files[1], first1, last1);
+-  fputs (" ----", out);
+-  set_color_context (RESET_CONTEXT);
+-  putc ('\n', out);
++  fputs (" ----\n", out);
+ 
+   if (changes & NEW)
+     {
+       struct change *next = hunk;
+ 
+-      if (first1 <= last1)
+-        set_color_context (ADD_CONTEXT);
+-
+       for (i = first1; i <= last1; i++)
+ 	{
+ 	  /* Skip past changes that apply (in file 1)
+@@ -274,17 +254,12 @@ pr_context_hunk (struct change *hunk)
+ 
+ 	  prefix = " ";
+ 	  if (next && next->line1 <= i)
+-            {
+-              /* The change NEXT covers this line.
+-                 If lines were deleted here in file 0, this is "changed".
+-                 Otherwise it is "inserted".  */
+-              prefix = (next->deleted > 0 ? "!" : "+");
+-            }
+-	  print_1_line_nl (prefix, &files[1].linbuf[i], true);
+-          if (i == last1)
+-            set_color_context (RESET_CONTEXT);
+-          if (files[1].linbuf[i + 1][-1] == '\n')
+-            putc ('\n', out);
++	    /* The change NEXT covers this line.
++	       If lines were deleted here in file 0, this is "changed".
++	       Otherwise it is "inserted".  */
++	    prefix = (next->deleted > 0 ? "!" : "+");
++
++	  print_1_line (prefix, &files[1].linbuf[i]);
+ 	}
+     }
+ }
+@@ -299,7 +274,7 @@ pr_context_hunk (struct change *hunk)
+ static void
+ print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+ {
+-  printint trans_a, trans_b;
++  long int trans_a, trans_b;
+   translate_range (file, a, b, &trans_a, &trans_b);
+ 
+   /* We can have B < A in the case of a range of no lines.
+@@ -307,14 +282,14 @@ print_unidiff_number_range (struct file_
+      which is B.  It would be more logical to print A, but
+      'patch' expects B in order to detect diffs against empty files.  */
+   if (trans_b <= trans_a)
+-    fprintf (outfile, trans_b < trans_a ? "%"pI"d,0" : "%"pI"d", trans_b);
++    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
+   else
+-    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b - trans_a + 1);
++    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
+ }
+ 
+ /* Print a portion of an edit script in unidiff format.
+    HUNK is the beginning of the portion to be printed.
+-   The end is marked by a 'link' that has been nulled out.
++   The end is marked by a `link' that has been nulled out.
+ 
+    Prints out lines from both files, and precedes each
+    line with the appropriate flag-character.  */
+@@ -355,13 +330,11 @@ pr_unidiff_hunk (struct change *hunk)
+   begin_output ();
+   out = outfile;
+ 
+-  set_color_context (LINE_NUMBER_CONTEXT);
+   fputs ("@@ -", out);
+   print_unidiff_number_range (&files[0], first0, last0);
+   fputs (" +", out);
+   print_unidiff_number_range (&files[1], first1, last1);
+   fputs (" @@", out);
+-  set_color_context (RESET_CONTEXT);
+ 
+   if (function)
+     print_context_function (out, function);
+@@ -390,43 +363,25 @@ pr_unidiff_hunk (struct change *hunk)
+ 	  /* For each difference, first output the deleted part. */
+ 
+ 	  k = next->deleted;
+-          if (k)
+-            set_color_context (DELETE_CONTEXT);
+-
+ 	  while (k--)
+ 	    {
+ 	      char const * const *line = &files[0].linbuf[i++];
+ 	      putc ('-', out);
+ 	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+ 		putc ('\t', out);
+-	      print_1_line_nl (NULL, line, true);
+-
+-              if (!k)
+-                set_color_context (RESET_CONTEXT);
+-
+-              if (line[1][-1] == '\n')
+-                putc ('\n', out);
++	      print_1_line (NULL, line);
+ 	    }
+ 
+ 	  /* Then output the inserted part. */
+ 
+ 	  k = next->inserted;
+-          if (k)
+-            set_color_context (ADD_CONTEXT);
+-
+-          while (k--)
++	  while (k--)
+ 	    {
+ 	      char const * const *line = &files[1].linbuf[j++];
+ 	      putc ('+', out);
+ 	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+ 		putc ('\t', out);
+-	      print_1_line_nl (NULL, line, true);
+-
+-              if (!k)
+-                set_color_context (RESET_CONTEXT);
+-
+-              if (line[1][-1] == '\n')
+-                putc ('\n', out);
++	      print_1_line (NULL, line);
+ 	    }
+ 
+ 	  /* We're done with this hunk, so on to the next! */
+@@ -438,20 +393,21 @@ pr_unidiff_hunk (struct change *hunk)
+ 
+ /* Scan a (forward-ordered) edit script for the first place that more than
+    2*CONTEXT unchanged lines appear, and return a pointer
+-   to the 'struct change' for the last change before those lines.  */
++   to the `struct change' for the last change before those lines.  */
+ 
+-static struct change * _GL_ATTRIBUTE_PURE
++static struct change *
+ find_hunk (struct change *start)
+ {
+   struct change *prev;
+   lin top0, top1;
+   lin thresh;
+ 
+-  /* Threshold distance is CONTEXT if the second change is ignorable,
+-     2 * CONTEXT + 1 otherwise.  Integer overflow can't happen, due
+-     to CONTEXT_LIM.  */
++  /* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable
++     changes, but only CONTEXT if one is ignorable.  Watch out for
++     integer overflow, though.  */
++  lin non_ignorable_threshold =
++    (LIN_MAX - 1) / 2 < context ? LIN_MAX : 2 * context + 1;
+   lin ignorable_threshold = context;
+-  lin non_ignorable_threshold = 2 * context + 1;
+ 
+   do
+     {
+@@ -460,7 +416,7 @@ find_hunk (struct change *start)
+       top1 = start->line1 + start->inserted;
+       prev = start;
+       start = start->link;
+-      thresh = (start && start->ignore
++      thresh = (prev->ignore || (start && start->ignore)
+ 		? ignorable_threshold
+ 		: non_ignorable_threshold);
+       /* It is not supposed to matter which file we check in the end-test.
+@@ -475,7 +431,7 @@ find_hunk (struct change *start)
+   return prev;
+ }
+ 
+-/* Set the 'ignore' flag properly in each change in SCRIPT.
++/* Set the `ignore' flag properly in each change in SCRIPT.
+    It should be 1 if all the lines inserted or deleted in that change
+    are ignorable lines.  */
+ 
+@@ -503,7 +459,7 @@ mark_ignorable (struct change *script)
+ }
+ 
+ /* Find the last function-header line in LINBUF prior to line number LINENUM.
+-   This is a line containing a match for the regexp in 'function_regexp'.
++   This is a line containing a match for the regexp in `function_regexp'.
+    Return the address of the text, or NULL if no function-header is found.  */
+ 
+ static char const *
+Only in diffutils-3.0-patch/src: context.o
+Only in diffutils-3.0-patch/src: .deps
+Only in diffutils-3.0/src: die.h
+Only in diffutils-3.0-patch/src: diff
+Only in diffutils-3.0-patch/src: diff3
+diff -pru diffutils-3.0/src/diff3.c diffutils-3.0-patch/src/diff3.c
+--- diffutils-3.0/src/diff3.c	2018-06-07 18:22:43.442130000 -0700
++++ diffutils-3.0-patch/src/diff3.c	2018-06-07 18:20:57.332083000 -0700
+@@ -1,7 +1,7 @@
+-/* GNU diff3 - compare three files line by line
++/* diff3 - compare three files line by line
+ 
+-   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+@@ -24,18 +24,18 @@
+ 
+ #include <c-stack.h>
+ #include <cmpbuf.h>
+-#include "die.h"
+ #include <error.h>
+ #include <exitfail.h>
+ #include <file-type.h>
+ #include <getopt.h>
++#include <inttostr.h>
+ #include <progname.h>
+-#include <system-quote.h>
++#include <sh-quote.h>
+ #include <version-etc.h>
+ #include <xalloc.h>
+ #include <xfreopen.h>
+ 
+-/* The official name of this program (e.g., no 'g' prefix).  */
++/* The official name of this program (e.g., no `g' prefix).  */
+ #define PROGRAM_NAME "diff3"
+ 
+ #define AUTHORS \
+@@ -79,9 +79,6 @@ struct diff_block {
+   char **lines[2];		/* The actual lines (may contain nulls) */
+   size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+   struct diff_block *next;
+-#ifdef lint
+-  struct diff_block *n2;	/* Used only when freeing.  */
+-#endif
+ };
+ 
+ /* Three way diff */
+@@ -162,7 +159,7 @@ static bool overlap_only;
+ /* If nonzero, show information for DIFF_2ND diffs.  */
+ static bool show_2nd;
+ 
+-/* If nonzero, include ':wq' at the end of the script
++/* If nonzero, include `:wq' at the end of the script
+    to write out the file being edited.   */
+ static bool finalwrite;
+ 
+@@ -180,7 +177,7 @@ static struct diff3_block *create_diff3_
+ static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+ static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+ static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+-static struct diff_block *process_diff (char const *, char const *, struct diff_block **, char **);
++static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+ static void check_stdout (void);
+ static void fatal (char const *) __attribute__((noreturn));
+ static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+@@ -216,38 +213,6 @@ static struct option const longopts[] =
+   {0, 0, 0, 0}
+ };
+ 
+-static void
+-free_diff_block (struct diff_block *p)
+-{
+-#ifndef lint
+-  (void)p;
+-#else
+-  while (p)
+-    {
+-      free (p->lines[0]);
+-      free (p->lines[1]);
+-      free (p->lengths[0]);
+-      free (p->lengths[1]);
+-      struct diff_block *next = p->n2;
+-      free (p);
+-      p = next;
+-    }
+-#endif
+-}
+-
+-/* Copy each next pointer to n2, since make_3way_diff would clobber the former,
+-   yet we will still need something to free these buffers.  */
+-static void
+-next_to_n2 (struct diff_block *p)
+-{
+-#ifndef lint
+-  (void)p;
+-#else
+-  while (p)
+-    p = p->n2 = p->next;
+-#endif
+-}
+-
+ int
+ main (int argc, char **argv)
+ {
+@@ -301,10 +266,10 @@ main (int argc, char **argv)
+ 	  break;
+ 	case 'X':
+ 	  overlap_only = true;
+-	  FALLTHROUGH;
++	  /* Fall through.  */
+ 	case 'E':
+ 	  flagging = true;
+-	  FALLTHROUGH;
++	  /* Fall through.  */
+ 	case 'e':
+ 	  incompat++;
+ 	  break;
+@@ -315,7 +280,7 @@ main (int argc, char **argv)
+ 	  strip_trailing_cr = true;
+ 	  break;
+ 	case 'v':
+-	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
++	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+ 		       AUTHORS, (char *) NULL);
+ 	  check_stdout ();
+ 	  return EXIT_SUCCESS;
+@@ -339,9 +304,7 @@ main (int argc, char **argv)
+ 	}
+     }
+ 
+-  /* -AeExX3 without -m implies ed script.  */
+-  edscript = incompat & ~(int) merge;
+-
++  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+   show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+   flagging |= ~incompat & merge;
+ 
+@@ -399,12 +362,12 @@ main (int argc, char **argv)
+     rev_mapping[mapping[i]] = i;
+ 
+   for (i = 0; i < 3; i++)
+-    if (! STREQ (file[i], "-"))
++    if (strcmp (file[i], "-") != 0)
+       {
+ 	if (stat (file[i], &statb) < 0)
+ 	  perror_with_exit (file[i]);
+ 	else if (S_ISDIR (statb.st_mode))
+-	  die (EXIT_TROUBLE, EISDIR, "%s", file[i]);
++	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+       }
+ 
+ #ifdef SIGCHLD
+@@ -415,19 +378,10 @@ main (int argc, char **argv)
+   /* Invoke diff twice on two pairs of input files, combine the two
+      diffs, and output them.  */
+ 
+-  char *b0, *b1;
+   commonname = file[rev_mapping[FILEC]];
+-  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block, &b1);
+-  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block, &b0);
+-
+-  next_to_n2 (thread0);
+-  next_to_n2 (thread1);
+-
++  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
++  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+   diff3 = make_3way_diff (thread0, thread1);
+-
+-  free_diff_block (thread0);
+-  free_diff_block (thread1);
+-
+   if (edscript)
+     conflicts_found
+       = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+@@ -447,10 +401,9 @@ main (int argc, char **argv)
+       conflicts_found = false;
+     }
+ 
+-  free (b0);
+-  free (b1);
+   check_stdout ();
+   exit (conflicts_found);
++  return conflicts_found;
+ }
+ 
+ static void
+@@ -458,8 +411,9 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  die (EXIT_TROUBLE, 0,
++  error (EXIT_TROUBLE, 0,
+ 	 _("Try '%s --help' for more information."), program_name);
++  abort ();
+ }
+ 
+ static void
+@@ -472,28 +426,23 @@ check_stdout (void)
+ }
+ 
+ static char const * const option_help_msgid[] = {
+-  N_("-A, --show-all              output all changes, bracketing conflicts"),
+-  "",
+-  N_("-e, --ed                    output ed script incorporating changes\n"
+-     "                                from OLDFILE to YOURFILE into MYFILE"),
+-  N_("-E, --show-overlap          like -e, but bracket conflicts"),
+-  N_("-3, --easy-only             like -e, but incorporate only nonoverlapping changes"),
+-  N_("-x, --overlap-only          like -e, but incorporate only overlapping changes"),
+-  N_("-X                          like -x, but bracket conflicts"),
+-  N_("-i                          append 'w' and 'q' commands to ed scripts"),
+-  "",
+-  N_("-m, --merge                 output actual merged file, according to\n"
+-     "                                -A if no other options are given"),
++  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
++  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
++  N_("-A  --show-all  Output all changes, bracketing conflicts."),
++  N_("-x  --overlap-only  Output overlapping changes."),
++  N_("-X  Output overlapping changes, bracketing them."),
++  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+   "",
+-  N_("-a, --text                  treat all files as text"),
+-  N_("    --strip-trailing-cr     strip trailing carriage return on input"),
+-  N_("-T, --initial-tab           make tabs line up by prepending a tab"),
+-  N_("    --diff-program=PROGRAM  use PROGRAM to compare files"),
+-  N_("-L, --label=LABEL           use LABEL instead of file name\n"
+-     "                                (can be repeated up to three times)"),
++  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
++  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
++  N_("-i  Append 'w' and `q' commands to ed scripts."),
++  N_("-a  --text  Treat all files as text."),
++  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
++  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
++  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+   "",
+-  N_("    --help                  display this help and exit"),
+-  N_("-v, --version               output version information and exit"),
++  N_("-v  --version  Output version info."),
++  N_("--help  Output this help."),
+   0
+ };
+ 
+@@ -505,25 +454,11 @@ usage (void)
+   printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+ 	  program_name);
+   printf ("%s\n\n", _("Compare three files line by line."));
+-
+-  fputs (_("\
+-Mandatory arguments to long options are mandatory for short options too.\n\
+-"), stdout);
+   for (p = option_help_msgid;  *p;  p++)
+     if (**p)
+       printf ("  %s\n", _(*p));
+     else
+       putchar ('\n');
+-  fputs (_("\n\
+-The default output format is a somewhat human-readable representation of\n\
+-the changes.\n\
+-\n\
+-The -e, -E, -x, -X (and corresponding long) options cause an ed script\n\
+-to be output instead of the default.\n\
+-\n\
+-Finally, the -m (--merge) option causes diff3 to do the merge internally\n\
+-and output the actual merged file.  For unusual input, this is more\n\
+-robust than using ed.\n"), stdout);
+   printf ("\n%s\n%s\n",
+ 	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+@@ -986,8 +921,7 @@ compare_line_list (char * const list1[],
+ static struct diff_block *
+ process_diff (char const *filea,
+ 	      char const *fileb,
+-	      struct diff_block **last_block,
+-	      char **buf_to_free)
++	      struct diff_block **last_block)
+ {
+   char *diff_contents;
+   char *diff_limit;
+@@ -1002,7 +936,6 @@ process_diff (char const *filea,
+ 				  sizeof *bptr->lengths[1]));
+ 
+   diff_limit = read_diff (filea, fileb, &diff_contents);
+-  *buf_to_free = diff_contents;
+   scan_diff = diff_contents;
+ 
+   while (scan_diff < diff_limit)
+@@ -1094,7 +1027,7 @@ process_diff (char const *filea,
+ 
+ /* Skip tabs and spaces, and return the first character after them.  */
+ 
+-static char * _GL_ATTRIBUTE_PURE
++static char *
+ skipwhite (char *s)
+ {
+   while (*s == ' ' || *s == '\t')
+@@ -1210,15 +1143,13 @@ read_diff (char const *filea,
+   int fd, wstatus, status;
+   int werrno = 0;
+   struct stat pipestat;
++
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
++
+   char const *argv[9];
+   char const **ap;
+-#if HAVE_WORKING_FORK
+   int fds[2];
+   pid_t pid;
+-#else
+-  FILE *fpipe;
+-  char *command;
+-#endif
+ 
+   ap = argv;
+   *ap++ = diff_program;
+@@ -1232,12 +1163,10 @@ read_diff (char const *filea,
+   *ap++ = fileb;
+   *ap = 0;
+ 
+-#if HAVE_WORKING_FORK
+-
+   if (pipe (fds) != 0)
+     perror_with_exit ("pipe");
+ 
+-  pid = fork ();
++  pid = vfork ();
+   if (pid == 0)
+     {
+       /* Child */
+@@ -1263,7 +1192,32 @@ read_diff (char const *filea,
+ 
+ #else
+ 
+-  command = system_quote_argv (SCI_SYSTEM, (char **) argv);
++  FILE *fpipe;
++  char const args[] = " --horizon-lines=100 -- ";
++  char *command = xmalloc (shell_quote_length (diff_program)
++			   + sizeof "-a"
++			   + sizeof "--strip-trailing-cr"
++			   + sizeof args - 1
++			   + shell_quote_length (filea) + 1
++			   + shell_quote_length (fileb) + 1);
++  char *p = command;
++  p = shell_quote_copy (p, diff_program);
++  if (text)
++    {
++      strcpy (p, " -a");
++      p += 3;
++    }
++  if (strip_trailing_cr)
++    {
++      strcpy (p, " --strip-trailing-cr");
++      p += 20;
++    }
++  strcpy (p, args);
++  p += sizeof args - 1;
++  p = shell_quote_copy (p, filea);
++  *p++ = ' ';
++  p = shell_quote_copy (p, fileb);
++  *p = 0;
+   errno = 0;
+   fpipe = popen (command, "r");
+   if (!fpipe)
+@@ -1301,7 +1255,7 @@ read_diff (char const *filea,
+ 
+   *output_placement = diff_result;
+ 
+-#if ! HAVE_WORKING_FORK
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+ 
+   wstatus = pclose (fpipe);
+   if (wstatus == -1)
+@@ -1319,7 +1273,7 @@ read_diff (char const *filea,
+   status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+ 
+   if (EXIT_TROUBLE <= status)
+-    die (EXIT_TROUBLE, werrno,
++    error (EXIT_TROUBLE, werrno,
+ 	   _(status == 126
+ 	     ? "subsidiary program '%s' could not be invoked"
+ 	     : status == 127
+@@ -1430,20 +1384,20 @@ output_diff3 (FILE *outputfile, struct d
+ 	  int realfile = mapping[i];
+ 	  lin lowt = D_LOWLINE (ptr, realfile);
+ 	  lin hight = D_HIGHLINE (ptr, realfile);
+-	  printint llowt = lowt;
+-	  printint lhight = hight;
++	  long int llowt = lowt;
++	  long int lhight = hight;
+ 
+ 	  fprintf (outputfile, "%d:", i + 1);
+ 	  switch (lowt - hight)
+ 	    {
+ 	    case 1:
+-	      fprintf (outputfile, "%"pI"da\n", llowt - 1);
++	      fprintf (outputfile, "%lda\n", llowt - 1);
+ 	      break;
+ 	    case 0:
+-	      fprintf (outputfile, "%"pI"dc\n", llowt);
++	      fprintf (outputfile, "%ldc\n", llowt);
+ 	      break;
+ 	    default:
+-	      fprintf (outputfile, "%"pI"d,%"pI"dc\n", llowt, lhight);
++	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+ 	      break;
+ 	    }
+ 
+@@ -1497,18 +1451,19 @@ dotlines (FILE *outputfile, struct diff3
+ 
+ /* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+    output a command that removes initial '.'s starting with line START
+-   and continuing for NUM lines.  */
++   and continuing for NUM lines.  (START is long int, not lin, for
++   convenience with printf %ld formats.)  */
+ 
+ static void
+-undotlines (FILE *outputfile, bool leading_dot, printint start, printint num)
++undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+ {
+   fputs (".\n", outputfile);
+   if (leading_dot)
+     {
+       if (num == 1)
+-	fprintf (outputfile, "%"pI"ds/^\\.//\n", start);
++	fprintf (outputfile, "%lds/^\\.//\n", start);
+       else
+-	fprintf (outputfile, "%"pI"d,%"pI"ds/^\\.//\n", start, start + num - 1);
++	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+     }
+ }
+ 
+@@ -1520,7 +1475,7 @@ undotlines (FILE *outputfile, bool leadi
+    around the problems involved with changing line numbers in an ed
+    script.
+ 
+-   As in 'output_diff3', the variable MAPPING maps from file number
++   As in `output_diff3', the variable MAPPING maps from file number
+    according to the argument list to file number according to the diff
+    passed.  All files listed below are in terms of the argument list.
+    REV_MAPPING is the inverse of MAPPING.
+@@ -1549,7 +1504,7 @@ output_diff3_edscript (FILE *outputfile,
+ 	   ? DIFF_ALL
+ 	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+ 
+-      printint low0, high0;
++      long int low0, high0;
+ 
+       /* If we aren't supposed to do this output block, skip it.  */
+       switch (type)
+@@ -1570,7 +1525,7 @@ output_diff3_edscript (FILE *outputfile,
+ 
+ 	  /* Mark end of conflict.  */
+ 
+-	  fprintf (outputfile, "%"pI"da\n", high0);
++	  fprintf (outputfile, "%lda\n", high0);
+ 	  leading_dot = false;
+ 	  if (type == DIFF_ALL)
+ 	    {
+@@ -1592,7 +1547,7 @@ output_diff3_edscript (FILE *outputfile,
+ 
+ 	  /* Mark start of conflict.  */
+ 
+-	  fprintf (outputfile, "%"pI"da\n<<<<<<< %s\n", low0 - 1,
++	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+ 		   type == DIFF_ALL ? file0 : file1);
+ 	  leading_dot = false;
+ 	  if (type == DIFF_2ND)
+@@ -1608,9 +1563,9 @@ output_diff3_edscript (FILE *outputfile,
+ 	/* Write out a delete */
+ 	{
+ 	  if (low0 == high0)
+-	    fprintf (outputfile, "%"pI"dd\n", low0);
++	    fprintf (outputfile, "%ldd\n", low0);
+ 	  else
+-	    fprintf (outputfile, "%"pI"d,%"pI"dd\n", low0, high0);
++	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+ 	}
+       else
+ 	/* Write out an add or change */
+@@ -1618,13 +1573,13 @@ output_diff3_edscript (FILE *outputfile,
+ 	  switch (high0 - low0)
+ 	    {
+ 	    case -1:
+-	      fprintf (outputfile, "%"pI"da\n", high0);
++	      fprintf (outputfile, "%lda\n", high0);
+ 	      break;
+ 	    case 0:
+-	      fprintf (outputfile, "%"pI"dc\n", high0);
++	      fprintf (outputfile, "%ldc\n", high0);
+ 	      break;
+ 	    default:
+-	      fprintf (outputfile, "%"pI"d,%"pI"dc\n", low0, high0);
++	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+ 	      break;
+ 	    }
+ 
+@@ -1776,15 +1731,17 @@ reverse_diff3_blocklist (struct diff3_bl
+ 
+   return prev;
+ }
+-
++
+ static void
+ fatal (char const *msgid)
+ {
+-  die (EXIT_TROUBLE, 0, "%s", _(msgid));
++  error (EXIT_TROUBLE, 0, "%s", _(msgid));
++  abort ();
+ }
+ 
+ static void
+ perror_with_exit (char const *string)
+ {
+-  die (EXIT_TROUBLE, errno, "%s", string);
++  error (EXIT_TROUBLE, errno, "%s", string);
++  abort ();
+ }
+Only in diffutils-3.0-patch/src: diff3.o
+diff -pru diffutils-3.0/src/diff.c diffutils-3.0-patch/src/diff.c
+--- diffutils-3.0/src/diff.c	2018-06-07 18:22:43.439129000 -0700
++++ diffutils-3.0-patch/src/diff.c	2018-06-07 18:20:57.386088000 -0700
+@@ -1,7 +1,7 @@
+-/* GNU diff - compare files line by line
++/* diff - compare files line by line
+ 
+    Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+-   2009-2013, 2015-2018 Free Software Foundation, Inc.
++   2009-2010 Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -20,7 +20,6 @@
+ 
+ #define GDIFF_MAIN
+ #include "diff.h"
+-#include "die.h"
+ #include <assert.h>
+ #include "paths.h"
+ #include <c-stack.h>
+@@ -28,7 +27,6 @@
+ #include <error.h>
+ #include <exclude.h>
+ #include <exitfail.h>
+-#include <filenamecat.h>
+ #include <file-type.h>
+ #include <fnmatch.h>
+ #include <getopt.h>
+@@ -40,10 +38,9 @@
+ #include <timespec.h>
+ #include <version-etc.h>
+ #include <xalloc.h>
+-#include <xreadlink.h>
+-#include <binary-io.h>
++#include <xfreopen.h>
+ 
+-/* The official name of this program (e.g., no 'g' prefix).  */
++/* The official name of this program (e.g., no `g' prefix).  */
+ #define PROGRAM_NAME "diff"
+ 
+ #define AUTHORS \
+@@ -71,7 +68,6 @@ static void add_regexp (struct regexp_li
+ static void summarize_regexp_list (struct regexp_list *);
+ static void specify_style (enum output_style);
+ static void specify_value (char const **, char const *, char const *);
+-static void specify_colors_style (char const *);
+ static void try_help (char const *, char const *) __attribute__((noreturn));
+ static void check_stdout (void);
+ static void usage (void);
+@@ -94,11 +90,15 @@ static bool binary;
+ enum { binary = true };
+ #endif
+ 
+-/* If one file is missing, treat it as present but empty (-N).  */
++/* When comparing directories, if a file appears only in one
++   directory, treat it as present but empty in the other (-N).
++   Then `patch' would create the file with appropriate contents.  */
+ static bool new_file;
+ 
+-/* If the first file is missing, treat it as present but empty
+-   (--unidirectional-new-file).  */
++/* When comparing directories, if a file appears only in the second
++   directory of the two, treat it as present but empty in the other
++   (--unidirectional-new-file).
++   Then `patch' would create the file with appropriate contents.  */
+ static bool unidirectional_new_file;
+ 
+ /* Report files compared that are the same (-s).
+@@ -106,7 +106,7 @@ static bool unidirectional_new_file;
+ static bool report_identical_files;
+ 
+ static char const shortopts[] =
+-"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:yZ";
++"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+ 
+ /* Values for long options that do not have single-letter equivalents.  */
+ enum
+@@ -119,7 +119,6 @@ enum
+   INHIBIT_HUNK_MERGE_OPTION,
+   LEFT_COLUMN_OPTION,
+   LINE_FORMAT_OPTION,
+-  NO_DEREFERENCE_OPTION,
+   NO_IGNORE_FILE_NAME_CASE_OPTION,
+   NORMAL_OPTION,
+   SDIFF_MERGE_ASSIST_OPTION,
+@@ -138,12 +137,7 @@ enum
+   UNCHANGED_GROUP_FORMAT_OPTION,
+   OLD_GROUP_FORMAT_OPTION,
+   NEW_GROUP_FORMAT_OPTION,
+-  CHANGED_GROUP_FORMAT_OPTION,
+-
+-  COLOR_OPTION,
+-  COLOR_PALETTE_OPTION,
+-
+-  PRESUME_OUTPUT_TTY_OPTION,
++  CHANGED_GROUP_FORMAT_OPTION
+ };
+ 
+ static char const group_format_option[][sizeof "--unchanged-group-format"] =
+@@ -166,7 +160,6 @@ static struct option const longopts[] =
+   {"binary", 0, 0, BINARY_OPTION},
+   {"brief", 0, 0, 'q'},
+   {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+-  {"color", 2, 0, COLOR_OPTION},
+   {"context", 2, 0, 'C'},
+   {"ed", 0, 0, 'e'},
+   {"exclude", 1, 0, 'x'},
+@@ -184,7 +177,6 @@ static struct option const longopts[] =
+   {"ignore-matching-lines", 1, 0, 'I'},
+   {"ignore-space-change", 0, 0, 'b'},
+   {"ignore-tab-expansion", 0, 0, 'E'},
+-  {"ignore-trailing-space", 0, 0, 'Z'},
+   {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+   {"initial-tab", 0, 0, 'T'},
+   {"label", 1, 0, 'L'},
+@@ -194,13 +186,11 @@ static struct option const longopts[] =
+   {"new-file", 0, 0, 'N'},
+   {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+   {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+-  {"no-dereference", 0, 0, NO_DEREFERENCE_OPTION},
+   {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+   {"normal", 0, 0, NORMAL_OPTION},
+   {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+   {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+   {"paginate", 0, 0, 'l'},
+-  {"palette", 1, 0, COLOR_PALETTE_OPTION},
+   {"rcs", 0, 0, 'n'},
+   {"recursive", 0, 0, 'r'},
+   {"report-identical-files", 0, 0, 's'},
+@@ -222,9 +212,6 @@ static struct option const longopts[] =
+   {"unified", 2, 0, 'U'},
+   {"version", 0, 0, 'v'},
+   {"width", 1, 0, 'W'},
+-
+-  /* This is solely for testing.  Do not document.  */
+-  {"-presume-output-tty", no_argument, NULL, PRESUME_OUTPUT_TTY_OPTION},
+   {0, 0, 0, 0}
+ };
+ 
+@@ -296,7 +283,6 @@ main (int argc, char **argv)
+   ignore_regexp_list.buf = &ignore_regexp;
+   re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+   excluded = new_exclude ();
+-  presume_output_tty = false;
+ 
+   /* Decode the options.  */
+ 
+@@ -317,12 +303,11 @@ main (int argc, char **argv)
+ 	case '7':
+ 	case '8':
+ 	case '9':
+-	  ocontext = (! ISDIGIT (prev)
+-		      ? c - '0'
+-		      : (ocontext - (c - '0' <= CONTEXT_MAX % 10)
+-			 < CONTEXT_MAX / 10)
+-		      ? 10 * ocontext + (c - '0')
+-		      : CONTEXT_MAX);
++	  if (! ISDIGIT (prev))
++	    ocontext = c - '0';
++	  else if (LIN_MAX / 10 < ocontext
++		   || ((ocontext = 10 * ocontext + c - '0') < 0))
++	    ocontext = LIN_MAX;
+ 	  break;
+ 
+ 	case 'a':
+@@ -334,11 +319,6 @@ main (int argc, char **argv)
+ 	    ignore_white_space = IGNORE_SPACE_CHANGE;
+ 	  break;
+ 
+-	case 'Z':
+-	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+-	    ignore_white_space |= IGNORE_TRAILING_SPACE;
+-	  break;
+-
+ 	case 'B':
+ 	  ignore_blank_lines = true;
+ 	  break;
+@@ -351,8 +331,8 @@ main (int argc, char **argv)
+ 		numval = strtoumax (optarg, &numend, 10);
+ 		if (*numend)
+ 		  try_help ("invalid context length '%s'", optarg);
+-		if (CONTEXT_MAX < numval)
+-		  numval = CONTEXT_MAX;
++		if (LIN_MAX < numval)
++		  numval = LIN_MAX;
+ 	      }
+ 	    else
+ 	      numval = 3;
+@@ -400,8 +380,8 @@ main (int argc, char **argv)
+ 	  break;
+ 
+ 	case 'E':
+-	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+-	    ignore_white_space |= IGNORE_TAB_EXPANSION;
++	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
++	    ignore_white_space = IGNORE_TAB_EXPANSION;
+ 	  break;
+ 
+ 	case 'f':
+@@ -499,7 +479,7 @@ main (int argc, char **argv)
+ 	  break;
+ 
+ 	case 'v':
+-	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
++	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+ 		       AUTHORS, (char *) NULL);
+ 	  check_stdout ();
+ 	  return EXIT_SUCCESS;
+@@ -538,7 +518,7 @@ main (int argc, char **argv)
+ #if O_BINARY
+ 	  binary = true;
+ 	  if (! isatty (STDOUT_FILENO))
+-	    set_binary_mode (STDOUT_FILENO, O_BINARY);
++	    xfreopen (NULL, "wb", stdout);
+ #endif
+ 	  break;
+ 
+@@ -577,10 +557,6 @@ main (int argc, char **argv)
+ 	    specify_value (&line_format[i], optarg, "--line-format");
+ 	  break;
+ 
+-	case NO_DEREFERENCE_OPTION:
+-	  no_dereference_symlinks = true;
+-	  break;
+-
+ 	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+ 	  ignore_file_name_case = false;
+ 	  break;
+@@ -608,8 +584,7 @@ main (int argc, char **argv)
+ 
+ 	case TABSIZE_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+-	  if (! (0 < numval && numval <= SIZE_MAX - GUTTER_WIDTH_MINIMUM)
+-	      || *numend)
++	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+ 	    try_help ("invalid tabsize '%s'", optarg);
+ 	  if (tabsize != numval)
+ 	    {
+@@ -640,31 +615,12 @@ main (int argc, char **argv)
+ 	  specify_value (&group_format[c], optarg, group_format_option[c]);
+ 	  break;
+ 
+-	case COLOR_OPTION:
+-	  specify_colors_style (optarg);
+-	  break;
+-
+-	case COLOR_PALETTE_OPTION:
+-	  set_color_palette (optarg);
+-	  break;
+-
+-        case PRESUME_OUTPUT_TTY_OPTION:
+-          presume_output_tty = true;
+-          break;
+-
+ 	default:
+ 	  try_help (NULL, NULL);
+ 	}
+       prev = c;
+     }
+ 
+-  if (colors_style == AUTO)
+-    {
+-      char const *t = getenv ("TERM");
+-      if (t && STREQ (t, "dumb"))
+-        colors_style = NEVER;
+-    }
+-
+   if (output_style == OUTPUT_UNSPECIFIED)
+     {
+       if (show_c_function)
+@@ -715,14 +671,10 @@ main (int argc, char **argv)
+ 		a half line plus a gutter is an integral number of tabs,
+ 		so that tabs in the right column line up.  */
+ 
+-    size_t t = expand_tabs ? 1 : tabsize;
+-    size_t w = width;
+-    size_t t_plus_g = t + GUTTER_WIDTH_MINIMUM;
+-    size_t unaligned_off = (w >> 1) + (t_plus_g >> 1) + (w & t_plus_g & 1);
+-    size_t off = unaligned_off - unaligned_off % t;
+-    sdiff_half_width = (off <= GUTTER_WIDTH_MINIMUM || w <= off
+-			? 0
+-			: MIN (off - GUTTER_WIDTH_MINIMUM, w - off));
++    intmax_t t = expand_tabs ? 1 : tabsize;
++    intmax_t w = width;
++    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
++    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+     sdiff_column2_offset = sdiff_half_width ? off : w;
+   }
+ 
+@@ -818,7 +770,7 @@ add_regexp (struct regexp_list *reglist,
+   char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+ 
+   if (m != 0)
+-    error (EXIT_TROUBLE, 0, "%s: %s", pattern, m);
++    error (0, 0, "%s: %s", pattern, m);
+   else
+     {
+       char *regexps = reglist->regexps;
+@@ -864,7 +816,7 @@ summarize_regexp_list (struct regexp_lis
+ 	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+ 					      reglist->buf);
+ 	  if (m)
+-	    die (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
++	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+ 	}
+     }
+ }
+@@ -874,8 +826,9 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
++  abort ();
+ }
+ 
+ static void
+@@ -888,65 +841,41 @@ check_stdout (void)
+ }
+ 
+ static char const * const option_help_msgid[] = {
+-  N_("    --normal                  output a normal diff (the default)"),
+-  N_("-q, --brief                   report only when files differ"),
+-  N_("-s, --report-identical-files  report when two files are the same"),
+-  N_("-c, -C NUM, --context[=NUM]   output NUM (default 3) lines of copied context"),
+-  N_("-u, -U NUM, --unified[=NUM]   output NUM (default 3) lines of unified context"),
+-  N_("-e, --ed                      output an ed script"),
+-  N_("-n, --rcs                     output an RCS format diff"),
+-  N_("-y, --side-by-side            output in two columns"),
+-  N_("-W, --width=NUM               output at most NUM (default 130) print columns"),
+-  N_("    --left-column             output only the left column of common lines"),
+-  N_("    --suppress-common-lines   do not output common lines"),
+-  "",
+-  N_("-p, --show-c-function         show which C function each change is in"),
+-  N_("-F, --show-function-line=RE   show the most recent line matching RE"),
+-  N_("    --label LABEL             use LABEL instead of file name and timestamp\n"
+-     "                                (can be repeated)"),
+-  "",
+-  N_("-t, --expand-tabs             expand tabs to spaces in output"),
+-  N_("-T, --initial-tab             make tabs line up by prepending a tab"),
+-  N_("    --tabsize=NUM             tab stops every NUM (default 8) print columns"),
+-  N_("    --suppress-blank-empty    suppress space or tab before empty output lines"),
+-  N_("-l, --paginate                pass output through 'pr' to paginate it"),
+-  "",
+-  N_("-r, --recursive                 recursively compare any subdirectories found"),
+-  N_("    --no-dereference            don't follow symbolic links"),
+-  N_("-N, --new-file                  treat absent files as empty"),
+-  N_("    --unidirectional-new-file   treat absent first files as empty"),
+-  N_("    --ignore-file-name-case     ignore case when comparing file names"),
+-  N_("    --no-ignore-file-name-case  consider case when comparing file names"),
+-  N_("-x, --exclude=PAT               exclude files that match PAT"),
+-  N_("-X, --exclude-from=FILE         exclude files that match any pattern in FILE"),
+-  N_("-S, --starting-file=FILE        start with FILE when comparing directories"),
+-  N_("    --from-file=FILE1           compare FILE1 to all operands;\n"
+-     "                                  FILE1 can be a directory"),
+-  N_("    --to-file=FILE2             compare all operands to FILE2;\n"
+-     "                                  FILE2 can be a directory"),
+-  "",
+-  N_("-i, --ignore-case               ignore case differences in file contents"),
+-  N_("-E, --ignore-tab-expansion      ignore changes due to tab expansion"),
+-  N_("-Z, --ignore-trailing-space     ignore white space at line end"),
+-  N_("-b, --ignore-space-change       ignore changes in the amount of white space"),
+-  N_("-w, --ignore-all-space          ignore all white space"),
+-  N_("-B, --ignore-blank-lines        ignore changes where lines are all blank"),
+-  N_("-I, --ignore-matching-lines=RE  ignore changes where all lines match RE"),
++  N_("Compare files line by line."),
+   "",
+-  N_("-a, --text                      treat all files as text"),
+-  N_("    --strip-trailing-cr         strip trailing carriage return on input"),
++  N_("-i  --ignore-case  Ignore case differences in file contents."),
++  N_("--ignore-file-name-case  Ignore case when comparing file names."),
++  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
++  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
++  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
++  N_("-w  --ignore-all-space  Ignore all white space."),
++  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
++  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
++  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+ #if O_BINARY
+-  N_("    --binary                    read and write data in binary mode"),
++  N_("--binary  Read and write data in binary mode."),
+ #endif
++  N_("-a  --text  Treat all files as text."),
+   "",
+-  N_("-D, --ifdef=NAME                output merged file with '#ifdef NAME' diffs"),
+-  N_("    --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT"),
+-  N_("    --line-format=LFMT          format all input lines with LFMT"),
+-  N_("    --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT"),
+-  N_("  These format options provide fine-grained control over the output\n"
+-     "    of diff, generalizing -D/--ifdef."),
++  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
++-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
++  --label LABEL  Use LABEL instead of file name.\n\
++  -p  --show-c-function  Show which C function each change is in.\n\
++  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
++  N_("-q  --brief  Output only whether files differ."),
++  N_("-e  --ed  Output an ed script."),
++  N_("--normal  Output a normal diff."),
++  N_("-n  --rcs  Output an RCS format diff."),
++  N_("-y  --side-by-side  Output in two columns.\n\
++  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
++  --left-column  Output only the left column of common lines.\n\
++  --suppress-common-lines  Do not output common lines."),
++  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
++  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
++  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
++  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+   N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+-  N_("  GFMT (only) may contain:\n\
++  N_("  GFMT may contain:\n\
+     %<  lines from FILE1\n\
+     %>  lines from FILE2\n\
+     %=  lines common to FILE1 and FILE2\n\
+@@ -956,31 +885,41 @@ static char const * const option_help_ms
+         L  last line number\n\
+         N  number of lines = L-F+1\n\
+         E  F-1\n\
+-        M  L+1\n\
+-    %(A=B?T:E)  if A equals B then T else E"),
+-  N_("  LFMT (only) may contain:\n\
++        M  L+1"),
++  N_("  LFMT may contain:\n\
+     %L  contents of line\n\
+     %l  contents of line, excluding any trailing newline\n\
+     %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+-  N_("  Both GFMT and LFMT may contain:\n\
++  N_("  Either GFMT or LFMT may contain:\n\
+     %%  %\n\
+     %c'C'  the single character C\n\
+-    %c'\\OOO'  the character with octal code OOO\n\
+-    C    the character C (other characters represent themselves)"),
++    %c'\\OOO'  the character with octal code OOO"),
+   "",
+-  N_("-d, --minimal            try hard to find a smaller set of changes"),
+-  N_("    --horizon-lines=NUM  keep NUM lines of the common prefix and suffix"),
+-  N_("    --speed-large-files  assume large files and many scattered small changes"),
+-  N_("    --color[=WHEN]       colorize the output; WHEN can be 'never', 'always',\n"
+-     "                           or 'auto' (the default)"),
+-  N_("    --palette=PALETTE    the colors to use when --color is active; PALETTE is\n"
+-     "                           a colon-separated list of terminfo capabilities"),
++  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
++  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
++  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
++  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
++  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+   "",
+-  N_("    --help               display this help and exit"),
+-  N_("-v, --version            output version information and exit"),
++  N_("-r  --recursive  Recursively compare any subdirectories found."),
++  N_("-N  --new-file  Treat absent files as empty."),
++  N_("--unidirectional-new-file  Treat absent first files as empty."),
++  N_("-s  --report-identical-files  Report when two files are the same."),
++  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
++  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
++  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
++  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
++  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+   "",
+-  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE' or 'FILE DIR'."),
+-  N_("If --from-file or --to-file is given, there are no restrictions on FILE(s)."),
++  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
++  N_("-d  --minimal  Try hard to find a smaller set of changes."),
++  N_("--speed-large-files  Assume large files and many scattered small changes."),
++  "",
++  N_("-v  --version  Output version info."),
++  N_("--help  Output this help."),
++  "",
++  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
++  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+   N_("If a FILE is '-', read standard input."),
+   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+   0
+@@ -992,11 +931,6 @@ usage (void)
+   char const * const *p;
+ 
+   printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+-  printf ("%s\n\n", _("Compare FILES line by line."));
+-
+-  fputs (_("\
+-Mandatory arguments to long options are mandatory for short options too.\n\
+-"), stdout);
+ 
+   for (p = option_help_msgid;  *p;  p++)
+     {
+@@ -1024,7 +958,7 @@ Mandatory arguments to long options are
+ static void
+ specify_value (char const **var, char const *value, char const *option)
+ {
+-  if (*var && ! STREQ (*var, value))
++  if (*var && strcmp (*var, value) != 0)
+     {
+       error (0, 0, _("conflicting %s option value '%s'"), option, value);
+       try_help (NULL, NULL);
+@@ -1043,21 +977,6 @@ specify_style (enum output_style style)
+       output_style = style;
+     }
+ }
+-
+-/* Set the color mode.  */
+-static void
+-specify_colors_style (char const *value)
+-{
+-  if (value == NULL || STREQ (value, "auto"))
+-    colors_style = AUTO;
+-  else if (STREQ (value, "always"))
+-    colors_style = ALWAYS;
+-  else if (STREQ (value, "never"))
+-    colors_style = NEVER;
+-  else
+-    try_help ("invalid color '%s'", value);
+-}
+-
+ 
+ /* Set the last-modified time of *ST to be the current time.  */
+ 
+@@ -1148,9 +1067,9 @@ compare_files (struct comparison const *
+   else
+     {
+       cmp.file[0].name = free0
+-	= file_name_concat (parent->file[0].name, name0, NULL);
++	= dir_file_pathname (parent->file[0].name, name0);
+       cmp.file[1].name = free1
+-	= file_name_concat (parent->file[1].name, name1, NULL);
++	= dir_file_pathname (parent->file[1].name, name1);
+     }
+ 
+   /* Stat the files.  */
+@@ -1167,8 +1086,8 @@ compare_files (struct comparison const *
+ 	  else if (STREQ (cmp.file[f].name, "-"))
+ 	    {
+ 	      cmp.file[f].desc = STDIN_FILENO;
+-	      if (binary && ! isatty (STDIN_FILENO))
+-		set_binary_mode (STDIN_FILENO, O_BINARY);
++	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
++		xfreopen (NULL, "rb", stdin);
+ 	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+ 		cmp.file[f].desc = ERRNO_ENCODE (errno);
+ 	      else
+@@ -1188,10 +1107,7 @@ compare_files (struct comparison const *
+ 		  set_mtime_to_now (&cmp.file[f].stat);
+ 		}
+ 	    }
+-	  else if ((no_dereference_symlinks
+-		    ? lstat (cmp.file[f].name, &cmp.file[f].stat)
+-		    : stat (cmp.file[f].name, &cmp.file[f].stat))
+-		   != 0)
++	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+ 	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+ 	}
+     }
+@@ -1207,11 +1123,9 @@ compare_files (struct comparison const *
+ 	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+ 	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+ 	       && cmp.file[f].stat.st_size == 0)
+-	    : ((cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+-		|| cmp.file[f].desc == ERRNO_ENCODE (EBADF))
++	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+ 	       && ! parent
+-	       && (cmp.file[1 - f].desc == UNOPENED
+-		   || cmp.file[1 - f].desc == STDIN_FILENO))))
++	       && cmp.file[1 - f].desc == UNOPENED)))
+       cmp.file[f].desc = NONEXISTENT;
+ 
+   for (f = 0; f < 2; f++)
+@@ -1242,15 +1156,12 @@ compare_files (struct comparison const *
+       char const *fnm = cmp.file[fnm_arg].name;
+       char const *dir = cmp.file[dir_arg].name;
+       char const *filename = cmp.file[dir_arg].name = free0
+-	= find_dir_file_pathname (dir, last_component (fnm));
++	= dir_file_pathname (dir, last_component (fnm));
+ 
+       if (STREQ (fnm, "-"))
+ 	fatal ("cannot compare '-' to a directory");
+ 
+-      if ((no_dereference_symlinks
+-	   ? lstat (filename, &cmp.file[dir_arg].stat)
+-	   : stat (filename, &cmp.file[dir_arg].stat))
+-	  != 0)
++      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+ 	{
+ 	  perror_with_name (filename);
+ 	  status = EXIT_TROUBLE;
+@@ -1297,10 +1208,8 @@ compare_files (struct comparison const *
+     }
+   else if ((DIR_P (0) | DIR_P (1))
+ 	   || (parent
+-	       && !((S_ISREG (cmp.file[0].stat.st_mode)
+-		     || S_ISLNK (cmp.file[0].stat.st_mode))
+-		    && (S_ISREG (cmp.file[1].stat.st_mode)
+-			|| S_ISLNK  (cmp.file[1].stat.st_mode)))))
++	       && (! S_ISREG (cmp.file[0].stat.st_mode)
++		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+     {
+       if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+ 	{
+@@ -1341,62 +1250,10 @@ compare_files (struct comparison const *
+ 	  status = EXIT_FAILURE;
+ 	}
+     }
+-  else if (S_ISLNK (cmp.file[0].stat.st_mode)
+-	   || S_ISLNK (cmp.file[1].stat.st_mode))
+-    {
+-      /* We get here only if we use lstat(), not stat().  */
+-      assert (no_dereference_symlinks);
+-
+-      if (S_ISLNK (cmp.file[0].stat.st_mode)
+-	  && S_ISLNK (cmp.file[1].stat.st_mode))
+-	{
+-	  /* Compare the values of the symbolic links.  */
+-	  char *link_value[2] = { NULL, NULL };
+-
+-	  for (f = 0; f < 2; f++)
+-	    {
+-	      link_value[f] = xreadlink (cmp.file[f].name);
+-	      if (link_value[f] == NULL)
+-		{
+-		  perror_with_name (cmp.file[f].name);
+-		  status = EXIT_TROUBLE;
+-		  break;
+-		}
+-	    }
+-	  if (status == EXIT_SUCCESS)
+-	    {
+-	      if ( ! STREQ (link_value[0], link_value[1]))
+-		{
+-		  message ("Symbolic links %s and %s differ\n",
+-			   cmp.file[0].name, cmp.file[1].name);
+-		  /* This is a difference.  */
+-		  status = EXIT_FAILURE;
+-		}
+-	    }
+-	  for (f = 0; f < 2; f++)
+-	    free (link_value[f]);
+-	}
+-      else
+-	{
+-	  /* We have two files that are not to be compared, because
+-	     one of them is a symbolic link and the other one is not.  */
+-
+-	  message5 ("File %s is a %s while file %s is a %s\n",
+-		    file_label[0] ? file_label[0] : cmp.file[0].name,
+-		    file_type (&cmp.file[0].stat),
+-		    file_label[1] ? file_label[1] : cmp.file[1].name,
+-		    file_type (&cmp.file[1].stat));
+-
+-	  /* This is a difference.  */
+-	  status = EXIT_FAILURE;
+-	}
+-    }
+   else if (files_can_be_treated_as_binary
+ 	   && S_ISREG (cmp.file[0].stat.st_mode)
+ 	   && S_ISREG (cmp.file[1].stat.st_mode)
+-	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size
+-	   && 0 < cmp.file[0].stat.st_size
+-	   && 0 < cmp.file[1].stat.st_size)
++	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+     {
+       message ("Files %s and %s differ\n",
+ 	       file_label[0] ? file_label[0] : cmp.file[0].name,
+diff -pru diffutils-3.0/src/diff.h diffutils-3.0-patch/src/diff.h
+--- diffutils-3.0/src/diff.h	2018-06-07 18:22:43.440130000 -0700
++++ diffutils-3.0-patch/src/diff.h	2018-06-07 18:20:57.331082000 -0700
+@@ -1,7 +1,7 @@
+ /* Shared definitions for GNU DIFF
+ 
+-   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -38,19 +38,6 @@ enum changes
+   /* Both deletes and inserts: a hunk containing both old and new lines.  */
+   CHANGED
+ };
+-
+-/* When colors should be used in the output.  */
+-enum colors_style
+-{
+-  /* Never output colors.  */
+-  NEVER,
+-
+-  /* Output colors if the output is a terminal.  */
+-  AUTO,
+-
+-  /* Always output colors.  */
+-  ALWAYS,
+-};
+ 
+ /* Variables for command line options */
+ 
+@@ -74,7 +61,7 @@ enum output_style
+   /* Output the differences in a unified context diff format (-u).  */
+   OUTPUT_UNIFIED,
+ 
+-  /* Output the differences as commands suitable for 'ed' (-e).  */
++  /* Output the differences as commands suitable for `ed' (-e).  */
+   OUTPUT_ED,
+ 
+   /* Output the diff as a forward ed script (-f).  */
+@@ -96,9 +83,6 @@ enum output_style
+ 
+ XTERN enum output_style output_style;
+ 
+-/* Define the current color context used to print a line.  */
+-XTERN enum colors_style colors_style;
+-
+ /* Nonzero if output cannot be generated for identical files.  */
+ XTERN bool no_diff_means_no_output;
+ 
+@@ -114,7 +98,7 @@ XTERN bool text;
+ XTERN lin horizon_lines;
+ 
+ /* The significance of white space during comparisons.  */
+-enum DIFF_white_space
++XTERN enum
+ {
+   /* All white space is significant (the default).  */
+   IGNORE_NO_WHITE_SPACE,
+@@ -122,21 +106,12 @@ enum DIFF_white_space
+   /* Ignore changes due to tab expansion (-E).  */
+   IGNORE_TAB_EXPANSION,
+ 
+-  /* Ignore changes in trailing horizontal white space (-Z).  */
+-  IGNORE_TRAILING_SPACE,
+-
+-  /* IGNORE_TAB_EXPANSION and IGNORE_TRAILING_SPACE are a special case
+-     because they are independent and can be ORed together, yielding
+-     IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE.  */
+-  IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE,
+-
+   /* Ignore changes in horizontal white space (-b).  */
+   IGNORE_SPACE_CHANGE,
+ 
+   /* Ignore all horizontal white space (-w).  */
+   IGNORE_ALL_SPACE
+-};
+-XTERN enum DIFF_white_space ignore_white_space;
++} ignore_white_space;
+ 
+ /* Ignore changes that affect only blank lines (-B).  */
+ XTERN bool ignore_blank_lines;
+@@ -151,11 +126,7 @@ XTERN bool ignore_case;
+ /* Ignore differences in case of letters in file names.  */
+ XTERN bool ignore_file_name_case;
+ 
+-/* Act on symbolic links themselves rather than on their target
+-   (--no-dereference).  */
+-XTERN bool no_dereference_symlinks;
+-
+-/* File labels for '-c' output headers (--label).  */
++/* File labels for `-c' output headers (--label).  */
+ XTERN char *file_label[2];
+ 
+ /* Regexp to identify function-header lines (-F).  */
+@@ -231,8 +202,8 @@ XTERN bool minimal;
+ /* The strftime format to use for time strings.  */
+ XTERN char const *time_format;
+ 
+-/* The result of comparison is an "edit script": a chain of 'struct change'.
+-   Each 'struct change' represents one place where some lines are deleted
++/* The result of comparison is an "edit script": a chain of `struct change'.
++   Each `struct change' represents one place where some lines are deleted
+    and some are inserted.
+ 
+    LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+@@ -345,79 +316,58 @@ XTERN FILE *outfile;
+ /* Declare various functions.  */
+ 
+ /* analyze.c */
+-extern int diff_2_files (struct comparison *);
++int diff_2_files (struct comparison *);
+ 
+ /* context.c */
+-extern void print_context_header (struct file_data[], char const * const *, bool);
+-extern void print_context_script (struct change *, bool);
++void print_context_header (struct file_data[], bool);
++void print_context_script (struct change *, bool);
+ 
+ /* dir.c */
+-extern int diff_dirs (struct comparison const *,
+-                      int (*) (struct comparison const *,
+-                               char const *, char const *));
+-extern char *find_dir_file_pathname (char const *, char const *);
++int diff_dirs (struct comparison const *, int (*) (struct comparison const *, char const *, char const *));
+ 
+ /* ed.c */
+-extern void print_ed_script (struct change *);
+-extern void pr_forward_ed_script (struct change *);
++void print_ed_script (struct change *);
++void pr_forward_ed_script (struct change *);
+ 
+ /* ifdef.c */
+-extern void print_ifdef_script (struct change *);
++void print_ifdef_script (struct change *);
+ 
+ /* io.c */
+-extern void file_block_read (struct file_data *, size_t);
+-extern bool read_files (struct file_data[], bool);
++void file_block_read (struct file_data *, size_t);
++bool read_files (struct file_data[], bool);
+ 
+ /* normal.c */
+-extern void print_normal_script (struct change *);
++void print_normal_script (struct change *);
+ 
+ /* rcs.c */
+-extern void print_rcs_script (struct change *);
++void print_rcs_script (struct change *);
+ 
+ /* side.c */
+-extern void print_sdiff_script (struct change *);
++void print_sdiff_script (struct change *);
+ 
+ /* util.c */
+ extern char const change_letter[4];
+ extern char const pr_program[];
+-extern char *concat (char const *, char const *, char const *);
+-extern bool lines_differ (char const *, char const *) _GL_ATTRIBUTE_PURE;
+-extern lin translate_line_number (struct file_data const *, lin);
+-extern struct change *find_change (struct change *);
+-extern struct change *find_reverse_change (struct change *);
+-extern void *zalloc (size_t);
+-extern enum changes analyze_hunk (struct change *, lin *, lin *, lin *, lin *);
+-extern void begin_output (void);
+-extern void debug_script (struct change *);
+-extern void fatal (char const *) __attribute__((noreturn));
+-extern void finish_output (void);
+-extern void message (char const *, char const *, char const *);
+-extern void message5 (char const *, char const *, char const *,
+-                      char const *, char const *);
+-extern void output_1_line (char const *, char const *, char const *,
+-                           char const *);
+-extern void perror_with_name (char const *);
+-extern void pfatal_with_name (char const *) __attribute__((noreturn));
+-extern void print_1_line (char const *, char const * const *);
+-extern void print_1_line_nl (char const *, char const * const *, bool);
+-extern void print_message_queue (void);
+-extern void print_number_range (char, struct file_data *, lin, lin);
+-extern void print_script (struct change *, struct change * (*) (struct change *),
+-                          void (*) (struct change *));
+-extern void setup_output (char const *, char const *, bool);
+-extern void translate_range (struct file_data const *, lin, lin,
+-                             printint *, printint *);
+-
+-enum color_context
+-{
+-  HEADER_CONTEXT,
+-  ADD_CONTEXT,
+-  DELETE_CONTEXT,
+-  RESET_CONTEXT,
+-  LINE_NUMBER_CONTEXT,
+-};
+-
+-XTERN bool presume_output_tty;
+-
+-extern void set_color_context (enum color_context color_context);
+-extern void set_color_palette (char const *palette);
++char *concat (char const *, char const *, char const *);
++char *dir_file_pathname (char const *, char const *);
++bool lines_differ (char const *, char const *);
++lin translate_line_number (struct file_data const *, lin);
++struct change *find_change (struct change *);
++struct change *find_reverse_change (struct change *);
++void *zalloc (size_t);
++enum changes analyze_hunk (struct change *, lin *, lin *, lin *, lin *);
++void begin_output (void);
++void debug_script (struct change *);
++void fatal (char const *) __attribute__((noreturn));
++void finish_output (void);
++void message (char const *, char const *, char const *);
++void message5 (char const *, char const *, char const *, char const *, char const *);
++void output_1_line (char const *, char const *, char const *, char const *);
++void perror_with_name (char const *);
++void pfatal_with_name (char const *) __attribute__((noreturn));
++void print_1_line (char const *, char const * const *);
++void print_message_queue (void);
++void print_number_range (char, struct file_data *, lin, lin);
++void print_script (struct change *, struct change * (*) (struct change *), void (*) (struct change *));
++void setup_output (char const *, char const *, bool);
++void translate_range (struct file_data const *, lin, lin, long int *, long int *);
+Only in diffutils-3.0-patch/src: diff.o
+diff -pru diffutils-3.0/src/dir.c diffutils-3.0-patch/src/dir.c
+--- diffutils-3.0/src/dir.c	2018-06-07 18:22:43.444129000 -0700
++++ diffutils-3.0-patch/src/dir.c	2018-06-07 18:20:57.336084000 -0700
+@@ -1,7 +1,7 @@
+ /* Read, sort and compare two directories.  Used for GNU DIFF.
+ 
+    Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+-   2009-2013, 2015-2018 Free Software Foundation, Inc.
++   2009-2010 Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -21,7 +21,6 @@
+ #include "diff.h"
+ #include <error.h>
+ #include <exclude.h>
+-#include <filenamecat.h>
+ #include <setjmp.h>
+ #include <xalloc.h>
+ 
+@@ -45,6 +44,7 @@ static bool locale_specific_sorting;
+ static jmp_buf failed_locale_specific_sorting;
+ 
+ static bool dir_loop (struct comparison const *, int);
++static int compare_names_for_qsort (void const *, void const *);
+ 
+ 
+ /* Read a directory and get its vector of names.  */
+@@ -84,7 +84,7 @@ dir_read (struct file_data const *dir, s
+       dirdata->data = data = xmalloc (data_alloc);
+ 
+       /* Read the directory entries, and insert the subfiles
+-	 into the 'data' table.  */
++	 into the `data' table.  */
+ 
+       while ((errno = 0, (next = readdir (reading)) != 0))
+ 	{
+@@ -125,7 +125,7 @@ dir_read (struct file_data const *dir, s
+ #endif
+     }
+ 
+-  /* Create the 'names' table from the 'data' table.  */
++  /* Create the `names' table from the `data' table.  */
+   if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+     xalloc_die ();
+   dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+@@ -139,27 +139,6 @@ dir_read (struct file_data const *dir, s
+   return true;
+ }
+ 
+-/* Compare strings in a locale-specific way, returning a value
+-   compatible with strcmp.  */
+-
+-static int
+-compare_collated (char const *name1, char const *name2)
+-{
+-  int r;
+-  errno = 0;
+-  if (ignore_file_name_case)
+-    r = strcasecoll (name1, name2);
+-  else
+-    r = strcoll (name1, name2);
+-  if (errno)
+-    {
+-      error (0, errno, _("cannot compare file names '%s' and '%s'"),
+-	     name1, name2);
+-      longjmp (failed_locale_specific_sorting, 1);
+-    }
+-  return r;
+-}
+-
+ /* Compare file names, returning a value compatible with strcmp.  */
+ 
+ static int
+@@ -167,30 +146,34 @@ compare_names (char const *name1, char c
+ {
+   if (locale_specific_sorting)
+     {
+-      int diff = compare_collated (name1, name2);
+-      if (diff || ignore_file_name_case)
+-	return diff;
++      int r;
++      errno = 0;
++      if (ignore_file_name_case)
++	r = strcasecoll (name1, name2);
++      else
++	r = strcoll (name1, name2);
++      if (errno)
++	{
++	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
++		 name1, name2);
++	  longjmp (failed_locale_specific_sorting, 1);
++	}
++      return r;
+     }
+-  return file_name_cmp (name1, name2);
++
++  return (ignore_file_name_case
++	  ? strcasecmp (name1, name2)
++	  : file_name_cmp (name1, name2));
+ }
+ 
+-/* Compare names FILE1 and FILE2 when sorting a directory.
+-   Prefer filtered comparison, breaking ties with file_name_cmp.  */
++/* A wrapper for compare_names suitable as an argument for qsort.  */
+ 
+ static int
+ compare_names_for_qsort (void const *file1, void const *file2)
+ {
+   char const *const *f1 = file1;
+   char const *const *f2 = file2;
+-  char const *name1 = *f1;
+-  char const *name2 = *f2;
+-  if (locale_specific_sorting)
+-    {
+-      int diff = compare_collated (name1, name2);
+-      if (diff)
+-	return diff;
+-    }
+-  return file_name_cmp (name1, name2);
++  return compare_names (*f1, *f2);
+ }
+ 
+ /* Compare the contents of two directories named in CMP.
+@@ -251,7 +234,7 @@ diff_dirs (struct comparison const *cmp,
+ 	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+ 	       compare_names_for_qsort);
+ 
+-      /* If '-S name' was given, and this is the topmost level of comparison,
++      /* If `-S name' was given, and this is the topmost level of comparison,
+ 	 ignore all file names less than the specified starting name.  */
+ 
+       if (starting_file && ! cmp->parent)
+@@ -270,41 +253,6 @@ diff_dirs (struct comparison const *cmp,
+ 	     pretend the "next name" in that dir is very large.  */
+ 	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+ 			   : compare_names (*names[0], *names[1]));
+-
+-	  /* Prefer a file_name_cmp match if available.  This algorithm is
+-	     O(N**2), where N is the number of names in a directory
+-	     that compare_names says are all equal, but in practice N
+-	     is so small it's not worth tuning.  */
+-	  if (nameorder == 0 && ignore_file_name_case)
+-	    {
+-	      int raw_order = file_name_cmp (*names[0], *names[1]);
+-	      if (raw_order != 0)
+-		{
+-		  int greater_side = raw_order < 0;
+-		  int lesser_side = 1 - greater_side;
+-		  char const **lesser = names[lesser_side];
+-		  char const *greater_name = *names[greater_side];
+-		  char const **p;
+-
+-		  for (p = lesser + 1;
+-		       *p && compare_names (*p, greater_name) == 0;
+-		       p++)
+-		    {
+-		      int c = file_name_cmp (*p, greater_name);
+-		      if (0 <= c)
+-			{
+-			  if (c == 0)
+-			    {
+-			      memmove (lesser + 1, lesser,
+-				       (char *) p - (char *) lesser);
+-			      *lesser = greater_name;
+-			    }
+-			  break;
+-			}
+-		    }
+-		}
+-	    }
+-
+ 	  int v1 = (*handle_file) (cmp,
+ 				   0 < nameorder ? 0 : *names[0]++,
+ 				   nameorder < 0 ? 0 : *names[1]++);
+@@ -324,7 +272,7 @@ diff_dirs (struct comparison const *cmp,
+ 
+ /* Return nonzero if CMP is looping recursively in argument I.  */
+ 
+-static bool _GL_ATTRIBUTE_PURE
++static bool
+ dir_loop (struct comparison const *cmp, int i)
+ {
+   struct comparison const *p = cmp;
+@@ -333,53 +281,3 @@ dir_loop (struct comparison const *cmp,
+       return true;
+   return false;
+ }
+-
+-/* Find a matching filename in a directory.  */
+-
+-char *
+-find_dir_file_pathname (char const *dir, char const *file)
+-{
+-  /* The 'IF_LINT (volatile)' works around what appears to be a bug in
+-     gcc 4.8.0 20120825; see
+-     <http://lists.gnu.org/archive/html/bug-diffutils/2012-08/msg00007.html>.
+-     */
+-  char const * IF_LINT (volatile) match = file;
+-
+-  char *val;
+-  struct dirdata dirdata;
+-  dirdata.names = NULL;
+-  dirdata.data = NULL;
+-
+-  if (ignore_file_name_case)
+-    {
+-      struct file_data filedata;
+-      filedata.name = dir;
+-      filedata.desc = 0;
+-
+-      if (dir_read (&filedata, &dirdata))
+-	{
+-	  locale_specific_sorting = true;
+-	  if (setjmp (failed_locale_specific_sorting))
+-	    match = file; /* longjmp may mess up MATCH.  */
+-	  else
+-	    {
+-	      for (char const **p = dirdata.names; *p; p++)
+-		if (compare_names (*p, file) == 0)
+-		  {
+-		    if (file_name_cmp (*p, file) == 0)
+-		      {
+-			match = *p;
+-			break;
+-		      }
+-		    if (match == file)
+-		      match = *p;
+-		  }
+-	    }
+-	}
+-    }
+-
+-  val = file_name_concat (dir, match, NULL);
+-  free (dirdata.names);
+-  free (dirdata.data);
+-  return val;
+-}
+Only in diffutils-3.0-patch/src: dir.o
+diff -pru diffutils-3.0/src/ed.c diffutils-3.0-patch/src/ed.c
+--- diffutils-3.0/src/ed.c	2018-06-07 18:22:43.445131000 -0700
++++ diffutils-3.0-patch/src/ed.c	2018-06-07 18:20:57.326089000 -0700
+@@ -1,7 +1,7 @@
+ /* Output routines for ed-script format.
+ 
+-   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -144,7 +144,7 @@ static void
+ print_rcs_hunk (struct change *hunk)
+ {
+   lin i, f0, l0, f1, l1;
+-  printint tf0, tl0, tf1, tl1;
++  long int tf0, tl0, tf1, tl1;
+ 
+   /* Determine range of line numbers involved in each file.  */
+   enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+@@ -159,16 +159,14 @@ print_rcs_hunk (struct change *hunk)
+     {
+       /* For deletion, print just the starting line number from file 0
+ 	 and the number of lines deleted.  */
+-      fprintf (outfile, "d%"pI"d %"pI"d\n", tf0,
+-	       tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
++      fprintf (outfile, "d%ld %ld\n", tf0, tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+     }
+ 
+   if (changes & NEW)
+     {
+       /* Take last-line-number from file 0 and # lines from file 1.  */
+       translate_range (&files[1], f1, l1, &tf1, &tl1);
+-      fprintf (outfile, "a%"pI"d %"pI"d\n", tl0,
+-	       tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
++      fprintf (outfile, "a%ld %ld\n", tl0, tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+ 
+       /* Print the inserted lines.  */
+       for (i = f1; i <= l1; i++)
+Only in diffutils-3.0-patch/src: ed.o
+diff -pru diffutils-3.0/src/ifdef.c diffutils-3.0-patch/src/ifdef.c
+--- diffutils-3.0/src/ifdef.c	2018-06-07 18:22:43.446132000 -0700
++++ diffutils-3.0-patch/src/ifdef.c	2018-06-07 18:20:57.337084000 -0700
+@@ -1,7 +1,7 @@
+ /* #ifdef-format output routines for GNU DIFF.
+ 
+-   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2013, 2015-2018
+-   Free Software Foundation, Inc.
++   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -132,7 +132,7 @@ format_group (register FILE *out, char c
+ 	    break;
+ 
+ 	  case '(':
+-	    /* Print if-then-else format e.g. '%(n=1?thenpart:elsepart)'.  */
++	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
+ 	    {
+ 	      int i;
+ 	      uintmax_t value[2];
+@@ -357,22 +357,21 @@ do_printf_spec (FILE *out, char const *s
+ 
+ 	if (out)
+ 	  {
+-	    /* For example, if the spec is "%3xn" and pI is "l", use the printf
++	    /* For example, if the spec is "%3xn", use the printf
+ 	       format spec "%3lx".  Here the spec prefix is "%3".  */
+-	    printint print_value = value;
++	    long int long_value = value;
+ 	    size_t spec_prefix_len = f - spec - 2;
+-	    size_t pI_len = sizeof pI - 1;
+-#if 0
+-	    char format[spec_prefix_len + pI_len + 2];
++#if HAVE_C_VARARRAYS
++	    char format[spec_prefix_len + 3];
+ #else
+-	    char *format = xmalloc (spec_prefix_len + pI_len + 2);
++	    char *format = xmalloc (spec_prefix_len + 3);
+ #endif
+-	    char *p = format + spec_prefix_len + pI_len;
++	    char *p = format + spec_prefix_len;
+ 	    memcpy (format, spec, spec_prefix_len);
+-	    memcpy (format + spec_prefix_len, pI, pI_len);
++	    *p++ = 'l';
+ 	    *p++ = c;
+ 	    *p = '\0';
+-	    fprintf (out, format, print_value);
++	    fprintf (out, format, long_value);
+ #if ! HAVE_C_VARARRAYS
+ 	    free (format);
+ #endif
+Only in diffutils-3.0-patch/src: ifdef.o
+diff -pru diffutils-3.0/src/io.c diffutils-3.0-patch/src/io.c
+--- diffutils-3.0/src/io.c	2018-06-07 18:22:43.448130000 -0700
++++ diffutils-3.0-patch/src/io.c	2018-06-07 18:20:57.339084000 -0700
+@@ -1,7 +1,7 @@
+ /* File I/O for GNU DIFF.
+ 
+-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -19,7 +19,6 @@
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+ 
+ #include "diff.h"
+-#include <binary-io.h>
+ #include <cmpbuf.h>
+ #include <file-type.h>
+ #include <xalloc.h>
+@@ -58,10 +57,10 @@ static size_t nbuckets;
+    The number of an equivalence class is its index in this array.  */
+ static struct equivclass *equivs;
+ 
+-/* Index of first free element in the array 'equivs'.  */
++/* Index of first free element in the array `equivs'.  */
+ static lin equivs_index;
+ 
+-/* Number of elements allocated in the array 'equivs'.  */
++/* Number of elements allocated in the array `equivs'.  */
+ static lin equivs_alloc;
+ 
+ /* Read a block of data into a file buffer, checking for EOF and error.  */
+@@ -108,35 +107,15 @@ sip (struct file_data *current, bool ski
+ 				     PTRDIFF_MAX - 2 * sizeof (word));
+       current->buffer = xmalloc (current->bufsize);
+ 
+-#ifdef __KLIBC__
+-      /* Skip test if seek is not possible */
+-      skip_test = skip_test
+-		  || (lseek (current->desc, 0, SEEK_CUR) < 0
+-		      && errno == ESPIPE);
+-#endif
+-
+       if (! skip_test)
+ 	{
+ 	  /* Check first part of file to see if it's a binary file.  */
+ 
+-	  int prev_mode = set_binary_mode (current->desc, O_BINARY);
+-	  off_t buffered;
+-	  file_block_read (current, current->bufsize);
+-	  buffered = current->buffered;
+-
+-	  if (prev_mode != O_BINARY)
+-	    {
+-	      /* Revert to text mode and seek back to the start to reread
+-		 the file.  Use relative seek, since file descriptors
+-		 like stdin might not start at offset zero.  */
+-	      if (lseek (current->desc, - buffered, SEEK_CUR) < 0)
+-		pfatal_with_name (current->name);
+-	      set_binary_mode (current->desc, prev_mode);
+-	      current->buffered = 0;
+-	      current->eof = false;
+-	    }
++	  /* FIXME: if O_BINARY, this should revert to text mode
++	     if the file is not binary.  */
+ 
+-	  return binary_file_p (current->buffer, buffered);
++	  file_block_read (current, current->bufsize);
++	  return binary_file_p (current->buffer, current->buffered);
+ 	}
+     }
+ 
+@@ -219,7 +198,9 @@ slurp (struct file_data *current)
+ static void
+ find_and_hash_each_line (struct file_data *current)
+ {
++  hash_value h;
+   char const *p = current->prefix_end;
++  unsigned char c;
+   lin i, *bucket;
+   size_t length;
+ 
+@@ -234,70 +215,122 @@ find_and_hash_each_line (struct file_dat
+   lin eqs_alloc = equivs_alloc;
+   char const *suffix_begin = current->suffix_begin;
+   char const *bufend = FILE_BUFFER (current) + current->buffered;
+-  bool ig_case = ignore_case;
+-  enum DIFF_white_space ig_white_space = ignore_white_space;
+   bool diff_length_compare_anyway =
+-    ig_white_space != IGNORE_NO_WHITE_SPACE;
++    ignore_white_space != IGNORE_NO_WHITE_SPACE;
+   bool same_length_diff_contents_compare_anyway =
+-    diff_length_compare_anyway | ig_case;
++    diff_length_compare_anyway | ignore_case;
+ 
+   while (p < suffix_begin)
+     {
+       char const *ip = p;
+-      hash_value h = 0;
+-      unsigned char c;
++
++      h = 0;
+ 
+       /* Hash this line until we find a newline.  */
+-      switch (ig_white_space)
+-	{
+-	case IGNORE_ALL_SPACE:
+-	  while ((c = *p++) != '\n')
+-	    if (! isspace (c))
+-	      h = HASH (h, ig_case ? tolower (c) : c);
+-	  break;
++      if (ignore_case)
++	switch (ignore_white_space)
++	  {
++	  case IGNORE_ALL_SPACE:
++	    while ((c = *p++) != '\n')
++	      if (! isspace (c))
++		h = HASH (h, tolower (c));
++	    break;
++
++	  case IGNORE_SPACE_CHANGE:
++	    while ((c = *p++) != '\n')
++	      {
++		if (isspace (c))
++		  {
++		    do
++		      if ((c = *p++) == '\n')
++			goto hashing_done;
++		    while (isspace (c));
++
++		    h = HASH (h, ' ');
++		  }
+ 
+-	case IGNORE_SPACE_CHANGE:
+-	  while ((c = *p++) != '\n')
++		/* C is now the first non-space.  */
++		h = HASH (h, tolower (c));
++	      }
++	    break;
++
++	  case IGNORE_TAB_EXPANSION:
+ 	    {
+-	      if (isspace (c))
++	      size_t column = 0;
++	      while ((c = *p++) != '\n')
+ 		{
+-		  do
+-		    if ((c = *p++) == '\n')
+-		      goto hashing_done;
+-		  while (isspace (c));
++		  size_t repetitions = 1;
+ 
+-		  h = HASH (h, ' ');
+-		}
++		  switch (c)
++		    {
++		    case '\b':
++		      column -= 0 < column;
++		      break;
++
++		    case '\t':
++		      c = ' ';
++		      repetitions = tabsize - column % tabsize;
++		      column = (column + repetitions < column
++				? 0
++				: column + repetitions);
++		      break;
++
++		    case '\r':
++		      column = 0;
++		      break;
+ 
+-	      /* C is now the first non-space.  */
+-	      h = HASH (h, ig_case ? tolower (c) : c);
++		    default:
++		      c = tolower (c);
++		      column++;
++		      break;
++		    }
++
++		  do
++		    h = HASH (h, c);
++		  while (--repetitions != 0);
++		}
+ 	    }
+-	  break;
++	    break;
+ 
+-	case IGNORE_TAB_EXPANSION:
+-	case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
+-	case IGNORE_TRAILING_SPACE:
++	  default:
++	    while ((c = *p++) != '\n')
++	      h = HASH (h, tolower (c));
++	    break;
++	  }
++      else
++	switch (ignore_white_space)
+ 	  {
+-	    size_t column = 0;
++	  case IGNORE_ALL_SPACE:
++	    while ((c = *p++) != '\n')
++	      if (! isspace (c))
++		h = HASH (h, c);
++	    break;
++
++	  case IGNORE_SPACE_CHANGE:
+ 	    while ((c = *p++) != '\n')
+ 	      {
+-		if (ig_white_space & IGNORE_TRAILING_SPACE
+-		    && isspace (c))
++		if (isspace (c))
+ 		  {
+-		    char const *p1 = p;
+-		    unsigned char c1;
+ 		    do
+-		      if ((c1 = *p1++) == '\n')
+-			{
+-			  p = p1;
+-			  goto hashing_done;
+-			}
+-		    while (isspace (c1));
++		      if ((c = *p++) == '\n')
++			goto hashing_done;
++		    while (isspace (c));
++
++		    h = HASH (h, ' ');
+ 		  }
+ 
+-		size_t repetitions = 1;
++		/* C is now the first non-space.  */
++		h = HASH (h, c);
++	      }
++	    break;
++
++	  case IGNORE_TAB_EXPANSION:
++	    {
++	      size_t column = 0;
++	      while ((c = *p++) != '\n')
++		{
++		  size_t repetitions = 1;
+ 
+-		if (ig_white_space & IGNORE_TAB_EXPANSION)
+ 		  switch (c)
+ 		    {
+ 		    case '\b':
+@@ -321,25 +354,18 @@ find_and_hash_each_line (struct file_dat
+ 		      break;
+ 		    }
+ 
+-		if (ig_case)
+-		  c = tolower (c);
+-
+-		do
+-		  h = HASH (h, c);
+-		while (--repetitions != 0);
+-	      }
+-	  }
+-	  break;
++		  do
++		    h = HASH (h, c);
++		  while (--repetitions != 0);
++		}
++	    }
++	    break;
+ 
+-	default:
+-	  if (ig_case)
+-	    while ((c = *p++) != '\n')
+-	      h = HASH (h, tolower (c));
+-	  else
++	  default:
+ 	    while ((c = *p++) != '\n')
+ 	      h = HASH (h, c);
+-	  break;
+-	}
++	    break;
++	  }
+ 
+    hashing_done:;
+ 
+@@ -355,7 +381,7 @@ find_and_hash_each_line (struct file_dat
+ 	     complete line, put it into buckets[-1] so that it can
+ 	     compare equal only to the other file's incomplete line
+ 	     (if one exists).  */
+-	  if (ig_white_space < IGNORE_TRAILING_SPACE)
++	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+ 	    bucket = &buckets[-1];
+ 	}
+ 
+@@ -481,6 +507,7 @@ prepare_text (struct file_data *current)
+ {
+   size_t buffered = current->buffered;
+   char *p = FILE_BUFFER (current);
++  char *dst;
+ 
+   if (buffered == 0 || p[buffered - 1] == '\n')
+     current->missing_newline = false;
+@@ -496,25 +523,16 @@ prepare_text (struct file_data *current)
+   /* Don't use uninitialized storage when planting or using sentinels.  */
+   memset (p + buffered, 0, sizeof (word));
+ 
+-  if (strip_trailing_cr)
++  if (strip_trailing_cr && (dst = memchr (p, '\r', buffered)))
+     {
+-      char *dst;
+-      char *srclim = p + buffered;
+-      *srclim = '\r';
+-      dst = rawmemchr (p, '\r');
++      char const *src = dst;
++      char const *srclim = p + buffered;
+ 
+-      if (dst != srclim)
+-	{
+-	  char const *src = dst;
+-	  do
+-	    {
+-	      *dst = *src++;
+-	      dst += ! (*dst == '\r' && *src == '\n');
+-	    }
+-	  while (src < srclim);
++      do
++	dst += ! ((*dst = *src++) == '\r' && *src == '\n');
++      while (src < srclim);
+ 
+-	  buffered -= src - dst;
+-	}
++      buffered -= src - dst;
+     }
+ 
+   current->buffered = buffered;
+@@ -545,7 +563,6 @@ find_identical_ends (struct file_data fi
+   lin i, lines;
+   size_t n0, n1;
+   lin alloc_lines0, alloc_lines1;
+-  bool prefix_needed;
+   lin buffered_prefix, prefix_count, prefix_mask;
+   lin middle_guess, suffix_guess;
+ 
+@@ -695,13 +712,12 @@ find_identical_ends (struct file_data fi
+   prefix_mask = prefix_count - 1;
+   lines = 0;
+   linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
+-  prefix_needed = ! (no_diff_means_no_output
+-		     && filevec[0].prefix_end == p0
+-		     && filevec[1].prefix_end == p1);
+   p0 = buffer0;
+ 
+   /* If the prefix is needed, find the prefix lines.  */
+-  if (prefix_needed)
++  if (! (no_diff_means_no_output
++	 && filevec[0].prefix_end == p0
++	 && filevec[1].prefix_end == p1))
+     {
+       end0 = filevec[0].prefix_end;
+       while (p0 != end0)
+@@ -792,8 +808,7 @@ read_files (struct file_data filevec[],
+     }
+   if (appears_binary)
+     {
+-      set_binary_mode (filevec[0].desc, O_BINARY);
+-      set_binary_mode (filevec[1].desc, O_BINARY);
++      /* FIXME: If O_BINARY, this should set both files to binary mode.  */
+       return true;
+     }
+ 
+Only in diffutils-3.0-patch/src: io.o
+Only in diffutils-3.0-patch/src: Makefile
+diff -pru diffutils-3.0/src/Makefile.am diffutils-3.0-patch/src/Makefile.am
+--- diffutils-3.0/src/Makefile.am	2018-06-07 18:22:43.430130000 -0700
++++ diffutils-3.0-patch/src/Makefile.am	2018-06-07 18:20:57.324096000 -0700
+@@ -1,7 +1,6 @@
+ # Automakefile for GNU diffutils programs.
+ 
+-# Copyright (C) 2001-2002, 2006, 2009-2013, 2015-2018 Free Software Foundation,
+-# Inc.
++# Copyright (C) 2001-2002, 2006, 2009-2010 Free Software Foundation, Inc.
+ 
+ # This program is free software: you can redistribute it and/or modify
+ # it under the terms of the GNU General Public License as published by
+@@ -18,13 +17,14 @@
+ 
+ bin_PROGRAMS = cmp diff diff3 sdiff
+ 
++noinst_HEADERS = system.h
++
+ localedir = $(datadir)/locale
+ 
+ AM_CPPFLAGS = -I../lib -I$(top_srcdir)/lib
+ AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS)
+ 
+ LDADD = \
+-  libver.a \
+   ../lib/libdiffutils.a \
+   $(LIBCSTACK) \
+   $(LIBINTL) \
+@@ -41,12 +41,8 @@ cmp_SOURCES = cmp.c
+ diff3_SOURCES = diff3.c
+ sdiff_SOURCES = sdiff.c
+ diff_SOURCES = \
+-  analyze.c context.c diff.c dir.c ed.c ifdef.c io.c \
++  analyze.c context.c diff.c diff.h dir.c ed.c ifdef.c io.c \
+   normal.c side.c util.c
+-noinst_HEADERS =	\
+-  die.h			\
+-  diff.h		\
+-  system.h
+ 
+ MOSTLYCLEANFILES = paths.h paths.ht
+ 
+@@ -57,24 +53,3 @@ BUILT_SOURCES = paths.h
+ paths.h: Makefile.am
+ 	$(AM_V_GEN)(echo '#define DEFAULT_DIFF_PROGRAM "'$(gdiff)'"' && \
+ 	  echo '#define LOCALEDIR "$(localedir)"') >$@t && mv $@t $@
+-
+-noinst_LIBRARIES = libver.a
+-nodist_libver_a_SOURCES = version.c version.h
+-
+-BUILT_SOURCES += version.c
+-version.c: Makefile
+-	$(AM_V_GEN)rm -f $@
+-	$(AM_V_at)printf '#include <config.h>\n' > $@t
+-	$(AM_V_at)printf 'char const *Version = "$(PACKAGE_VERSION)";\n' >> $@t
+-	$(AM_V_at)chmod a-w $@t
+-	$(AM_V_at)mv $@t $@
+-
+-BUILT_SOURCES += version.h
+-version.h: Makefile
+-	$(AM_V_GEN)rm -f $@
+-	$(AM_V_at)printf 'extern char const *Version;\n' > $@t
+-	$(AM_V_at)chmod a-w $@t
+-	$(AM_V_at)mv $@t $@
+-
+-DISTCLEANFILES = version.c version.h
+-MAINTAINERCLEANFILES = $(BUILT_SOURCES)
+Only in diffutils-3.0-patch/src: Makefile.in
+diff -pru diffutils-3.0/src/normal.c diffutils-3.0-patch/src/normal.c
+--- diffutils-3.0/src/normal.c	2018-06-07 18:22:43.450130000 -0700
++++ diffutils-3.0-patch/src/normal.c	2018-06-07 18:20:57.323085000 -0700
+@@ -1,7 +1,7 @@
+ /* Normal-format output routines for GNU DIFF.
+ 
+-   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2013, 2015-2018
+-   Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -49,43 +49,21 @@ print_normal_hunk (struct change *hunk)
+   begin_output ();
+ 
+   /* Print out the line number header for this hunk */
+-  set_color_context (LINE_NUMBER_CONTEXT);
+   print_number_range (',', &files[0], first0, last0);
+   fputc (change_letter[changes], outfile);
+   print_number_range (',', &files[1], first1, last1);
+-  set_color_context (RESET_CONTEXT);
+   fputc ('\n', outfile);
+ 
+   /* Print the lines that the first file has.  */
+   if (changes & OLD)
+-    {
+-      if (first0 <= last0)
+-        set_color_context (DELETE_CONTEXT);
+-      for (i = first0; i <= last0; i++)
+-        {
+-          print_1_line_nl ("<", &files[0].linbuf[i], true);
+-          if (i == last0)
+-            set_color_context (RESET_CONTEXT);
+-          if (files[0].linbuf[i + 1][-1] == '\n')
+-            putc ('\n', outfile);
+-        }
+-    }
++    for (i = first0; i <= last0; i++)
++      print_1_line ("<", &files[0].linbuf[i]);
+ 
+   if (changes == CHANGED)
+     fputs ("---\n", outfile);
+ 
+   /* Print the lines that the second file has.  */
+   if (changes & NEW)
+-    {
+-      if (first1 <= last1)
+-        set_color_context (ADD_CONTEXT);
+-      for (i = first1; i <= last1; i++)
+-        {
+-          print_1_line_nl (">", &files[1].linbuf[i], true);
+-          if (i == last1)
+-            set_color_context (RESET_CONTEXT);
+-          if (files[1].linbuf[i + 1][-1] == '\n')
+-            putc ('\n', outfile);
+-        }
+-    }
++    for (i = first1; i <= last1; i++)
++      print_1_line (">", &files[1].linbuf[i]);
+ }
+Only in diffutils-3.0-patch/src: normal.o
+Only in diffutils-3.0-patch/src: paths.h
+Only in diffutils-3.0-patch/src: sdiff
+diff -pru diffutils-3.0/src/sdiff.c diffutils-3.0-patch/src/sdiff.c
+--- diffutils-3.0/src/sdiff.c	2018-06-07 18:22:43.424127000 -0700
++++ diffutils-3.0-patch/src/sdiff.c	2018-06-07 18:20:57.341084000 -0700
+@@ -1,7 +1,7 @@
+-/* GNU sdiff - side-by-side merge of file differences
++/* sdiff - side-by-side merge of file differences
+ 
+-   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -26,17 +26,16 @@
+ 
+ #include <c-stack.h>
+ #include <dirname.h>
+-#include "die.h"
+ #include <error.h>
+ #include <exitfail.h>
+ #include <file-type.h>
+ #include <getopt.h>
+ #include <progname.h>
+-#include <system-quote.h>
++#include <sh-quote.h>
+ #include <version-etc.h>
+ #include <xalloc.h>
+ 
+-/* The official name of this program (e.g., no 'g' prefix).  */
++/* The official name of this program (e.g., no `g' prefix).  */
+ #define PROGRAM_NAME "sdiff"
+ 
+ #define AUTHORS \
+@@ -51,7 +50,7 @@ static char const **diffargv;
+ static char * volatile tmpname;
+ static FILE *tmp;
+ 
+-#if HAVE_WORKING_FORK
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+ static pid_t volatile diffpid;
+ #endif
+ 
+@@ -67,6 +66,7 @@ static void perror_fatal (char const *)
+ static void trapsigs (void);
+ static void untrapsig (int);
+ 
++#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+ static int const sigs[] = {
+ #ifdef SIGHUP
+        SIGHUP,
+@@ -85,17 +85,14 @@ static int const sigs[] = {
+ #endif
+ #ifdef SIGPIPE
+        SIGPIPE,
++# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+ #endif
+        SIGINT
++#define handler_index_of_SIGINT (NUM_SIGS - 1)
+ };
+-enum
+-  {
+-    NUM_SIGS = sizeof sigs / sizeof *sigs,
+-    handler_index_of_SIGINT = NUM_SIGS - 1
+-  };
+ 
+ #if HAVE_SIGACTION
+-  /* Prefer 'sigaction' if available, since 'signal' can lose signals.  */
++  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+   static struct sigaction initial_action[NUM_SIGS];
+ # define initial_handler(i) (initial_action[i].sa_handler)
+   static void signal_handler (int, void (*) (int));
+@@ -105,6 +102,29 @@ enum
+ # define signal_handler(sig, handler) signal (sig, handler)
+ #endif
+ 
++#if ! HAVE_SIGPROCMASK
++# define sigset_t int
++# define sigemptyset(s) (*(s) = 0)
++# ifndef sigmask
++#  define sigmask(sig) (1 << ((sig) - 1))
++# endif
++# define sigaddset(s, sig) (*(s) |= sigmask (sig))
++# ifndef SIG_BLOCK
++#  define SIG_BLOCK 0
++# endif
++# ifndef SIG_SETMASK
++#  define SIG_SETMASK (! SIG_BLOCK)
++# endif
++# if ! HAVE_SIGBLOCK
++#  define sigblock(mask) (mask)
++#  define sigsetmask(mask) (mask)
++# endif
++# define sigprocmask(how, n, o) \
++    ((how) == SIG_BLOCK \
++     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
++     : sigsetmask (*(n)))
++#endif
++
+ static bool diraccess (char const *);
+ static int temporary_file (void);
+ 
+@@ -136,7 +156,6 @@ static struct option const longopts[] =
+   {"ignore-matching-lines", 1, 0, 'I'},
+   {"ignore-space-change", 0, 0, 'b'},
+   {"ignore-tab-expansion", 0, 0, 'E'},
+-  {"ignore-trailing-space", 0, 0, 'Z'},
+   {"left-column", 0, 0, 'l'},
+   {"minimal", 0, 0, 'd'},
+   {"output", 1, 0, 'o'},
+@@ -156,8 +175,9 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
++  abort ();
+ }
+ 
+ static void
+@@ -170,31 +190,30 @@ check_stdout (void)
+ }
+ 
+ static char const * const option_help_msgid[] = {
+-  N_("-o, --output=FILE            operate interactively, sending output to FILE"),
++  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+   "",
+-  N_("-i, --ignore-case            consider upper- and lower-case to be the same"),
+-  N_("-E, --ignore-tab-expansion   ignore changes due to tab expansion"),
+-  N_("-Z, --ignore-trailing-space  ignore white space at line end"),
+-  N_("-b, --ignore-space-change    ignore changes in the amount of white space"),
+-  N_("-W, --ignore-all-space       ignore all white space"),
+-  N_("-B, --ignore-blank-lines     ignore changes whose lines are all blank"),
+-  N_("-I, --ignore-matching-lines=RE  ignore changes all whose lines match RE"),
+-  N_("    --strip-trailing-cr      strip trailing carriage return on input"),
+-  N_("-a, --text                   treat all files as text"),
++  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
++  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
++  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
++  N_("-W  --ignore-all-space  Ignore all white space."),
++  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
++  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
++  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
++  N_("-a  --text  Treat all files as text."),
+   "",
+-  N_("-w, --width=NUM              output at most NUM (default 130) print columns"),
+-  N_("-l, --left-column            output only the left column of common lines"),
+-  N_("-s, --suppress-common-lines  do not output common lines"),
++  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
++  N_("-l  --left-column  Output only the left column of common lines."),
++  N_("-s  --suppress-common-lines  Do not output common lines."),
+   "",
+-  N_("-t, --expand-tabs            expand tabs to spaces in output"),
+-  N_("    --tabsize=NUM            tab stops at every NUM (default 8) print columns"),
++  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
++  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+   "",
+-  N_("-d, --minimal                try hard to find a smaller set of changes"),
+-  N_("-H, --speed-large-files      assume large files, many scattered small changes"),
+-  N_("    --diff-program=PROGRAM   use PROGRAM to compare files"),
++  N_("-d  --minimal  Try hard to find a smaller set of changes."),
++  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
++  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+   "",
+-  N_("    --help                   display this help and exit"),
+-  N_("-v, --version                output version information and exit"),
++  N_("-v  --version  Output version info."),
++  N_("--help  Output this help."),
+   0
+ };
+ 
+@@ -204,12 +223,7 @@ usage (void)
+   char const * const *p;
+ 
+   printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+-  printf ("%s\n\n",
+-          _("Side-by-side merge of differences between FILE1 and FILE2."));
+-
+-  fputs (_("\
+-Mandatory arguments to long options are mandatory for short options too.\n\
+-"), stdout);
++  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+   for (p = option_help_msgid;  *p;  p++)
+     if (**p)
+       printf ("  %s\n", _(*p));
+@@ -226,7 +240,7 @@ Mandatory arguments to long options are
+ static void
+ cleanup (int signo __attribute__((unused)))
+ {
+-#if HAVE_WORKING_FORK
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+   if (0 < diffpid)
+     kill (diffpid, SIGPIPE);
+ #endif
+@@ -379,8 +393,8 @@ lf_copy (struct line_filter *lf, lin lin
+ 
+   while (lines)
+     {
+-      lf->bufpos = rawmemchr (lf->bufpos, '\n');
+-      if (lf->bufpos == lf->buflim)
++      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
++      if (! lf->bufpos)
+ 	{
+ 	  ck_fwrite (start, lf->buflim - start, outfile);
+ 	  if (! lf_refill (lf))
+@@ -403,8 +417,8 @@ lf_skip (struct line_filter *lf, lin lin
+ {
+   while (lines)
+     {
+-      lf->bufpos = rawmemchr (lf->bufpos, '\n');
+-      if (lf->bufpos == lf->buflim)
++      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
++      if (! lf->bufpos)
+ 	{
+ 	  if (! lf_refill (lf))
+ 	    break;
+@@ -424,7 +438,7 @@ lf_snarf (struct line_filter *lf, char *
+   for (;;)
+     {
+       char *start = lf->bufpos;
+-      char *next = rawmemchr (start, '\n');
++      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+       size_t s = next - start;
+       if (bufsize <= s)
+ 	return 0;
+@@ -463,7 +477,7 @@ main (int argc, char *argv[])
+   diffarg (DEFAULT_DIFF_PROGRAM);
+ 
+   /* parse command line args */
+-  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:WZ", longopts, 0))
++  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+ 	 != -1)
+     {
+       switch (opt)
+@@ -518,7 +532,7 @@ main (int argc, char *argv[])
+ 	  break;
+ 
+ 	case 'v':
+-	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
++	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+ 		       AUTHORS, (char *) NULL);
+ 	  check_stdout ();
+ 	  return EXIT_SUCCESS;
+@@ -532,10 +546,6 @@ main (int argc, char *argv[])
+ 	  diffarg ("-w");
+ 	  break;
+ 
+-	case 'Z':
+-	  diffarg ("-Z");
+-	  break;
+-
+ 	case DIFF_PROGRAM_OPTION:
+ 	  diffargv[0] = optarg;
+ 	  break;
+@@ -608,9 +618,21 @@ main (int argc, char *argv[])
+ 
+       trapsigs ();
+ 
+-#if ! HAVE_WORKING_FORK
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+       {
+-	char *command = system_quote_argv (SCI_SYSTEM, (char **) diffargv);
++	size_t cmdsize = 1;
++	char *p, *command;
++	int i;
++
++	for (i = 0;  diffargv[i];  i++)
++	  cmdsize += shell_quote_length (diffargv[i]) + 1;
++	command = p = xmalloc (cmdsize);
++	for (i = 0;  diffargv[i];  i++)
++	  {
++	    p = shell_quote_copy (p, diffargv[i]);
++	    *p++ = ' ';
++	  }
++	p[-1] = 0;
+ 	errno = 0;
+ 	diffout = popen (command, "r");
+ 	if (! diffout)
+@@ -620,11 +642,22 @@ main (int argc, char *argv[])
+ #else
+       {
+ 	int diff_fds[2];
++# if HAVE_WORKING_VFORK
++	sigset_t procmask;
++	sigset_t blocked;
++# endif
+ 
+ 	if (pipe (diff_fds) != 0)
+ 	  perror_fatal ("pipe");
+ 
+-	diffpid = fork ();
++# if HAVE_WORKING_VFORK
++	/* Block SIGINT and SIGPIPE.  */
++	sigemptyset (&blocked);
++	sigaddset (&blocked, SIGINT);
++	sigaddset (&blocked, SIGPIPE);
++	sigprocmask (SIG_BLOCK, &blocked, &procmask);
++# endif
++	diffpid = vfork ();
+ 	if (diffpid < 0)
+ 	  perror_fatal ("fork");
+ 	if (! diffpid)
+@@ -636,6 +669,10 @@ main (int argc, char *argv[])
+ 	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+ 	      signal_handler (SIGINT, SIG_IGN);
+ 	    signal_handler (SIGPIPE, SIG_DFL);
++# if HAVE_WORKING_VFORK
++	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
++	    sigprocmask (SIG_SETMASK, &procmask, 0);
++# endif
+ 	    close (diff_fds[0]);
+ 	    if (diff_fds[1] != STDOUT_FILENO)
+ 	      {
+@@ -647,6 +684,19 @@ main (int argc, char *argv[])
+ 	    _exit (errno == ENOENT ? 127 : 126);
+ 	  }
+ 
++# if HAVE_WORKING_VFORK
++	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
++	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
++	  signal_handler (SIGINT, catchsig);
++	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
++	  signal_handler (SIGPIPE, catchsig);
++	else
++	  signal_handler (SIGPIPE, SIG_IGN);
++
++	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
++	sigprocmask (SIG_SETMASK, &procmask, 0);
++# endif
++
+ 	close (diff_fds[1]);
+ 	diffout = fdopen (diff_fds[0], "r");
+ 	if (! diffout)
+@@ -668,7 +718,7 @@ main (int argc, char *argv[])
+ 	int wstatus;
+ 	int werrno = 0;
+ 
+-#if ! HAVE_WORKING_FORK
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+ 	wstatus = pclose (diffout);
+ 	if (wstatus == -1)
+ 	  werrno = errno;
+@@ -805,7 +855,7 @@ checksigs (void)
+ 
+       /* Yield an exit status indicating that a signal was received.  */
+       untrapsig (s);
+-      raise (s);
++      kill (getpid (), s);
+ 
+       /* That didn't work, so exit with error status.  */
+       exit (EXIT_TROUBLE);
+@@ -918,10 +968,10 @@ edit (struct line_filter *left, char con
+ 		  cmd0 = 'q';
+ 		  break;
+ 		}
+-	      FALLTHROUGH;
++	      /* Fall through.  */
+ 	    default:
+ 	      flush_line ();
+-	      FALLTHROUGH;
++	      /* Fall through.  */
+ 	    case '\n':
+ 	      give_help ();
+ 	      continue;
+@@ -967,14 +1017,14 @@ edit (struct line_filter *left, char con
+ 	      case 'd':
+ 		if (llen)
+ 		  {
+-		    printint l1 = lline;
+-		    printint l2 = lline + llen - 1;
+ 		    if (llen == 1)
+-		      fprintf (tmp, "--- %s %"pI"d\n", lname, l1);
++		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+ 		    else
+-		      fprintf (tmp, "--- %s %"pI"d,%"pI"d\n", lname, l1, l2);
++		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
++			       (long int) lline,
++			       (long int) (lline + llen - 1));
+ 		  }
+-		FALLTHROUGH;
++		/* Fall through.  */
+ 	      case '1': case 'b': case 'l':
+ 		lf_copy (left, llen, tmp);
+ 		break;
+@@ -989,14 +1039,14 @@ edit (struct line_filter *left, char con
+ 	      case 'd':
+ 		if (rlen)
+ 		  {
+-		    printint l1 = rline;
+-		    printint l2 = rline + rlen - 1;
+ 		    if (rlen == 1)
+-		      fprintf (tmp, "+++ %s %"pI"d\n", rname, l1);
++		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+ 		    else
+-		      fprintf (tmp, "+++ %s %"pI"d,%"pI"d\n", rname, l1, l2);
++		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
++			       (long int) rline,
++			       (long int) (rline + rlen - 1));
+ 		  }
+-		FALLTHROUGH;
++		/* Fall through.  */
+ 	      case '2': case 'b': case 'r':
+ 		lf_copy (right, rlen, tmp);
+ 		break;
+@@ -1011,17 +1061,16 @@ edit (struct line_filter *left, char con
+ 	    {
+ 	      int wstatus;
+ 	      int werrno = 0;
+-	      char const *argv[3];
+-
+ 	      ignore_SIGINT = true;
+ 	      checksigs ();
+-	      argv[0] = editor_program;
+-	      argv[1] = tmpname;
+-	      argv[2] = 0;
+ 
+ 	      {
+-#if ! HAVE_WORKING_FORK
+-		char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
++		char *command =
++		  xmalloc (shell_quote_length (editor_program)
++			   + 1 + strlen (tmpname) + 1);
++		sprintf (shell_quote_copy (command, editor_program),
++			 " %s", tmpname);
+ 		wstatus = system (command);
+ 		if (wstatus == -1)
+ 		  werrno = errno;
+@@ -1029,9 +1078,16 @@ edit (struct line_filter *left, char con
+ #else
+ 		pid_t pid;
+ 
+-		pid = fork ();
++		pid = vfork ();
+ 		if (pid == 0)
+ 		  {
++		    char const *argv[3];
++		    int i = 0;
++
++		    argv[i++] = editor_program;
++		    argv[i++] = tmpname;
++		    argv[i] = 0;
++
+ 		    execvp (editor_program, (char **) argv);
+ 		    _exit (errno == ENOENT ? 127 : 126);
+ 		  }
+@@ -1099,14 +1155,12 @@ interact (struct line_filter *diff,
+ 	  uintmax_t val;
+ 	  lin llen, rlen, lenmax;
+ 	  errno = 0;
+-	  val = strtoumax (diff_help + 1, &numend, 10);
+-	  if (LIN_MAX < val || errno || *numend != ',')
++	  llen = val = strtoumax (diff_help + 1, &numend, 10);
++	  if (llen < 0 || llen != val || errno || *numend != ',')
+ 	    fatal (diff_help);
+-	  llen = val;
+-	  val = strtoumax (numend + 1, &numend, 10);
+-	  if (LIN_MAX < val || errno || *numend)
++	  rlen = val = strtoumax (numend + 1, &numend, 10);
++	  if (rlen < 0 || rlen != val || errno || *numend)
+ 	    fatal (diff_help);
+-	  rlen = val;
+ 
+ 	  lenmax = MAX (llen, rlen);
+ 
+@@ -1165,9 +1219,18 @@ temporary_file (void)
+   char const *dir = tmpdir ? tmpdir : P_tmpdir;
+   char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+   int fd;
++  int e;
++  sigset_t procmask;
++  sigset_t blocked;
+   sprintf (buf, "%s/sdiffXXXXXX", dir);
++  sigemptyset (&blocked);
++  sigaddset (&blocked, SIGINT);
++  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+   fd = mkstemp (buf);
++  e = errno;
+   if (0 <= fd)
+     tmpname = buf;
++  sigprocmask (SIG_SETMASK, &procmask, 0);
++  errno = e;
+   return fd;
+ }
+Only in diffutils-3.0-patch/src: sdiff.o
+diff -pru diffutils-3.0/src/side.c diffutils-3.0-patch/src/side.c
+--- diffutils-3.0/src/side.c	2018-06-07 18:22:43.425129000 -0700
++++ diffutils-3.0-patch/src/side.c	2018-06-07 18:20:57.342085000 -0700
+@@ -1,7 +1,7 @@
+ /* sdiff-format output routines for GNU DIFF.
+ 
+-   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2013, 2015-2018 Free
+-   Software Foundation, Inc.
++   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2010 Free Software
++   Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -150,7 +150,7 @@ print_half_line (char const *const *line
+ 		break;
+ 	      }
+ 	  }
+-	  FALLTHROUGH;
++	  /* Fall through.  */
+ 	case '\f':
+ 	case '\v':
+ 	  if (in_position < out_bound)
+@@ -206,18 +206,6 @@ print_1sdiff_line (char const *const *le
+   size_t c2o = sdiff_column2_offset;
+   size_t col = 0;
+   bool put_newline = false;
+-  bool color_to_reset = false;
+-
+-  if (sep == '<')
+-    {
+-      set_color_context (DELETE_CONTEXT);
+-      color_to_reset = true;
+-    }
+-  else if (sep == '>')
+-    {
+-      set_color_context (ADD_CONTEXT);
+-      color_to_reset = true;
+-    }
+ 
+   if (left)
+     {
+@@ -245,9 +233,6 @@ print_1sdiff_line (char const *const *le
+ 
+   if (put_newline)
+     putc ('\n', out);
+-
+-  if (color_to_reset)
+-    set_color_context (RESET_CONTEXT);
+ }
+ 
+ /* Print lines common to both files in side-by-side format.  */
+@@ -260,9 +245,9 @@ print_sdiff_common_lines (lin limit0, li
+     {
+       if (sdiff_merge_assist)
+ 	{
+-	  printint len0 = limit0 - i0;
+-	  printint len1 = limit1 - i1;
+-	  fprintf (outfile, "i%"pI"d,%"pI"d\n", len0, len1);
++	  long int len0 = limit0 - i0;
++	  long int len1 = limit1 - i1;
++	  fprintf (outfile, "i%ld,%ld\n", len0, len1);
+ 	}
+ 
+       if (!left_column)
+@@ -302,12 +287,12 @@ print_sdiff_hunk (struct change *hunk)
+ 
+   if (sdiff_merge_assist)
+     {
+-      printint len0 = last0 - first0 + 1;
+-      printint len1 = last1 - first1 + 1;
+-      fprintf (outfile, "c%"pI"d,%"pI"d\n", len0, len1);
++      long int len0 = last0 - first0 + 1;
++      long int len1 = last1 - first1 + 1;
++      fprintf (outfile, "c%ld,%ld\n", len0, len1);
+     }
+ 
+-  /* Print "xxx  |  xxx " lines.  */
++  /* Print ``xxx  |  xxx '' lines */
+   if (changes == CHANGED)
+     {
+       for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+@@ -317,7 +302,7 @@ print_sdiff_hunk (struct change *hunk)
+       next1 = first1 = j;
+     }
+ 
+-  /* Print "     >  xxx " lines.  */
++  /* Print ``     >  xxx '' lines */
+   if (changes & NEW)
+     {
+       for (j = first1; j <= last1; ++j)
+@@ -325,7 +310,7 @@ print_sdiff_hunk (struct change *hunk)
+       next1 = j;
+     }
+ 
+-  /* Print "xxx  <     " lines.  */
++  /* Print ``xxx  <     '' lines */
+   if (changes & OLD)
+     {
+       for (i = first0; i <= last0; ++i)
+Only in diffutils-3.0-patch/src: side.o
+diff -pru diffutils-3.0/src/system.h diffutils-3.0-patch/src/system.h
+--- diffutils-3.0/src/system.h	2018-06-07 18:22:43.427128000 -0700
++++ diffutils-3.0-patch/src/system.h	2018-06-07 18:20:57.344085000 -0700
+@@ -1,7 +1,7 @@
+ /* System dependent declarations.
+ 
+-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -20,14 +20,14 @@
+ 
+ #include <config.h>
+ 
+-/* Use this to suppress gcc's "...may be used before initialized" warnings. */
++/* Use this to suppress gcc's `...may be used before initialized' warnings. */
+ #ifdef lint
+ # define IF_LINT(Code) Code
+ #else
+ # define IF_LINT(Code) /* empty */
+ #endif
+ 
+-/* Define '__attribute__' and 'volatile' first
++/* Define `__attribute__' and `volatile' first
+    so that they're used consistently in all system includes.  */
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6) || __STRICT_ANSI__
+ # define __attribute__(x)
+@@ -54,6 +54,12 @@
+ #include <time.h>
+ 
+ #include <sys/wait.h>
++#ifndef WEXITSTATUS
++# define WEXITSTATUS(stat_val) ((unsigned int) (stat_val) >> 8)
++#endif
++#ifndef WIFEXITED
++# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
++#endif
+ 
+ #include <dirent.h>
+ #ifndef _D_EXACT_NAMLEN
+@@ -99,12 +105,19 @@ int strcasecmp (char const *, char const
+    - It's typically faster.
+    POSIX 1003.1-2001 says that only '0' through '9' are digits.
+    Prefer ISDIGIT to isdigit unless it's important to use the locale's
+-   definition of 'digit' even when the host does not conform to POSIX.  */
++   definition of `digit' even when the host does not conform to POSIX.  */
+ #define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)
+ 
+ #include <errno.h>
+ 
+ #include <signal.h>
++#ifndef SA_RESTART
++# ifdef SA_INTERRUPT /* e.g. SunOS 4.1.x */
++#  define SA_RESTART SA_INTERRUPT
++# else
++#  define SA_RESTART 0
++# endif
++#endif
+ #if !defined SIGCHLD && defined SIGCLD
+ # define SIGCHLD SIGCLD
+ #endif
+@@ -115,49 +128,32 @@ int strcasecmp (char const *, char const
+ #define MAX(a, b) ((a) >= (b) ? (a) : (b))
+ 
+ #include <stdbool.h>
++
++#if HAVE_VFORK_H
++# include <vfork.h>
++#endif
++
++#if ! HAVE_WORKING_VFORK
++# define vfork fork
++#endif
++
+ #include <intprops.h>
+ #include "propername.h"
+-#include "version.h"
+ 
+-/* Type used for fast comparison of several bytes at a time.
+-   This used to be uintmax_t, but changing it to size_t
+-   made plain 'cmp' 90% faster (GCC 4.8.1, x86).  */
++/* Type used for fast comparison of several bytes at a time.  */
+ 
+ #ifndef word
+-# define word size_t
++# define word uintmax_t
+ #endif
+ 
+-/* The signed integer type of a line number.  Since files are read
+-   into main memory, ptrdiff_t should be wide enough.  */
++/* The integer type of a line number.  Since files are read into main
++   memory, ptrdiff_t should be wide enough.  */
+ 
+ typedef ptrdiff_t lin;
+ #define LIN_MAX PTRDIFF_MAX
+-
+-/* The signed integer type for printing line numbers, and its printf
+-   length modifier.  This is not simply ptrdiff_t, to cater to older
+-   and/or nonstandard C libraries where "l" works but "ll" and "t" do
+-   not, or where 'long' is too narrow and "ll" works but "t" does not.  */
+-
+-#if LIN_MAX <= LONG_MAX
+-typedef long int printint;
+-# define pI "l"
+-#elif LIN_MAX <= LLONG_MAX
+-typedef long long int printint;
+-# define pI "ll"
+-#else
+-typedef ptrdiff_t printint;
+-# define pI "t"
+-#endif
+-
+ verify (TYPE_SIGNED (lin));
+-verify (TYPE_SIGNED (printint));
+-verify (LIN_MAX == TYPE_MAXIMUM (lin));
+-verify (LIN_MAX <= TYPE_MAXIMUM (printint));
+-
+-/* Limit so that 2 * CONTEXT + 1 does not overflow.  */
+-
+-#define CONTEXT_MAX ((LIN_MAX - 1) / 2)
+-
++verify (sizeof (ptrdiff_t) <= sizeof (lin));
++verify (sizeof (lin) <= sizeof (long int));
+ 
+ /* This section contains POSIX-compliant defaults for macros
+    that are meant to be overridden by hand in config.h as needed.  */
+@@ -176,7 +172,7 @@ verify (LIN_MAX <= TYPE_MAXIMUM (printin
+ 
+ /* Do struct stat *S, *T describe the same special file?  */
+ #ifndef same_special_file
+-# if HAVE_STRUCT_STAT_ST_RDEV && defined S_ISBLK && defined S_ISCHR
++# if HAVE_ST_RDEV && defined S_ISBLK && defined S_ISCHR
+ #  define same_special_file(s, t) \
+      (((S_ISBLK ((s)->st_mode) && S_ISBLK ((t)->st_mode)) \
+        || (S_ISCHR ((s)->st_mode) && S_ISCHR ((t)->st_mode))) \
+@@ -230,11 +226,3 @@ verify (LIN_MAX <= TYPE_MAXIMUM (printin
+ #endif
+ 
+ #define STREQ(a, b) (strcmp (a, b) == 0)
+-
+-#ifndef FALLTHROUGH
+-# if __GNUC__ < 7
+-#  define FALLTHROUGH ((void) 0)
+-# else
+-#  define FALLTHROUGH __attribute__ ((__fallthrough__))
+-# endif
+-#endif
+diff -pru diffutils-3.0/src/util.c diffutils-3.0-patch/src/util.c
+--- diffutils-3.0/src/util.c	2018-06-07 18:22:43.429128000 -0700
++++ diffutils-3.0-patch/src/util.c	2018-06-07 18:20:57.345085000 -0700
+@@ -1,7 +1,7 @@
+ /* Support routines for GNU DIFF.
+ 
+-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2018 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -19,34 +19,15 @@
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+ 
+ #include "diff.h"
+-#include "argmatch.h"
+-#include "die.h"
+ #include <dirname.h>
+ #include <error.h>
+-#include <system-quote.h>
++#include <sh-quote.h>
+ #include <xalloc.h>
+-#include "xvasprintf.h"
+-#include <signal.h>
+-
+-/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
+-   present.  */
+-#ifndef SA_NOCLDSTOP
+-# define SA_NOCLDSTOP 0
+-# define sigprocmask(How, Set, Oset) /* empty */
+-# define sigset_t int
+-# if ! HAVE_SIGINTERRUPT
+-#  define siginterrupt(sig, flag) /* empty */
+-# endif
+-#endif
+-
+-#ifndef SA_RESTART
+-# define SA_RESTART 0
+-#endif
+ 
+ char const pr_program[] = PR_PROGRAM;
+ 
+ /* Queue up one-line messages to be printed at the end,
+-   when -l is specified.  Each message is recorded with a 'struct msg'.  */
++   when -l is specified.  Each message is recorded with a `struct msg'.  */
+ 
+ struct msg
+ {
+@@ -78,7 +59,8 @@ pfatal_with_name (char const *name)
+ {
+   int e = errno;
+   print_message_queue ();
+-  die (EXIT_TROUBLE, e, "%s", name);
++  error (EXIT_TROUBLE, e, "%s", name);
++  abort ();
+ }
+ 
+ /* Print an error message containing MSGID, then exit.  */
+@@ -87,7 +69,8 @@ void
+ fatal (char const *msgid)
+ {
+   print_message_queue ();
+-  die (EXIT_TROUBLE, 0, "%s", _(msgid));
++  error (EXIT_TROUBLE, 0, "%s", _(msgid));
++  abort ();
+ }
+ 
+ /* Like printf, except if -l in effect then save the message and print later.
+@@ -138,7 +121,7 @@ message5 (char const *format_msgid, char
+     }
+ }
+ 
+-/* Output all the messages that were saved up by calls to 'message'.  */
++/* Output all the messages that were saved up by calls to `message'.  */
+ 
+ void
+ print_message_queue (void)
+@@ -159,574 +142,16 @@ print_message_queue (void)
+     }
+ }
+ 
+-/* The set of signals that are caught.  */
+-
+-static sigset_t caught_signals;
+-
+-/* If nonzero, the value of the pending fatal signal.  */
+-
+-static sig_atomic_t volatile interrupt_signal;
+-
+-/* A count of the number of pending stop signals that have been received.  */
+-
+-static sig_atomic_t volatile stop_signal_count;
+-
+-/* An ordinary signal was received; arrange for the program to exit.  */
+-
+-static void
+-sighandler (int sig)
+-{
+-  if (! SA_NOCLDSTOP)
+-    signal (sig, SIG_IGN);
+-  if (! interrupt_signal)
+-    interrupt_signal = sig;
+-}
+-
+-/* A SIGTSTP was received; arrange for the program to suspend itself.  */
+-
+-static void
+-stophandler (int sig)
+-{
+-  if (! SA_NOCLDSTOP)
+-    signal (sig, stophandler);
+-  if (! interrupt_signal)
+-    stop_signal_count++;
+-}
+-/* Process any pending signals.  If signals are caught, this function
+-   should be called periodically.  Ideally there should never be an
+-   unbounded amount of time when signals are not being processed.
+-   Signal handling can restore the default colors, so callers must
+-   immediately change colors after invoking this function.  */
+-
+-static void
+-process_signals (void)
+-{
+-  while (interrupt_signal || stop_signal_count)
+-    {
+-      int sig;
+-      int stops;
+-      sigset_t oldset;
+-
+-      set_color_context (RESET_CONTEXT);
+-      fflush (stdout);
+-
+-      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
+-
+-      /* Reload interrupt_signal and stop_signal_count, in case a new
+-         signal was handled before sigprocmask took effect.  */
+-      sig = interrupt_signal;
+-      stops = stop_signal_count;
+-
+-      /* SIGTSTP is special, since the application can receive that signal
+-         more than once.  In this case, don't set the signal handler to the
+-         default.  Instead, just raise the uncatchable SIGSTOP.  */
+-      if (stops)
+-        {
+-          stop_signal_count = stops - 1;
+-          sig = SIGSTOP;
+-        }
+-      else
+-        signal (sig, SIG_DFL);
+-
+-      /* Exit or suspend the program.  */
+-      raise (sig);
+-      sigprocmask (SIG_SETMASK, &oldset, NULL);
+-
+-      /* If execution reaches here, then the program has been
+-         continued (after being suspended).  */
+-    }
+-}
+-
+-static void
+-install_signal_handlers (void)
+-{
+-  /* The signals that are trapped, and the number of such signals.  */
+-  static int const sig[] =
+-    {
+-      /* This one is handled specially.  */
+-      SIGTSTP,
+-
+-      /* The usual suspects.  */
+-      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+-#ifdef SIGPOLL
+-      SIGPOLL,
+-#endif
+-#ifdef SIGPROF
+-      SIGPROF,
+-#endif
+-#ifdef SIGVTALRM
+-      SIGVTALRM,
+-#endif
+-#ifdef SIGXCPU
+-      SIGXCPU,
+-#endif
+-#ifdef SIGXFSZ
+-      SIGXFSZ,
+-#endif
+-    };
+-  enum { nsigs = sizeof (sig) / sizeof *(sig) };
+-
+-#if ! SA_NOCLDSTOP
+-  bool caught_sig[nsigs];
+-#endif
+-  {
+-    int j;
+-#if SA_NOCLDSTOP
+-    struct sigaction act;
+-
+-    sigemptyset (&caught_signals);
+-    for (j = 0; j < nsigs; j++)
+-      {
+-        sigaction (sig[j], NULL, &act);
+-        if (act.sa_handler != SIG_IGN)
+-          sigaddset (&caught_signals, sig[j]);
+-      }
+-
+-    act.sa_mask = caught_signals;
+-    act.sa_flags = SA_RESTART;
++/* Call before outputting the results of comparing files NAME0 and NAME1
++   to set up OUTFILE, the stdio stream for the output to go to.
+ 
+-    for (j = 0; j < nsigs; j++)
+-      if (sigismember (&caught_signals, sig[j]))
+-        {
+-          act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
+-          sigaction (sig[j], &act, NULL);
+-        }
+-#else
+-    for (j = 0; j < nsigs; j++)
+-      {
+-        caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
+-        if (caught_sig[j])
+-          {
+-            signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
+-            siginterrupt (sig[j], 0);
+-          }
+-      }
+-#endif
+-    }
+-}
++   Usually, OUTFILE is just stdout.  But when -l was specified
++   we fork off a `pr' and make OUTFILE a pipe to it.
++   `pr' then outputs to our stdout.  */
+ 
+ static char const *current_name0;
+ static char const *current_name1;
+ static bool currently_recursive;
+-static bool colors_enabled;
+-
+-static struct color_ext_type *color_ext_list = NULL;
+-
+-struct bin_str
+-  {
+-    size_t len;			/* Number of bytes */
+-    const char *string;		/* Pointer to the same */
+-  };
+-
+-struct color_ext_type
+-  {
+-    struct bin_str ext;		/* The extension we're looking for */
+-    struct bin_str seq;		/* The sequence to output when we do */
+-    struct color_ext_type *next;	/* Next in list */
+-  };
+-
+-/* Parse a string as part of the --palette argument; this may involve
+-   decoding all kinds of escape characters.  If equals_end is set an
+-   unescaped equal sign ends the string, otherwise only a : or \0
+-   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
+-   true if successful.
+-
+-   The resulting string is *not* null-terminated, but may contain
+-   embedded nulls.
+-
+-   Note that both dest and src are char **; on return they point to
+-   the first free byte after the array and the character that ended
+-   the input string, respectively.  */
+-
+-static bool
+-get_funky_string (char **dest, const char **src, bool equals_end,
+-                  size_t *output_count)
+-{
+-  char num;			/* For numerical codes */
+-  size_t count;			/* Something to count with */
+-  enum {
+-    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
+-  } state;
+-  const char *p;
+-  char *q;
+-
+-  p = *src;			/* We don't want to double-indirect */
+-  q = *dest;			/* the whole darn time.  */
+-
+-  count = 0;			/* No characters counted in yet.  */
+-  num = 0;
+-
+-  state = ST_GND;		/* Start in ground state.  */
+-  while (state < ST_END)
+-    {
+-      switch (state)
+-        {
+-        case ST_GND:		/* Ground state (no escapes) */
+-          switch (*p)
+-            {
+-            case ':':
+-            case '\0':
+-              state = ST_END;	/* End of string */
+-              break;
+-            case '\\':
+-              state = ST_BACKSLASH; /* Backslash scape sequence */
+-              ++p;
+-              break;
+-            case '^':
+-              state = ST_CARET; /* Caret escape */
+-              ++p;
+-              break;
+-            case '=':
+-              if (equals_end)
+-                {
+-                  state = ST_END; /* End */
+-                  break;
+-                }
+-              FALLTHROUGH;
+-            default:
+-              *(q++) = *(p++);
+-              ++count;
+-              break;
+-            }
+-          break;
+-
+-        case ST_BACKSLASH:	/* Backslash escaped character */
+-          switch (*p)
+-            {
+-            case '0':
+-            case '1':
+-            case '2':
+-            case '3':
+-            case '4':
+-            case '5':
+-            case '6':
+-            case '7':
+-              state = ST_OCTAL;	/* Octal sequence */
+-              num = *p - '0';
+-              break;
+-            case 'x':
+-            case 'X':
+-              state = ST_HEX;	/* Hex sequence */
+-              num = 0;
+-              break;
+-            case 'a':		/* Bell */
+-              num = '\a';
+-              break;
+-            case 'b':		/* Backspace */
+-              num = '\b';
+-              break;
+-            case 'e':		/* Escape */
+-              num = 27;
+-              break;
+-            case 'f':		/* Form feed */
+-              num = '\f';
+-              break;
+-            case 'n':		/* Newline */
+-              num = '\n';
+-              break;
+-            case 'r':		/* Carriage return */
+-              num = '\r';
+-              break;
+-            case 't':		/* Tab */
+-              num = '\t';
+-              break;
+-            case 'v':		/* Vtab */
+-              num = '\v';
+-              break;
+-            case '?':		/* Delete */
+-              num = 127;
+-              break;
+-            case '_':		/* Space */
+-              num = ' ';
+-              break;
+-            case '\0':		/* End of string */
+-              state = ST_ERROR;	/* Error! */
+-              break;
+-            default:		/* Escaped character like \ ^ : = */
+-              num = *p;
+-              break;
+-            }
+-          if (state == ST_BACKSLASH)
+-            {
+-              *(q++) = num;
+-              ++count;
+-              state = ST_GND;
+-            }
+-          ++p;
+-          break;
+-
+-        case ST_OCTAL:		/* Octal sequence */
+-          if (*p < '0' || *p > '7')
+-            {
+-              *(q++) = num;
+-              ++count;
+-              state = ST_GND;
+-            }
+-          else
+-            num = (num << 3) + (*(p++) - '0');
+-          break;
+-
+-        case ST_HEX:		/* Hex sequence */
+-          switch (*p)
+-            {
+-            case '0':
+-            case '1':
+-            case '2':
+-            case '3':
+-            case '4':
+-            case '5':
+-            case '6':
+-            case '7':
+-            case '8':
+-            case '9':
+-              num = (num << 4) + (*(p++) - '0');
+-              break;
+-            case 'a':
+-            case 'b':
+-            case 'c':
+-            case 'd':
+-            case 'e':
+-            case 'f':
+-              num = (num << 4) + (*(p++) - 'a') + 10;
+-              break;
+-            case 'A':
+-            case 'B':
+-            case 'C':
+-            case 'D':
+-            case 'E':
+-            case 'F':
+-              num = (num << 4) + (*(p++) - 'A') + 10;
+-              break;
+-            default:
+-              *(q++) = num;
+-              ++count;
+-              state = ST_GND;
+-              break;
+-            }
+-          break;
+-
+-        case ST_CARET:		/* Caret escape */
+-          state = ST_GND;	/* Should be the next state... */
+-          if (*p >= '@' && *p <= '~')
+-            {
+-              *(q++) = *(p++) & 037;
+-              ++count;
+-            }
+-          else if (*p == '?')
+-            {
+-              *(q++) = 127;
+-              ++count;
+-            }
+-          else
+-            state = ST_ERROR;
+-          break;
+-
+-        default:
+-          abort ();
+-        }
+-    }
+-
+-  *dest = q;
+-  *src = p;
+-  *output_count = count;
+-
+-  return state != ST_ERROR;
+-}
+-
+-enum parse_state
+-  {
+-    PS_START = 1,
+-    PS_2,
+-    PS_3,
+-    PS_4,
+-    PS_DONE,
+-    PS_FAIL
+-  };
+-
+-#define LEN_STR_PAIR(s) sizeof (s) - 1, s
+-
+-static struct bin_str color_indicator[] =
+-  {
+-    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
+-    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
+-    { 0, NULL },			/* ec: End color (replaces lc+rs+rc) */
+-    { LEN_STR_PAIR ("0") },		/* rs: Reset to ordinary colors */
+-    { LEN_STR_PAIR ("1") },		/* hd: Header */
+-    { LEN_STR_PAIR ("32") },		/* ad: Add line */
+-    { LEN_STR_PAIR ("31") },		/* de: Delete line */
+-    { LEN_STR_PAIR ("36") },		/* ln: Line number */
+-  };
+-
+-static const char *const indicator_name[] =
+-  {
+-    "lc", "rc", "ec", "rs", "hd", "ad", "de", "ln", NULL
+-  };
+-ARGMATCH_VERIFY (indicator_name, color_indicator);
+-
+-static char const *color_palette;
+-
+-void
+-set_color_palette (char const *palette)
+-{
+-  color_palette = palette;
+-}
+-
+-static void
+-parse_diff_color (void)
+-{
+-  char *color_buf;
+-  const char *p;		/* Pointer to character being parsed */
+-  char *buf;			/* color_buf buffer pointer */
+-  int ind_no;			/* Indicator number */
+-  char label[3];		/* Indicator label */
+-  struct color_ext_type *ext;	/* Extension we are working on */
+-
+-  if ((p = color_palette) == NULL || *p == '\0')
+-    return;
+-
+-  ext = NULL;
+-  strcpy (label, "??");
+-
+-  /* This is an overly conservative estimate, but any possible
+-     --palette string will *not* generate a color_buf longer than
+-     itself, so it is a safe way of allocating a buffer in
+-     advance.  */
+-  buf = color_buf = xstrdup (p);
+-
+-  enum parse_state state = PS_START;
+-  while (true)
+-    {
+-      switch (state)
+-        {
+-        case PS_START:		/* First label character */
+-          switch (*p)
+-            {
+-            case ':':
+-              ++p;
+-              break;
+-
+-            case '*':
+-              /* Allocate new extension block and add to head of
+-                 linked list (this way a later definition will
+-                 override an earlier one, which can be useful for
+-                 having terminal-specific defs override global).  */
+-
+-              ext = xmalloc (sizeof *ext);
+-              ext->next = color_ext_list;
+-              color_ext_list = ext;
+-
+-              ++p;
+-              ext->ext.string = buf;
+-
+-              state = (get_funky_string (&buf, &p, true, &ext->ext.len)
+-                       ? PS_4 : PS_FAIL);
+-              break;
+-
+-            case '\0':
+-              state = PS_DONE;	/* Done! */
+-              goto done;
+-
+-            default:	/* Assume it is file type label */
+-              label[0] = *(p++);
+-              state = PS_2;
+-              break;
+-            }
+-          break;
+-
+-        case PS_2:		/* Second label character */
+-          if (*p)
+-            {
+-              label[1] = *(p++);
+-              state = PS_3;
+-            }
+-          else
+-            state = PS_FAIL;	/* Error */
+-          break;
+-
+-        case PS_3:		/* Equal sign after indicator label */
+-          state = PS_FAIL;	/* Assume failure...  */
+-          if (*(p++) == '=')/* It *should* be...  */
+-            {
+-              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
+-                {
+-                  if (STREQ (label, indicator_name[ind_no]))
+-                    {
+-                      color_indicator[ind_no].string = buf;
+-                      state = (get_funky_string (&buf, &p, false,
+-                                                 &color_indicator[ind_no].len)
+-                               ? PS_START : PS_FAIL);
+-                      break;
+-                    }
+-                }
+-              if (state == PS_FAIL)
+-                error (0, 0, _("unrecognized prefix: %s"), label);
+-            }
+-          break;
+-
+-        case PS_4:		/* Equal sign after *.ext */
+-          if (*(p++) == '=')
+-            {
+-              ext->seq.string = buf;
+-              state = (get_funky_string (&buf, &p, false, &ext->seq.len)
+-                       ? PS_START : PS_FAIL);
+-            }
+-          else
+-            state = PS_FAIL;
+-          break;
+-
+-        case PS_FAIL:
+-          goto done;
+-
+-        default:
+-          abort ();
+-        }
+-    }
+- done:
+-
+-  if (state == PS_FAIL)
+-    {
+-      struct color_ext_type *e;
+-      struct color_ext_type *e2;
+-
+-      error (0, 0,
+-             _("unparsable value for --palette"));
+-      free (color_buf);
+-      for (e = color_ext_list; e != NULL; /* empty */)
+-        {
+-          e2 = e;
+-          e = e->next;
+-          free (e2);
+-        }
+-      colors_enabled = false;
+-    }
+-}
+-
+-static void
+-check_color_output (bool is_pipe)
+-{
+-  bool output_is_tty;
+-
+-  if (! outfile || colors_style == NEVER)
+-    return;
+-
+-  output_is_tty = presume_output_tty || (!is_pipe && isatty (fileno (outfile)));
+-
+-  colors_enabled = (colors_style == ALWAYS
+-                    || (colors_style == AUTO && output_is_tty));
+-
+-  if (colors_enabled)
+-    parse_diff_color ();
+-
+-  if (output_is_tty)
+-    install_signal_handlers ();
+-}
+-
+-/* Call before outputting the results of comparing files NAME0 and NAME1
+-   to set up OUTFILE, the stdio stream for the output to go to.
+-
+-   Usually, OUTFILE is just stdout.  But when -l was specified
+-   we fork off a 'pr' and make OUTFILE a pipe to it.
+-   'pr' then outputs to our stdout.  */
+ 
+ void
+ setup_output (char const *name0, char const *name1, bool recursive)
+@@ -737,134 +162,43 @@ setup_output (char const *name0, char co
+   outfile = 0;
+ }
+ 
+-#if HAVE_WORKING_FORK
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+ static pid_t pr_pid;
+ #endif
+ 
+-static char c_escape_char (char c)
+-{
+-  switch (c) {
+-    case '\a': return 'a';
+-    case '\b': return 'b';
+-    case '\t': return 't';
+-    case '\n': return 'n';
+-    case '\v': return 'v';
+-    case '\f': return 'f';
+-    case '\r': return 'r';
+-    case '"': return '"';
+-    case '\\': return '\\';
+-    default:
+-      return c < 32;
+-  }
+-}
+-
+-static char *
+-c_escape (char const *str)
+-{
+-  char const *s;
+-  size_t plus = 0;
+-  bool must_quote = false;
+-
+-  for (s = str; *s; s++)
+-    {
+-      char c = *s;
+-
+-      if (c == ' ')
+-	{
+-	  must_quote = true;
+-	  continue;
+-	}
+-      switch (c_escape_char (*s))
+-	{
+-	  case 1:
+-	    plus += 3;
+-	    /* fall through */
+-	  case 0:
+-	    break;
+-	  default:
+-	    plus++;
+-	    break;
+-	}
+-    }
+-
+-  if (must_quote || plus)
+-    {
+-      size_t s_len = s - str;
+-      char *buffer = xmalloc (s_len + plus + 3);
+-      char *b = buffer;
+-
+-      *b++ = '"';
+-      for (s = str; *s; s++)
+-	{
+-	  char c = *s;
+-	  char escape = c_escape_char (c);
+-
+-	  switch (escape)
+-	    {
+-	      case 0:
+-		*b++ = c;
+-		break;
+-	      case 1:
+-		*b++ = '\\';
+-		*b++ = ((c >> 6) & 03) + '0';
+-		*b++ = ((c >> 3) & 07) + '0';
+-		*b++ = ((c >> 0) & 07) + '0';
+-		break;
+-	      default:
+-		*b++ = '\\';
+-		*b++ = escape;
+-		break;
+-	    }
+-	}
+-      *b++ = '"';
+-      *b = 0;
+-      return buffer;
+-    }
+-
+-  return (char *) str;
+-}
+-
+ void
+ begin_output (void)
+ {
+-  char *names[2];
+   char *name;
+ 
+   if (outfile != 0)
+     return;
+ 
+-  names[0] = c_escape (current_name0);
+-  names[1] = c_escape (current_name1);
+-
+   /* Construct the header of this piece of diff.  */
++  name = xmalloc (strlen (current_name0) + strlen (current_name1)
++		  + strlen (switch_string) + 7);
++
+   /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+      the standard: it says that we must print only the last component
+      of the pathnames, and it requires two spaces after "diff" if
+      there are no options.  These requirements are silly and do not
+      match historical practice.  */
+-  name = xasprintf ("diff%s %s %s", switch_string, names[0], names[1]);
++  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+ 
+   if (paginate)
+     {
+-      char const *argv[4];
+-
+       if (fflush (stdout) != 0)
+ 	pfatal_with_name (_("write failed"));
+ 
+-      argv[0] = pr_program;
+-      argv[1] = "-h";
+-      argv[2] = name;
+-      argv[3] = 0;
+-
+-      /* Make OUTFILE a pipe to a subsidiary 'pr'.  */
++      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+       {
+-#if HAVE_WORKING_FORK
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+ 	int pipes[2];
+ 
+ 	if (pipe (pipes) != 0)
+ 	  pfatal_with_name ("pipe");
+ 
+-	pr_pid = fork ();
++	pr_pid = vfork ();
+ 	if (pr_pid < 0)
+ 	  pfatal_with_name ("fork");
+ 
+@@ -878,7 +212,7 @@ begin_output (void)
+ 		close (pipes[0]);
+ 	      }
+ 
+-	    execv (pr_program, (char **) argv);
++	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+ 	    _exit (errno == ENOENT ? 127 : 126);
+ 	  }
+ 	else
+@@ -887,15 +221,19 @@ begin_output (void)
+ 	    outfile = fdopen (pipes[1], "w");
+ 	    if (!outfile)
+ 	      pfatal_with_name ("fdopen");
+-	    check_color_output (true);
+ 	  }
+ #else
+-	char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
++	char *command = xmalloc (sizeof pr_program - 1 + 7
++				 + shell_quote_length (name) + 1);
++	char *p;
++	sprintf (command, "%s -f -h ", pr_program);
++	p = command + sizeof pr_program - 1 + 7;
++	p = shell_quote_copy (p, name);
++	*p = 0;
+ 	errno = 0;
+ 	outfile = popen (command, "w");
+ 	if (!outfile)
+ 	  pfatal_with_name (command);
+-	check_color_output (true);
+ 	free (command);
+ #endif
+       }
+@@ -903,10 +241,9 @@ begin_output (void)
+   else
+     {
+ 
+-      /* If -l was not specified, output the diff straight to 'stdout'.  */
++      /* If -l was not specified, output the diff straight to `stdout'.  */
+ 
+       outfile = stdout;
+-      check_color_output (false);
+ 
+       /* If handling multiple files (because scanning a directory),
+ 	 print which files the following output is about.  */
+@@ -920,25 +257,20 @@ begin_output (void)
+   switch (output_style)
+     {
+     case OUTPUT_CONTEXT:
+-      print_context_header (files, (char const *const *)names, false);
++      print_context_header (files, false);
+       break;
+ 
+     case OUTPUT_UNIFIED:
+-      print_context_header (files, (char const *const *)names, true);
++      print_context_header (files, true);
+       break;
+ 
+     default:
+       break;
+     }
+-
+-  if (names[0] != current_name0)
+-    free (names[0]);
+-  if (names[1] != current_name1)
+-    free (names[1]);
+ }
+ 
+ /* Call after the end of output of diffs for one file.
+-   Close OUTFILE and get rid of the 'pr' subfork.  */
++   Close OUTFILE and get rid of the `pr' subfork.  */
+ 
+ void
+ finish_output (void)
+@@ -950,7 +282,7 @@ finish_output (void)
+       int werrno = 0;
+       if (ferror (outfile))
+ 	fatal ("write failed");
+-#if ! HAVE_WORKING_FORK
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+       wstatus = pclose (outfile);
+       if (wstatus == -1)
+ 	werrno = errno;
+@@ -964,7 +296,7 @@ finish_output (void)
+ 		? WEXITSTATUS (wstatus)
+ 		: INT_MAX);
+       if (status)
+-	die (EXIT_TROUBLE, werrno,
++	error (EXIT_TROUBLE, werrno,
+ 	       _(status == 126
+ 		 ? "subsidiary program '%s' could not be invoked"
+ 		 : status == 127
+@@ -1063,33 +395,6 @@ lines_differ (char const *s1, char const
+ 
+ 	      break;
+ 
+-	    case IGNORE_TRAILING_SPACE:
+-	    case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
+-	      if (isspace (c1) && isspace (c2))
+-		{
+-		  unsigned char c;
+-		  if (c1 != '\n')
+-		    {
+-		      char const *p = t1;
+-		      while ((c = *p) != '\n' && isspace (c))
+-			++p;
+-		      if (c != '\n')
+-			break;
+-		    }
+-		  if (c2 != '\n')
+-		    {
+-		      char const *p = t2;
+-		      while ((c = *p) != '\n' && isspace (c))
+-			++p;
+-		      if (c != '\n')
+-			break;
+-		    }
+-		  /* Both lines have nothing but whitespace left.  */
+-		  return false;
+-		}
+-	      if (ignore_white_space == IGNORE_TRAILING_SPACE)
+-		break;
+-	      FALLTHROUGH;
+ 	    case IGNORE_TAB_EXPANSION:
+ 	      if ((c1 == ' ' && c2 == '\t')
+ 		  || (c1 == '\t' && c2 == ' '))
+@@ -1145,13 +450,13 @@ lines_differ (char const *s1, char const
+ /* Find the consecutive changes at the start of the script START.
+    Return the last link before the first gap.  */
+ 
+-struct change * _GL_ATTRIBUTE_CONST
++struct change *
+ find_change (struct change *start)
+ {
+   return start;
+ }
+ 
+-struct change * _GL_ATTRIBUTE_CONST
++struct change *
+ find_reverse_change (struct change *start)
+ {
+   return start;
+@@ -1207,18 +512,6 @@ print_script (struct change *script,
+ void
+ print_1_line (char const *line_flag, char const *const *line)
+ {
+-  print_1_line_nl (line_flag, line, false);
+-}
+-
+-/* Print the text of a single line LINE,
+-   flagging it with the characters in LINE_FLAG (which say whether
+-   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+-   end in a blank, unless it is a single blank.  If SKIP_NL is set, then
+-   the final '\n' is not printed.  */
+-
+-void
+-print_1_line_nl (char const *line_flag, char const *const *line, bool skip_nl)
+-{
+   char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+   FILE *out = outfile; /* Help the compiler some more.  */
+   char const *flag_format = 0;
+@@ -1246,13 +539,10 @@ print_1_line_nl (char const *line_flag,
+       fprintf (out, flag_format_1, line_flag_1);
+     }
+ 
+-  output_1_line (base, limit - (skip_nl && limit[-1] == '\n'), flag_format, line_flag);
++  output_1_line (base, limit, flag_format, line_flag);
+ 
+   if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+-    {
+-      set_color_context (RESET_CONTEXT);
+-      fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+-    }
++    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+ }
+ 
+ /* Output a line from BASE up to LIMIT.
+@@ -1264,21 +554,8 @@ void
+ output_1_line (char const *base, char const *limit, char const *flag_format,
+ 	       char const *line_flag)
+ {
+-  const size_t MAX_CHUNK = 1024;
+   if (!expand_tabs)
+-    {
+-      size_t left = limit - base;
+-      while (left)
+-        {
+-          size_t to_write = MIN (left, MAX_CHUNK);
+-          size_t written = fwrite (base, sizeof (char), to_write, outfile);
+-          if (written < to_write)
+-            return;
+-          base += written;
+-          left -= written;
+-          process_signals ();
+-        }
+-    }
++    fwrite (base, sizeof (char), limit - base, outfile);
+   else
+     {
+       register FILE *out = outfile;
+@@ -1286,104 +563,42 @@ output_1_line (char const *base, char co
+       register char const *t = base;
+       register size_t column = 0;
+       size_t tab_size = tabsize;
+-      size_t counter_proc_signals = 0;
+ 
+       while (t < limit)
+-        {
+-          counter_proc_signals++;
+-          if (counter_proc_signals == MAX_CHUNK)
+-            {
+-              process_signals ();
+-              counter_proc_signals = 0;
+-            }
+-
+-          switch ((c = *t++))
+-            {
+-            case '\t':
+-              {
+-                size_t spaces = tab_size - column % tab_size;
+-                column += spaces;
+-                do
+-                  putc (' ', out);
+-                while (--spaces);
+-              }
+-              break;
+-
+-            case '\r':
+-              putc (c, out);
+-              if (flag_format && t < limit && *t != '\n')
+-                fprintf (out, flag_format, line_flag);
+-              column = 0;
+-              break;
+-
+-            case '\b':
+-              if (column == 0)
+-                continue;
+-              column--;
+-              putc (c, out);
+-              break;
+-
+-            default:
+-              column += isprint (c) != 0;
+-              putc (c, out);
+-              break;
+-            }
+-        }
+-    }
+-}
+-
+-enum indicator_no
+-  {
+-    C_LEFT, C_RIGHT, C_END, C_RESET, C_HEADER, C_ADD, C_DELETE, C_LINE
+-  };
++	switch ((c = *t++))
++	  {
++	  case '\t':
++	    {
++	      size_t spaces = tab_size - column % tab_size;
++	      column += spaces;
++	      do
++		putc (' ', out);
++	      while (--spaces);
++	    }
++	    break;
+ 
+-static void
+-put_indicator (const struct bin_str *ind)
+-{
+-  fwrite (ind->string, ind->len, 1, outfile);
+-}
++	  case '\r':
++	    putc (c, out);
++	    if (flag_format && t < limit && *t != '\n')
++	      fprintf (out, flag_format, line_flag);
++	    column = 0;
++	    break;
+ 
+-static enum color_context last_context = RESET_CONTEXT;
++	  case '\b':
++	    if (column == 0)
++	      continue;
++	    column--;
++	    putc (c, out);
++	    break;
+ 
+-void
+-set_color_context (enum color_context color_context)
+-{
+-  if (color_context != RESET_CONTEXT)
+-    process_signals ();
+-  if (colors_enabled && last_context != color_context)
+-    {
+-      put_indicator (&color_indicator[C_LEFT]);
+-      switch (color_context)
+-        {
+-        case HEADER_CONTEXT:
+-          put_indicator (&color_indicator[C_HEADER]);
+-          break;
+-
+-        case LINE_NUMBER_CONTEXT:
+-          put_indicator (&color_indicator[C_LINE]);
+-          break;
+-
+-        case ADD_CONTEXT:
+-          put_indicator (&color_indicator[C_ADD]);
+-          break;
+-
+-        case DELETE_CONTEXT:
+-          put_indicator (&color_indicator[C_DELETE]);
+-          break;
+-
+-        case RESET_CONTEXT:
+-          put_indicator (&color_indicator[C_RESET]);
+-          break;
+-
+-        default:
+-          abort ();
+-        }
+-      put_indicator (&color_indicator[C_RIGHT]);
+-      last_context = color_context;
++	  default:
++	    column += isprint (c) != 0;
++	    putc (c, out);
++	    break;
++	  }
+     }
+ }
+ 
+-
+ char const change_letter[] = { 0, 'd', 'a', 'c' };
+ 
+ /* Translate an internal line number (an index into diff's table of lines)
+@@ -1393,20 +608,20 @@ char const change_letter[] = { 0, 'd', '
+    Internal line numbers count from 0 starting after the prefix.
+    Actual line numbers count from 1 within the entire file.  */
+ 
+-lin _GL_ATTRIBUTE_PURE
++lin
+ translate_line_number (struct file_data const *file, lin i)
+ {
+   return i + file->prefix_lines + 1;
+ }
+ 
+ /* Translate a line number range.  This is always done for printing,
+-   so for convenience translate to printint rather than lin, so that the
+-   caller can use printf with "%"pI"d" without casting.  */
++   so for convenience translate to long int rather than lin, so that the
++   caller can use printf with "%ld" without casting.  */
+ 
+ void
+ translate_range (struct file_data const *file,
+ 		 lin a, lin b,
+-		 printint *aptr, printint *bptr)
++		 long int *aptr, long int *bptr)
+ {
+   *aptr = translate_line_number (file, a - 1) + 1;
+   *bptr = translate_line_number (file, b + 1) - 1;
+@@ -1421,21 +636,21 @@ translate_range (struct file_data const
+ void
+ print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+ {
+-  printint trans_a, trans_b;
++  long int trans_a, trans_b;
+   translate_range (file, a, b, &trans_a, &trans_b);
+ 
+   /* Note: we can have B < A in the case of a range of no lines.
+      In this case, we should print the line number before the range,
+      which is B.  */
+   if (trans_b > trans_a)
+-    fprintf (outfile, "%"pI"d%c%"pI"d", trans_a, sepchar, trans_b);
++    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+   else
+-    fprintf (outfile, "%"pI"d", trans_b);
++    fprintf (outfile, "%ld", trans_b);
+ }
+ 
+ /* Look at a hunk of edit script and report the range of lines in each file
+    that it applies to.  HUNK is the start of the hunk, which is a chain
+-   of 'struct change'.  The first and last line numbers of file 0 are stored in
++   of `struct change'.  The first and last line numbers of file 0 are stored in
+    *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+    Note that these are internal line numbers that count from 0.
+ 
+@@ -1459,11 +674,8 @@ analyze_hunk (struct change *hunk,
+   size_t trivial_length = ignore_blank_lines - 1;
+     /* If 0, ignore zero-length lines;
+        if SIZE_MAX, do not ignore lines just because of their length.  */
+-
+-  bool skip_white_space =
+-    ignore_blank_lines && IGNORE_TRAILING_SPACE <= ignore_white_space;
+   bool skip_leading_white_space =
+-    skip_white_space && IGNORE_SPACE_CHANGE <= ignore_white_space;
++    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+ 
+   char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+   char const * const *linbuf1 = files[1].linbuf;
+@@ -1484,18 +696,12 @@ analyze_hunk (struct change *hunk,
+       for (i = next->line0; i <= l0 && trivial; i++)
+ 	{
+ 	  char const *line = linbuf0[i];
+-	  char const *lastbyte = linbuf0[i + 1] - 1;
+-	  char const *newline = lastbyte + (*lastbyte != '\n');
++	  char const *newline = linbuf0[i + 1] - 1;
+ 	  size_t len = newline - line;
+ 	  char const *p = line;
+-	  if (skip_white_space)
+-	    for (; *p != '\n'; p++)
+-	      if (! isspace ((unsigned char) *p))
+-		{
+-		  if (! skip_leading_white_space)
+-		    p = line;
+-		  break;
+-		}
++	  if (skip_leading_white_space)
++	    while (isspace ((unsigned char) *p) && *p != '\n')
++	      p++;
+ 	  if (newline - p != trivial_length
+ 	      && (! ignore_regexp.fastmap
+ 		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+@@ -1505,18 +711,12 @@ analyze_hunk (struct change *hunk,
+       for (i = next->line1; i <= l1 && trivial; i++)
+ 	{
+ 	  char const *line = linbuf1[i];
+-	  char const *lastbyte = linbuf1[i + 1] - 1;
+-	  char const *newline = lastbyte + (*lastbyte != '\n');
++	  char const *newline = linbuf1[i + 1] - 1;
+ 	  size_t len = newline - line;
+ 	  char const *p = line;
+-	  if (skip_white_space)
+-	    for (; *p != '\n'; p++)
+-	      if (! isspace ((unsigned char) *p))
+-		{
+-		  if (! skip_leading_white_space)
+-		    p = line;
+-		  break;
+-		}
++	  if (skip_leading_white_space)
++	    while (isspace ((unsigned char) *p) && *p != '\n')
++	      p++;
+ 	  if (newline - p != trivial_length
+ 	      && (! ignore_regexp.fastmap
+ 		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+@@ -1556,6 +756,18 @@ zalloc (size_t size)
+   memset (p, 0, size);
+   return p;
+ }
++
++/* Yield the newly malloc'd pathname
++   of the file in DIR whose filename is FILE.  */
++
++char *
++dir_file_pathname (char const *dir, char const *file)
++{
++  char const *base = last_component (dir);
++  size_t baselen = base_len (base);
++  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
++  return concat (dir, "/" + omit_slash, file);
++}
+ 
+ void
+ debug_script (struct change *sp)
+@@ -1564,11 +776,11 @@ debug_script (struct change *sp)
+ 
+   for (; sp; sp = sp->link)
+     {
+-      printint line0 = sp->line0;
+-      printint line1 = sp->line1;
+-      printint deleted = sp->deleted;
+-      printint inserted = sp->inserted;
+-      fprintf (stderr, "%3"pI"d %3"pI"d delete %"pI"d insert %"pI"d\n",
++      long int line0 = sp->line0;
++      long int line1 = sp->line1;
++      long int deleted = sp->deleted;
++      long int inserted = sp->inserted;
++      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+ 	       line0, line1, deleted, inserted);
+     }
+ 
+Only in diffutils-3.0-patch/src: util.o
diff --git a/src/cmp.c.orig b/src/cmp.c.orig
new file mode 100644
index 0000000..e19f013
--- /dev/null
+++ b/src/cmp.c.orig
@@ -0,0 +1,685 @@
+/* cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *);
+static size_t block_compare_and_count (word const *, word const *, off_t *);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value '%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b  --print-bytes  Print differing bytes."),
+  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
+  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
+  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
+  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
+  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
+  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare two files byte by byte."));
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n%s\n\n%s\n%s\n",
+	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after '%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand '%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    xfreopen (NULL, "rb", stdin);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      error (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
+   using `buffer[0]' and `buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of `read0' and `read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      /* Insert sentinels for the block compare.  */
+
+      buf0[read0] = ~buf1[read0];
+      buf1[read1] = ~buf0[read1];
+
+      /* If the line number should be written for differing files,
+	 compare the blocks and count the number of newlines
+	 simultaneously.  */
+      first_diff = (comparison_type == type_first_diff
+		    ? block_compare_and_count (buffer0, buffer1, &line_number)
+		    : block_compare (buffer0, buffer1));
+
+      byte_number += first_diff;
+      smaller = MIN (read0, read1);
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX 1003.1-2001 for this format.  This
+		       message is used only in the POSIX locale, so it
+		       need not be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		}
+	      }
+	      /* Fall through.  */
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX 1003.1-2001 for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ,
+   and count the number of '\n' occurrences in the common
+   part of P0 and P1.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.
+   Increment *COUNT by the count of '\n' occurrences.  */
+
+static size_t
+block_compare_and_count (word const *p0, word const *p1, off_t *count)
+{
+  word l;		/* One word from first buffer. */
+  word const *l0, *l1;	/* Pointers into each buffer. */
+  char const *c0, *c1;	/* Pointers for finding exact address. */
+  size_t cnt = 0;	/* Number of '\n' occurrences. */
+  word nnnn;		/* Newline, sizeof (word) times.  */
+  int i;
+
+  nnnn = 0;
+  for (i = 0; i < sizeof nnnn; i++)
+    nnnn = (nnnn << CHAR_BIT) | '\n';
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
+    {
+      l ^= nnnn;
+      for (i = 0; i < sizeof l; i++)
+	{
+	  unsigned char uc = l;
+	  cnt += ! uc;
+	  l >>= CHAR_BIT;
+	}
+    }
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    cnt += *c0 == '\n';
+
+  *count += cnt;
+  return c0 - (char const *) p0;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/src/diff.c b/src/diff.c
index cc1b611..3f78acc 100644
--- a/src/diff.c
+++ b/src/diff.c
@@ -57,9 +57,9 @@
 struct regexp_list
 {
   char *regexps;	/* chars representing disjunction of the regexps */
-  size_t len;		/* chars used in `regexps' */
-  size_t size;		/* size malloc'ed for `regexps'; 0 if not malloc'ed */
-  bool multiple_regexps;/* Does `regexps' represent a disjunction?  */
+  size_t len;		/* chars used in 'regexps' */
+  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
   struct re_pattern_buffer *buf;
 };
 
diff --git a/src/diff.c.orig b/src/diff.c.orig
new file mode 100644
index 0000000..365bea0
--- /dev/null
+++ b/src/diff.c.orig
@@ -0,0 +1,1330 @@
+/* diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in 'regexps' */
+  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* When comparing directories, if a file appears only in one
+   directory, treat it as present but empty in the other (-N).
+   Then `patch' would create the file with appropriate contents.  */
+static bool new_file;
+
+/* When comparing directories, if a file appears only in the second
+   directory of the two, treat it as present but empty in the other
+   (--unidirectional-new-file).
+   Then `patch' would create the file with appropriate contents.  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (! ISDIGIT (prev))
+	    ocontext = c - '0';
+	  else if (LIN_MAX / 10 < ocontext
+		   || ((ocontext = 10 * ocontext + c - '0') < 0))
+	    ocontext = LIN_MAX;
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (LIN_MAX < numval)
+		  numval = LIN_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
+	    ignore_white_space = IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    xfreopen (NULL, "wb", stdout);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    intmax_t t = expand_tabs ? 1 : tabsize;
+    intmax_t w = width;
+    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
+    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (0, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("Compare files line by line."),
+  "",
+  N_("-i  --ignore-case  Ignore case differences in file contents."),
+  N_("--ignore-file-name-case  Ignore case when comparing file names."),
+  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-w  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+#if O_BINARY
+  N_("--binary  Read and write data in binary mode."),
+#endif
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
+-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
+  --label LABEL  Use LABEL instead of file name.\n\
+  -p  --show-c-function  Show which C function each change is in.\n\
+  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
+  N_("-q  --brief  Output only whether files differ."),
+  N_("-e  --ed  Output an ed script."),
+  N_("--normal  Output a normal diff."),
+  N_("-n  --rcs  Output an RCS format diff."),
+  N_("-y  --side-by-side  Output in two columns.\n\
+  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+  --left-column  Output only the left column of common lines.\n\
+  --suppress-common-lines  Do not output common lines."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
+  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+  N_("  GFMT may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1"),
+  N_("  LFMT may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Either GFMT or LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO"),
+  "",
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+  "",
+  N_("-r  --recursive  Recursively compare any subdirectories found."),
+  N_("-N  --new-file  Treat absent files as empty."),
+  N_("--unidirectional-new-file  Treat absent first files as empty."),
+  N_("-s  --report-identical-files  Report when two files are the same."),
+  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
+  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
+  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
+  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
+  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+  "",
+  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("--speed-large-files  Assume large files and many scattered small changes."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+  N_("If a FILE is '-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && strcmp (*var, value) != 0)
+    {
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= dir_file_pathname (parent->file[0].name, name0);
+      cmp.file[1].name = free1
+	= dir_file_pathname (parent->file[1].name, name1);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
+		xfreopen (NULL, "rb", stdin);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+	       && ! parent
+	       && cmp.file[1 - f].desc == UNOPENED)))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare '-' to a directory");
+
+      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && (! S_ISREG (cmp.file[0].stat.st_mode)
+		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/src/diff3.c.orig b/src/diff3.c.orig
new file mode 100644
index 0000000..885a194
--- /dev/null
+++ b/src/diff3.c.orig
@@ -0,0 +1,1747 @@
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include `:wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  /* Fall through.  */
+	case 'E':
+	  flagging = true;
+	  /* Fall through.  */
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("'-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (strcmp (file[i], "-") != 0)
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+  diff3 = make_3way_diff (thread0, thread1);
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  check_stdout ();
+  exit (conflicts_found);
+  return conflicts_found;
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
+  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
+  N_("-A  --show-all  Output all changes, bracketing conflicts."),
+  N_("-x  --overlap-only  Output overlapping changes."),
+  N_("-X  Output overlapping changes, bracketing them."),
+  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+  "",
+  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+  N_("-i  Append 'w' and `q' commands to ed scripts."),
+  N_("-a  --text  Treat all files as text."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char *
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+
+  char const *argv[9];
+  char const **ap;
+  int fds[2];
+  pid_t pid;
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = vfork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  FILE *fpipe;
+  char const args[] = " --horizon-lines=100 -- ";
+  char *command = xmalloc (shell_quote_length (diff_program)
+			   + sizeof "-a"
+			   + sizeof "--strip-trailing-cr"
+			   + sizeof args - 1
+			   + shell_quote_length (filea) + 1
+			   + shell_quote_length (fileb) + 1);
+  char *p = command;
+  p = shell_quote_copy (p, diff_program);
+  if (text)
+    {
+      strcpy (p, " -a");
+      p += 3;
+    }
+  if (strip_trailing_cr)
+    {
+      strcpy (p, " --strip-trailing-cr");
+      p += 20;
+    }
+  strcpy (p, args);
+  p += sizeof args - 1;
+  p = shell_quote_copy (p, filea);
+  *p++ = ' ';
+  p = shell_quote_copy (p, fileb);
+  *p = 0;
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    error (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  long int llowt = lowt;
+	  long int lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%lda\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  (START is long int, not lin, for
+   convenience with printf %ld formats.)  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%lds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in `output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      long int low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%lda\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%ldd\n", low0);
+	  else
+	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%lda\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  error (EXIT_TROUBLE, errno, "%s", string);
+  abort ();
+}
diff --git a/src/dir.c.orig b/src/dir.c.orig
new file mode 100644
index 0000000..5e08318
--- /dev/null
+++ b/src/dir.c.orig
@@ -0,0 +1,283 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+static int compare_names_for_qsort (void const *, void const *);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the `data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the `names' table from the `data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int r;
+      errno = 0;
+      if (ignore_file_name_case)
+	r = strcasecoll (name1, name2);
+      else
+	r = strcoll (name1, name2);
+      if (errno)
+	{
+	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+		 name1, name2);
+	  longjmp (failed_locale_specific_sorting, 1);
+	}
+      return r;
+    }
+
+  return (ignore_file_name_case
+	  ? strcasecmp (name1, name2)
+	  : file_name_cmp (name1, name2));
+}
+
+/* A wrapper for compare_names suitable as an argument for qsort.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  return compare_names (*f1, *f2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If `-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
diff --git a/src/sdiff.c b/src/sdiff.c
index 4344e8d..a85a44c 100644
--- a/src/sdiff.c
+++ b/src/sdiff.c
@@ -747,7 +747,7 @@ main (int argc, char *argv[])
 	exit (WEXITSTATUS (wstatus));
       }
     }
-  return EXIT_SUCCESS;			/* Fool `-Wall'.  */
+  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
 }
 
 static void
diff --git a/src/sdiff.c.orig b/src/sdiff.c.orig
new file mode 100644
index 0000000..6ea6f0a
--- /dev/null
+++ b/src/sdiff.c.orig
@@ -0,0 +1,1236 @@
+/* sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+#endif
+       SIGINT
+#define handler_index_of_SIGINT (NUM_SIGS - 1)
+};
+
+#if HAVE_SIGACTION
+  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+#if ! HAVE_SIGPROCMASK
+# define sigset_t int
+# define sigemptyset(s) (*(s) = 0)
+# ifndef sigmask
+#  define sigmask(sig) (1 << ((sig) - 1))
+# endif
+# define sigaddset(s, sig) (*(s) |= sigmask (sig))
+# ifndef SIG_BLOCK
+#  define SIG_BLOCK 0
+# endif
+# ifndef SIG_SETMASK
+#  define SIG_SETMASK (! SIG_BLOCK)
+# endif
+# if ! HAVE_SIGBLOCK
+#  define sigblock(mask) (mask)
+#  define sigsetmask(mask) (mask)
+# endif
+# define sigprocmask(how, n, o) \
+    ((how) == SIG_BLOCK \
+     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
+     : sigsetmask (*(n)))
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+  "",
+  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-W  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
+  N_("-l  --left-column  Output only the left column of common lines."),
+  N_("-s  --suppress-common-lines  Do not output common lines."),
+  "",
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  "",
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      {
+	size_t cmdsize = 1;
+	char *p, *command;
+	int i;
+
+	for (i = 0;  diffargv[i];  i++)
+	  cmdsize += shell_quote_length (diffargv[i]) + 1;
+	command = p = xmalloc (cmdsize);
+	for (i = 0;  diffargv[i];  i++)
+	  {
+	    p = shell_quote_copy (p, diffargv[i]);
+	    *p++ = ' ';
+	  }
+	p[-1] = 0;
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+# if HAVE_WORKING_VFORK
+	sigset_t procmask;
+	sigset_t blocked;
+# endif
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+# if HAVE_WORKING_VFORK
+	/* Block SIGINT and SIGPIPE.  */
+	sigemptyset (&blocked);
+	sigaddset (&blocked, SIGINT);
+	sigaddset (&blocked, SIGPIPE);
+	sigprocmask (SIG_BLOCK, &blocked, &procmask);
+# endif
+	diffpid = vfork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+# if HAVE_WORKING_VFORK
+	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
+	    sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+# if HAVE_WORKING_VFORK
+	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
+	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	  signal_handler (SIGINT, catchsig);
+	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
+	  signal_handler (SIGPIPE, catchsig);
+	else
+	  signal_handler (SIGPIPE, SIG_IGN);
+
+	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
+	sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      kill (getpid (), s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	      flush_line ();
+	      /* Fall through.  */
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+		    else
+		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
+			       (long int) lline,
+			       (long int) (lline + llen - 1));
+		  }
+		/* Fall through.  */
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+		    else
+		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
+			       (long int) rline,
+			       (long int) (rline + rlen - 1));
+		  }
+		/* Fall through.  */
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      ignore_SIGINT = true;
+	      checksigs ();
+
+	      {
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+		char *command =
+		  xmalloc (shell_quote_length (editor_program)
+			   + 1 + strlen (tmpname) + 1);
+		sprintf (shell_quote_copy (command, editor_program),
+			 " %s", tmpname);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = vfork ();
+		if (pid == 0)
+		  {
+		    char const *argv[3];
+		    int i = 0;
+
+		    argv[i++] = editor_program;
+		    argv[i++] = tmpname;
+		    argv[i] = 0;
+
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  llen = val = strtoumax (diff_help + 1, &numend, 10);
+	  if (llen < 0 || llen != val || errno || *numend != ',')
+	    fatal (diff_help);
+	  rlen = val = strtoumax (numend + 1, &numend, 10);
+	  if (rlen < 0 || rlen != val || errno || *numend)
+	    fatal (diff_help);
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  int e;
+  sigset_t procmask;
+  sigset_t blocked;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  sigemptyset (&blocked);
+  sigaddset (&blocked, SIGINT);
+  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+  fd = mkstemp (buf);
+  e = errno;
+  if (0 <= fd)
+    tmpname = buf;
+  sigprocmask (SIG_SETMASK, &procmask, 0);
+  errno = e;
+  return fd;
+}
diff --git a/src/util.c.orig b/src/util.c.orig
new file mode 100644
index 0000000..d18bf38
--- /dev/null
+++ b/src/util.c.orig
@@ -0,0 +1,788 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <dirname.h>
+#include <error.h>
+#include <sh-quote.h>
+#include <xalloc.h>
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a `struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  error (EXIT_TROUBLE, e, "%s", name);
+  abort ();
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to `message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a `pr' and make OUTFILE a pipe to it.
+   `pr' then outputs to our stdout.  */
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t pr_pid;
+#endif
+
+void
+begin_output (void)
+{
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  /* Construct the header of this piece of diff.  */
+  name = xmalloc (strlen (current_name0) + strlen (current_name1)
+		  + strlen (switch_string) + 7);
+
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+
+  if (paginate)
+    {
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+      {
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = vfork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	  }
+#else
+	char *command = xmalloc (sizeof pr_program - 1 + 7
+				 + shell_quote_length (name) + 1);
+	char *p;
+	sprintf (command, "%s -f -h ", pr_program);
+	p = command + sizeof pr_program - 1 + 7;
+	p = shell_quote_copy (p, name);
+	*p = 0;
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to `stdout'.  */
+
+      outfile = stdout;
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, true);
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the `pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	error (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change *
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change *
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit, flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  if (!expand_tabs)
+    fwrite (base, sizeof (char), limit - base, outfile);
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+
+      while (t < limit)
+	switch ((c = *t++))
+	  {
+	  case '\t':
+	    {
+	      size_t spaces = tab_size - column % tab_size;
+	      column += spaces;
+	      do
+		putc (' ', out);
+	      while (--spaces);
+	    }
+	    break;
+
+	  case '\r':
+	    putc (c, out);
+	    if (flag_format && t < limit && *t != '\n')
+	      fprintf (out, flag_format, line_flag);
+	    column = 0;
+	    break;
+
+	  case '\b':
+	    if (column == 0)
+	      continue;
+	    column--;
+	    putc (c, out);
+	    break;
+
+	  default:
+	    column += isprint (c) != 0;
+	    putc (c, out);
+	    break;
+	  }
+    }
+}
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to long int rather than lin, so that the
+   caller can use printf with "%ld" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 long int *aptr, long int *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%ld", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of `struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+  bool skip_leading_white_space =
+    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *newline = linbuf0[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *newline = linbuf1[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+/* Yield the newly malloc'd pathname
+   of the file in DIR whose filename is FILE.  */
+
+char *
+dir_file_pathname (char const *dir, char const *file)
+{
+  char const *base = last_component (dir);
+  size_t baselen = base_len (base);
+  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
+  return concat (dir, "/" + omit_slash, file);
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      long int line0 = sp->line0;
+      long int line1 = sp->line1;
+      long int deleted = sp->deleted;
+      long int inserted = sp->inserted;
+      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
-- 
1.8.5.3

